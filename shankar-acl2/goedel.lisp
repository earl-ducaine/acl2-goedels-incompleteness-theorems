
;; Copyright (C) 1994 by Natarajan Shankar.  All Rights Reserved.
;;
;; This script is hereby placed in the public domain, and therefore unlimited
;; editing and redistribution is permitted.
;;
;; NO WARRANTY
;;
;; Natarajan Shankar PROVIDES ABSOLUTELY NO WARRANTY.  THE EVENT SCRIPT IS
;; PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
;; INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF MERCHANTABILITY AND
;; FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
;; PERFORMANCE OF THE SCRIPT IS WITH YOU.  SHOULD THE SCRIPT PROVE DEFECTIVE, YOU
;; ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
;;
;; IN NO EVENT WILL Natarajan Shankar BE LIABLE TO YOU FOR ANY DAMAGES, ANY LOST
;; PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
;; ARISING OUT OF THE USE OR INABILITY TO USE THIS SCRIPT (INCLUDING BUT NOT
;; LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED
;; BY THIRD PARTIES), EVEN IF YOU HAVE ADVISED US OF THE POSSIBILITY OF SUCH
;; DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.



;;;   The Mechanical Proof of Goedel's Incompleteness Theorem
;;;                            by
;;;                        N. Shankar

;;;
;;;  I:  Defining the Proof-checker for Z2         ;;
;;;


;; Recognizers for function, variable, and predicate symbols.


;; To allow duplicates for hacking
;; (set-ld-redefinition-action '(:doit . :overwrite) state)


(defun g-function (fn) (equal (car fn) 2))
(defun g-variable (x) (acl2-numberp x))
(defun predicate (p) (equal (car p) 3))


;; Degree (arity) and index (subscript) of a function/predicate symbol.

(defun degree (fn)
  (fix (caddr fn)))

(defun index (fn)
  (fix (cadr fn)))


;; (v x) generates the xth variable

(defun v (x) (fix x))

(defthm numberp-fix
    (acl2-numberp (fix x))
  :rule-classes :type-prescription)

(defthm g-variable-v
    (g-variable (v x))
  :rule-classes :type-prescription)


;; fn generates function symbol with index x and arity y.
(defun fn (x y)
  (list 2 (fix x) (fix y)))


;; p generates the predicate symbol with index x and arity y.
(defun p (x y)
  (list 3 (fix x) (fix y)))

(defthm g-function-fn
    (g-function (fn x y))
  :rule-classes :type-prescription)

(defthm predicate-p
    (predicate (p x y))
  :rule-classes :type-prescription)


;;f-or is the disjunction shell.
;; (add-shell f-or nil f-orp

(defun f-orp (x)
  (equal (car x) 'z2-or))

(defun f-or (x y)
  (list 'z2-or x y))

(defun arg1 (x)
  (cadr x))

(defun arg2 (x)
  (caddr x))


;; f-not is the negation shell.

(defun f-not (x)
  (list 'z2-not x))

(defun f-notp (x)
  (equal (car x) 'z2-not))

(defun arg (x)
  (cadr x))



;;forsome is the existential quantification shell.

(defun forsomep (x)
  (equal (car x) 'z2-forsome))

(defun forsome (x y)
  (list 'z2-forsome (fix x) y))

(defun bind (x)
  (fix (cadr x)))



;; EQL is the equality predicate for z2 expressions.  Strict equality EQUAL
;; cannot be used since expressions will be goedel-encoded, and it is possible
;; two different expressions to have the same goedel-encoding.  EQL essentially
;; checks that its two arguments have the same encoding.

(defun fix1 (x)
  (if (acl2-numberp x) x nil))

(defun g-body (x)
  (caddr x))


(defthm bind-count
    (implies (forsomep x)
             (< (acl2-count (bind x)) (acl2-count x))))


(defun g-eql (x y)
  (if (consp x)
      (if (consp y)
          (and (g-eql (car x) (car y))
               (g-eql (cdr x) (cdr y)))
          nil)
      (if (consp y)
          nil
          (equal x y))))


;; (defun g-eql (x y)
;;   (if (consp x)
;;       (if (consp y)
;;           (and (g-eql (car x) (car y))
;;                (g-eql (cdr x) (cdr y)))
;;           nil)
;;       (if (consp y)
;;           nil
;;           (if (f-notp x)
;;               (if (f-notp y) (g-eql (arg x) (arg y)) nil)
;;               (if (f-notp y)
;;                   nil
;;                   (if (f-orp x)
;;                       (if (f-orp y)
;;                           (and (g-eql (arg1 x) (arg1 y))
;;                                (g-eql (arg2 x) (arg2 y)))
;;                           nil)
;;                       (if (f-orp y)
;;                           nil
;;                           (if (forsomep x)
;;                               (if (forsomep y)
;;                                   (and (equal (bind x) (bind y))
;;                                        (g-eql (g-body x) (g-body y)))
;;                                   nil)
;;                               (if (forsomep y)
;;                                   nil
;;                                   (equal (fix1 x) (fix1 y)))))))))))



(defthm eql-comm
    (equal (g-eql x y) (g-eql y x)))


(defthm equal-eql
    (implies (equal x y) (g-eql x y)))


(defthm acl2-numberp-eql
    (implies (or (acl2-numberp x)
                 (acl2-numberp y))
             (equal (g-eql x y) (equal x y))))


(defthm consp-eql
    (equal (g-eql (cons x y) (cons u v))
           (and (g-eql x u)
                (g-eql y v))))


(defthm f-notp-eql
    (equal (g-eql (f-not x) (f-not y)) (g-eql x y)))


(defthm f-orp-eql
    (equal (g-eql (f-or x y) (f-or u v))
           (and (g-eql x u)
                (g-eql y v))))


(defthm forsomep-eql
    (equal (g-eql (forsome x y) (forsome u v))
           (and (equal (fix x) (fix u))
                (g-eql y v))))


;; memb checks if x is a member of y, using eql.
(defun memb (x y)
  (if (and (true-listp y)
           (not (null y)))
      (if (g-eql x (car y))
          t
          (memb x (cdr y)))
      nil))


(defthm degree-fn (equal (degree (fn x y)) (fix y)))


(defthm degree-p (equal (degree (p x y)) (fix y)))


(defthm index-fn (equal (index (fn x y)) (fix x)))


(defthm index-p (equal (index (p x y)) (fix x)))


(defthm not-function
    (implies (or (atom x)
                 (predicate x))
             (not (g-function x))))


(defthm not-predicate
    (implies (or (atom x)
                 (g-function x))
             (not (predicate x))))


(in-theory (disable index degree v fn p g-function predicate))


;; x is a function or a predicate.
(defun func-pred (x)
  (or (g-function x)
      (predicate x)))

;; Append concatenates two lists.
(defun g-append (x y)
  (cond
    ((and (true-listp x)
          (true-listp y))
     (if (not (null x))
         (cons (car x) (g-append (cdr x) y))
         y))
    ((true-listp x) x)
    ((true-listp y) y)
    (t nil)))




;; del deletes all occurrences of x from list y, using eql.
(defun del (x y)
  (if (and (true-listp y)
           (not (null y)))
      (if (g-eql x (car y))
          (del x (cdr y))
          (cons (car y) (del x (cdr y))))
      nil))


(defthm not-memb-del
    (not (memb x (del x y))))


;; COLLECT-FREE collects a list of all the free variables in the
;; expression/list of expressions EXP, depending on (ZEROP FLG).
(defun collect-free (exp flg)
  (if (zerop flg)
      (if (g-variable exp)
          (cons exp nil)
          (if (f-notp exp)
              (collect-free (arg exp) 0)
              (if (f-orp exp)
                  (g-append (collect-free (arg1 exp) 0)
                            (collect-free (arg2 exp) 0))
                  (if (forsomep exp)
                      (del (bind exp) (collect-free (g-body exp) 0))
                      (if (consp exp) (collect-free (cdr exp) 1) nil)))))
      (if (consp exp)
          (g-append (collect-free (car exp) 0)
                    (collect-free (cdr exp) 1))
          nil)))


(defun sentence (exp)
  (equal (collect-free exp 0) nil))


;; Covering collects a list of all bound variables that govern free occurrences
;; of var in exp.
(defun covering (exp var flg)
  (if (zerop flg)
      (if (f-notp exp)
          (covering (arg exp) var 0)
          (if (f-orp exp)
              (g-append (covering (arg1 exp) var 0) (covering (arg2 exp) var 0))
              (if (forsomep exp)
                  (if (memb var (collect-free exp 0))
                      (cons (bind exp) (covering (g-body exp) var 0))
                      nil)
                  (if (consp exp) (covering (cdr exp) var 1) nil))))
      (if (consp exp)
          (g-append (covering (car exp) var 0)
                    (covering (cdr exp) var 1))
          nil)))


;; X and Y have no common elements.
(defun nil-intersect (x y)
  (if (consp x)
      (and (not (memb (car x) y))
           (nil-intersect (cdr x) y))
      t))


;; TERM is free-for VAR in EXP, if no free occurrence of VAR in EXP is governed
;; by a variable which occurs free in term.
(defun free-for (exp var term flg)
  (nil-intersect (covering exp var flg) (collect-free term 0)))


;; (F-EQUAL X Y) is the z2 expression for (X = Y).

(defun f-equal (x y)
  (list (p 0 2) x y))



(defthm or-memb-append
    (equal (memb x (g-append y z))
           (or (memb x y)
               (memb x z))))


(defthm memb-del
    (implies (and (not (g-eql x z))
                  (true-listp y))
             (g-eql (memb x (del z y)) (memb x y))))


;; VAR-LIST checks that list is a list of N variables.
(defun var-list (list n)
  (if (or (zerop n)
          (atom list))
      (and (zerop n)
           (atom list))
      (and (g-variable (car list))
           (var-list (cdr list) (1- n)))))


;; SYMB checks that X is either the equality symbol, or appears in list
;; symbols.
(defun symb (x symbols)
      (or (equal x (p 0 2))
          (memb x symbols)))


;; TERMP checks that EXP is either a variable or an n-ary function symbol (in
;; symbols) applied to n smaller terms.
(defun g-termp (exp flg symbols)
  (if (equal flg 0)
      (g-top-termp exp symbols)
      (g-termsp exp symbols)))

(mutual-recursion
 (defun g-top-termp (exp symbols)
   (if (true-listp exp)
       (and (g-function (car exp))
            (symb (car exp) symbols)
            (g-termsp (cdr exp) symbols)
            (equal (length (cdr exp)) (degree (car exp))))
       (g-variable exp)))
 (defun g-termsp (exp symbols)
   (if (null exp)
       t
       (and (true-listp exp)
            (g-top-termp (car exp) symbols)
            (g-termsp (cdr exp) symbols)))))


;; ATOMP checks that EXP is an n-ary predicate symbol applied to n terms.
(defun g-atomp (exp symbols)
  (and (predicate (car exp))
       (symb (car exp) symbols)
       (equal (length (cdr exp)) (degree (car exp)))
       (g-termp (cdr exp) 1 symbols)))


(defthm atomp-reduc
    (equal (g-atomp (cons x y) symbols)
           (and (predicate x)
                (symb x symbols)
                (equal (length y) (degree x))
                (g-termp y 1 symbols))))


(defthm atomp-f-equal
    (equal (g-atomp (f-equal x y) symbols)
           (and (g-termp x 0 symbols)
                (g-termp y 0 symbols))))


;; SUBST substitutes term for all free occurrences of VAR in EXP.
(defun g-subst (exp var term flg)
  (if (zerop flg)
      (if (g-variable exp)
          (if (equal exp var) term exp)
          (if (f-notp exp)
              (f-not (g-subst (arg exp) var term 0))
              (if (f-orp exp)
                  (f-or (g-subst (arg1 exp) var term 0)
                        (g-subst (arg2 exp) var term 0))
                  (if (forsomep exp)
                      (if (g-eql (bind exp) var)
                          exp
                          (forsome (bind exp) (g-subst (g-body exp) var term 0)))
                      (if (consp exp)
                          (cons (car exp) (g-subst (cdr exp) var term 1))
                          exp)))))
      (if (consp exp)
          (cons (g-subst (car exp) var term 0) (g-subst (cdr exp) var term 1))
          exp)))


;; SUB checks if every element of X occurs in Y, using EQL.
(defun sub (x y)
  (if (true-listp x)
    (and x
         (memb (car x) y)
         (sub (cdr x) y))
    nil))


;; SUBSET checks if every element of X occurs in Y, using equal.
(defun subset (x y)
  (if (true-listp x)
      (and x
           (member (car x) y)
           (subset (cdr x) y))
      nil))


(defthm sub-subset
    (implies (subset x y) (sub x y)))


(defthm subst-f-equal
    (equal (g-subst (f-equal x y) var term 0)
           (f-equal (g-subst x var term 0) (g-subst y var term 0))))


(in-theory (disable f-equal g-atomp))


;; FORMULA checks if EXP is a well-formed formula.
(defun g-formula (exp symbols)
  (if (f-notp exp)
      (g-formula (arg exp) symbols)
      (if (f-orp exp)
          (and (g-formula (arg1 exp) symbols)
               (g-formula (arg2 exp) symbols))
          (if (forsomep exp)
              (g-formula (g-body exp) symbols)
              (g-atomp exp symbols)))))


(defthm formula-f-equal
    (equal (g-formula (f-equal x y) symbols)
           (and (g-termp x 0 symbols)
                (g-termp y 0 symbols))))

;; (f-and x y) denotes (x ^ y).
(defun f-and (x y)
  (f-not (f-or (f-not x) (f-not y))))


;; (f-implies x y) denotes (x => y).
(defun f-implies (x y)
  (f-or (f-not x) y))


;; (forall x exp) denotes (ax exp).
(defun forall (var exp)
  (f-not (forsome var (f-not exp))))


;; pairequals returns a formula of the form
;; ((x1=y1) -> (...-> ((xn=yn) -> exp))).
(defun pairequals (vars1 vars2 exp)
  (if (and (consp vars1)
           (consp vars2))
      (f-implies (f-equal (car vars1) (car vars2))
                 (pairequals (cdr vars1) (cdr vars2) exp))
      exp))


;; (defun second (x) (cadr x))
;; (defun third (x) (caddr x))
;; (defun fourth (x) (cadddr x))


;; FOL-AXIOM-PROOF checks if CONC is a logical axiom (in a theory with
;; symbols), using hints from hints.  The axioms are: [1] propositional
;; axioms of the form, "((not a) or a)";  [2] substitution axioms of
;; the form, "[t/x]a -> (forsome x a)";  [3] identity axioms of the form,
;; "(x=x)";  [4] equality axioms for functions, of the form,
;; "((x1=y1) -> (...-> ((xn=yn) -> ((fx1...xn)=(fy1...yn)))))";
;; [5] equality axioms for predicates, of the form,
;; "((x1=y1) -> (...-> ((xn=yn) -> ((px1...xn) -> (py1...yn)))))".
(defun fol-axiom-proof (conc hints symbols)
  (if (equal (car hints) 1)
      (and (g-formula (second hints) symbols)
           (g-eql conc (f-or (f-not (second hints)) (second hints))))
      (if (equal (car hints) 2)
          (and (g-formula (second hints) symbols)
               (g-variable (third hints))
               (g-termp (fourth hints) 0 symbols)
               (free-for (second hints) (third hints) (fourth hints) 0)
               (g-eql conc
                      (f-implies
                       (g-subst (second hints) (third hints) (fourth hints) 0)
                       (forsome (third hints) (second hints)))))
          (if (equal (car hints) 3)
              (and (g-termp (second hints) 0 symbols)
                   (g-eql conc (f-equal (second hints) (second hints))))
              (if (equal (car hints) 4)
                  (and (g-termp (third hints) 1 symbols)
                       (g-termp (fourth hints) 1 symbols)
                       (g-function (second hints))
                       (equal (length (third hints)) (degree (second hints)))
                       (equal (length (fourth hints)) (degree (second hints)))
                       (g-eql conc
                              (pairequals (third hints)
                                          (fourth hints)
                                          (f-equal
                                           (cons (second hints) (third hints))
                                           (cons (second hints) (fourth hints))))))
                  (if (equal (car hints) 5)
                      (and (g-termp (third hints) 1 symbols)
                           (g-termp (fourth hints) 1 symbols)
                           (predicate (second hints))
                           (equal (length (third hints)) (degree (second hints)))
                           (equal (length (fourth hints)) (degree (second hints)))
                           (g-eql conc
                                  (pairequals (third hints)
                                              (fourth hints)
                                              (f-implies (cons (second hints)
                                                               (third hints))
                                                         (cons (second hints)
                                                               (fourth hints))))))
                      nil))))))


;; fol-rules checks if conc follows from the sub-goals by an application
;; of one of the logical rules of inference, using hints from hints.
;; the rules of inference are:  [1] expansion: derive "(a or b)" from "b";
;; [2] contraction: derive "a" from "(a or a)";
;; [3] associativity: derive "((a or b) or c)" from "(a or (b or c))";
;; [4] cut: derive "(b or c)" from "(a or b)" and "((not b) or c)";
;; [5] e-introduction: derive "((forsome x a) -> b)" from "(a -> b)",
;; provided "x" does not occur free in "b".
(defun fol-rules (conc hints sub-goals symbols)
  (if (equal (car hints) 1)
      (and (g-formula (second hints) symbols)
           (g-formula (car sub-goals) symbols)
           (g-eql conc (f-or (second hints) (car sub-goals))))
      (if (equal (car hints) 2)
          (and (g-formula (second hints) symbols)
               (g-eql sub-goals (list (f-or (second hints) (second hints))))
               (g-eql conc (second hints)))
          (if (equal (car hints) 3)
              (and (g-formula (second hints) symbols)
                   (g-formula (third hints) symbols)
                   (g-formula (fourth hints) symbols)
                   (g-eql sub-goals
                          (list (f-or (second hints)
                                      (f-or (third hints) (fourth hints)))))
                   (g-eql conc (f-or (f-or (second hints)
                                           (third hints)) (fourth hints))))
              (if (equal (car hints) 4)
                  (and (g-formula (second hints) symbols)
                       (g-formula (third hints) symbols)
                       (g-formula (fourth hints) symbols)
                       (g-eql sub-goals
                              (list (f-or (second hints) (third hints))
                                    (f-or (f-not (second hints)) (fourth hints))))
                       (g-eql conc (f-or (third hints) (fourth hints))))
                  (if (equal (car hints) 5)
                      (and (g-variable (second hints))
                           (g-formula (third hints) symbols)
                           (g-formula (fourth hints) symbols)
                           (not (memb (second hints)
                                      (collect-free (fourth hints) 0)))
                           (g-eql sub-goals
                                  (list (f-implies (third hints) (fourth hints))))
                           (g-eql conc
                                  (f-implies (forsome (second hints) (third hints))
                                             (fourth hints))))
                      nil))))))


;; Some notation for: [1] set-theoretic membership: "(x in y)";
;; [2] null set: "(phi)";  [3] pairing: "{x, y}";
;; [4] union: "(x u y)";  [5] integerhood:  "(i x)" defined as
;; "x is transitive and linearly ordered";
;; [6] successor: "(s x)" defined as "(x u {x})", where "{x}" is "{x, x}";
;; [7] if-and-only-if: "(a <-> b)".
(defun isin (x y) (list (p 1 2) x y))
(defun phi nil (list (fn 0 0)))
(defun z-pair (x y) (list (fn 1 2) x y))
(defun z-union (x y) (list (fn 2 2) x y))
(defun z-int (x) (list (p 2 1) x))
(defun z-succ (x) (list (fn 3 1) x))
(defun f-iff (x y) (f-and (f-implies x y) (f-implies y x)))


;; z2-axioms checks if conc is a set-theoretic axiom from z2.
;; these axioms are:
;; [1] extensionality: "(x=y) <-> (forall z ((z in x) <-> (z in y)))".
;; [2] null set: "(not (x in (phi)))".
;; [3] pairing: "(z in {x, y}) <-> ((z=x) v (z=y))".
;; [4] union: "(z in (x u y)) <-> ((z in x) v (z in y))".
;; [5] induction:  "a[(phi)] ^ (forall x (((i x) ^ a[x]) -> a[(s x)])
;;                     -> (forall x ((i x) -> a[x]))"
(defun z2-axioms (conc hints symbols)
  (if
   (equal (car hints) 1)
   (and (g-variable (fourth hints))
        (g-termp (second hints) 0 symbols)
        (g-termp (third hints) 0 symbols)
        (not (memb (fourth hints) (collect-free (second hints) 0)))
        (not (memb (fourth hints) (collect-free (third hints) 0)))
        (g-eql conc
               (f-iff (f-equal (second hints) (third hints))
                      (forall (fourth hints)
                              (f-iff (isin (fourth hints) (second hints))
                                     (isin (fourth hints) (third hints)))))))
   (if
    (equal (car hints) 2)
    (and (g-termp (second hints) 0 symbols)
         (g-eql conc (f-not (isin (second hints) (phi)))))
    (if
     (equal (car hints) 3)
     (and (g-termp (list (second hints) (third hints) (fourth hints)) 1 symbols)
          (g-eql conc
                 (f-iff (isin (fourth hints) (z-pair (second hints) (third hints)))
                        (f-or (f-equal (fourth hints) (second hints))
                              (f-equal (fourth hints) (third hints))))))
     (if (equal (car hints) 4)
         (and (g-termp (list (second hints) (third hints) (fourth hints)) 1 symbols)
              (g-eql conc
                     (f-iff (isin (fourth hints)
                                  (z-union (second hints) (third hints)))
                            (f-or (isin (fourth hints) (second hints))
                                  (isin (fourth hints) (third hints))))))
         (if (equal (car hints) 5)
             (and (g-variable (third hints))
                  (g-formula (second hints) symbols)
                  (g-eql conc
                         (f-implies
                          (f-and (g-subst (second hints)
                                          (third hints) (phi) 0)
                                 (forall (third hints)
                                         (f-implies (f-and (z-int (third hints))
                                                           (second hints))
                                                    (g-subst (second hints)
                                                             (third hints)
                                                             (z-succ (third hints))
                                                             0))))
                          (forall (third hints)
                                  (f-implies (z-int (third hints))
                                             (second hints))))))
             nil))))))


;; X is a list with no duplicates.
(defun g-set (x)
  (if (and (true-listp x)
           x)
      (and (not (memb (car x) (cdr x)))
           (g-set (cdr x)))
      t))


;; returns the element paired to x in the alist y.
(defun g-assoc (x y)
  (if (and (true-listp y)
           y)
      (if (g-eql (caar y) x)
          (cadar y)
          (assoc x (cdr y)))
      0))


;; returns the list of symbols following the last occurrence of sym in symbols.
(defun rest-of (sym symbols)
  (if (and (true-listp symbols)
           symbols)
      (if (and (g-eql (car symbols) sym)
               (not (memb sym (cdr symbols))))
          (cdr symbols)
          (rest-of sym (cdr symbols)))
      nil))


;; symb-defn-proof checks if conc is admissible as the definition of a new
;; function or predicate symbol.  the definition of a predicate symbol
;; must have the form, "(px1...xn) <-> a", where the "xi" are distinct
;; variables, and "a" is a formula w.r.t. the symbols that follow "p" in symbols
;; which contains no free variables other than the "xi".
;; the definition of a function symbol must have the form, "[(fx1...xn)/x]a",
;; where the "x" and the "xi" are distinct, "a" is a formula w.r.t. the
;; symbols that follow "f" in symbols, and "(forsome-unique x a)" is
;; provable in a theory which only contains the symbols that follow "f" in symbols.
(defun symb-defn-proof (conc hints sub-goals defn symbols)
  (if (predicate (caar hints))
      (and (g-set (cdar hints))
           (var-list (cdar hints) (degree (caar hints)))
           (g-eql conc (f-iff (car hints) defn))
           (sub (collect-free defn 0) (cdar hints))
           (g-formula defn (rest-of (caar hints) symbols)))
      (if (g-function (caar hints))
          (and (g-set (cons (fourth hints) (cons (second hints) (cdar hints))))
               (var-list (cdar hints) (degree (caar hints)))
               (g-variable (second hints))
               (g-variable (fourth hints))
               (g-formula (third hints) (rest-of (caar hints) symbols))
               (sub (collect-free (third hints) 0)
                    (cons (second hints) (cdar hints)))
               (free-for (third hints) (second hints) (car hints) 0)
               (free-for (third hints) (second hints) (fourth hints) 0)
               (g-eql conc (g-subst (third hints) (second hints) (car hints) 0))
               (g-eql conc defn)
               (g-eql sub-goals
                      (list (forsome (second hints) (third hints))
                            (f-implies (f-and (third hints)
                                              (g-subst (third hints)
                                                       (second hints)
                                                       (fourth hints)
                                                       0))
                                       (f-equal (second hints) (fourth hints))))))
          nil)))


;; A formal proof is represented as 4-tuple: <step hints conclusion sub-proofs>,
;; where the conclusion is derived from the conclusions of the sub-proofs
;; by means of a proof-step given by the combination of `step' and `hints'.
;; conc returns the conclusion of a proof/list of proofs.
(defun conc
    (pf flg)
  (if (zerop flg)
      (third pf)
      (if (consp pf)
          (cons (conc (car pf) 0) (conc (cdr pf) 1))
          nil)))


;; prf checks if pf is well-formed proof in a theory whose function/predicate
;; symbols appear in symbols, where the definitions of the defined symbols
;; appear in defns, and given is a list of assumptions.  the argument given is
;; there merely to facilitate the proof of essential incompleteness, and is never
;; actually used to demonstrate the existence of a proof.  one can obviously
;; introduce an inconsistency through given.
;; prf recurses down pf and checks if the conclusion is either [1] a logical axiom;
;; [2] follows from the conclusion of the sub-proofs (which are themselves
;; well-formed) by means of one of the rules of inference; [3] a set-theoretic
;; axiom; [4] a function/predicate definition; [5] an assumption from given.
(defun prf (pf given defns flg symbols)
  (if (zerop flg)
      (if (atom pf)
          nil
          (if (not (g-formula (conc pf 0) symbols))
              nil
              (if (equal (car pf) 1)
                  (fol-axiom-proof (conc pf 0) (second pf) symbols)
                  (if (equal (car pf) 2)
                      (and (fol-rules (conc pf 0)
                                      (second pf)
                                      (conc (fourth pf) 1)
                                      symbols)
                           (prf (fourth pf) given defns 1 symbols))
                      (if (equal (car pf) 3)
                          (z2-axioms (conc pf 0) (second pf) symbols)
                          (if (equal (car pf) 4)
                              (and (symb-defn-proof (conc pf 0)
                                                    (second pf)
                                                    (conc (fourth pf) 1)
                                                    (assoc (caar (second pf)) defns)
                                                    symbols)
                                   (if (g-function (caar (cadr pf)))
                                       (prf (cadddr pf)
                                            given
                                            defns
                                            1
                                            (rest-of (caar (cadr pf)) symbols))
                                       t))
                              (if (equal (car pf) 5)
                                  (memb (conc pf 0) given)
                                  nil)))))))
      (if (atom pf)
          t
          (and (prf (car pf) given defns 0 symbols)
               (prf (cdr pf) given defns 1 symbols)))))


;; Proves checks that pf is a well-formed proof whose conclusion is exp.
(defun proves (pf exp given defns symbols)
  (and (g-eql (conc pf 0) exp)
       (g-formula exp symbols)
       (prf pf given defns 0 symbols)))


;; ;; what follows is a series of rewrite rules which convert the proof-checker above





;; ;; into a set of rewrite rules.  functions like prop-axiom construct axioms
;; ;; whose proofs are constructed by `proof-constructors' like prop-axiom-proof.
;; (defun prop-axiom (exp) (f-or (f-not exp) exp))
;; (defun subst-axiom (exp var term) (f-implies (g-subst exp var term 0) (forsome var exp)))
;; (defun ident-axiom (var) (f-equal var var))
;; (defun prop-axiom-proof (exp) (list 1 (list 1 exp) (prop-axiom exp)))
;; (defun subst-axiom-proof (exp var term) (list 1 (list 2 exp var term) (subst-axiom exp var term)))
;; (defun ident-axiom-proof (var) (list 1 (list 3 var) (f-equal var var)))
;; (defun equal-axiom1
;;       (vars1 vars2 fn)
;;       (pairequals vars1 vars2 (f-equal (cons fn vars1) (cons fn vars2))))
;; (defun equal-axiom1-proof
;;       (fn vars1 vars2)
;;       (list 1 (list 4 fn vars1 vars2) (equal-axiom1 vars1 vars2 fn)))
;; (defun equal-axiom2
;;       (vars1 vars2 pr)
;;       (pairequals vars1 vars2 (f-implies (cons pr vars1) (cons pr vars2))))
;; (defun equal-axiom2-proof
;;       (pr vars1 vars2)
;;       (list 1 (list 5 pr vars1 vars2) (equal-axiom2 vars1 vars2 pr)))
;; (defthm formula-f-not (equal (g-formula (f-not x) symbols) (g-formula x symbols)))
;; (defthm formula-f-or

;;              (equal (g-formula (f-or x y) symbols)
;;                     (and (g-formula x symbols)
;;                          (g-formula y symbols))))
;; (defthm formula-forsome (equal (g-formula (forsome x y) symbols) (g-formula y symbols)))
;; ;; the lemma below establishes that prop-axiom-proof constructs a well-formed proof
;; ;; of a propositional axiom.  once this is proved, the definition of prop-axiom-proof
;; ;; is irrelevant and is disabled.
;; (defthm prop-axiom-proves

;;              (implies (g-formula exp symbols)
;;                       (proves (prop-axiom-proof exp) (f-or (f-not exp) exp) given defns symbols)))
;; (defthm subst-length

;;              (implies (not (zerop flg)) (equal (length (g-subst exp var term flg)) (length exp))))
;; (defthm subst-termp

;;              (implies (and (g-termp exp flg symbols)
;;                            (g-termp term 0 symbols))
;;                       (g-termp (g-subst exp var term flg) flg symbols)))
;; (toggle g0606 atomp nil)
;; (defthm subst-formula

;;              (implies (and (g-formula exp symbols)
;;                            (g-termp term 0 symbols))
;;                       (g-formula (g-subst exp var term 0) symbols)))
;; (toggle g0607 atomp t)
;; (defthm subst-axiom-proves

;;              (implies (and (equal lhs (g-subst exp var term 0))
;;                            (g-variable var)
;;                            (g-termp term 0 symbols)
;;                            (g-formula exp symbols)
;;                            (free-for exp var term 0))
;;                       (proves (subst-axiom-proof exp var term)
;;                               (f-implies lhs (forsome var exp))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable free-for)))
;; (defthm formula-pairequals

;;              (implies (and (g-termp vars1 1 symbols)
;;                            (g-termp vars2 1 symbols)
;;                            (g-formula exp symbols))
;;                       (g-formula (pairequals vars1 vars2 exp) symbols)))
;; (defthm equal-axiom1-proves

;;              (implies (and (g-function fn)
;;                            (symb fn symbols)
;;                            (equal (length vars1) (degree fn))
;;                            (equal (length vars2) (degree fn))
;;                            (g-termp vars1 1 symbols)
;;                            (g-termp vars2 1 symbols)
;;                            (equal concl (equal-axiom1 vars1 vars2 fn)))
;;                       (proves (equal-axiom1-proof fn vars1 vars2) concl given defns symbols)))
;; (defthm equal-axiom2-proves

;;              (implies (and (predicate pr)
;;                            (symb pr symbols)
;;                            (equal (length vars1) (degree pr))
;;                            (equal (length vars2) (degree pr))
;;                            (g-termp vars1 1 symbols)
;;                            (g-termp vars2 1 symbols)
;;                            (equal concl (equal-axiom2 vars1 vars2 pr)))
;;                       (proves (equal-axiom2-proof pr vars1 vars2) concl given defns symbols)))
;; (defthm ident-axiom-proves

;;              (implies (g-termp var 0 symbols)
;;                       (proves (ident-axiom-proof var) (f-equal var var) given defns symbols)))
;; (defun assum-proof (exp) (list 5 nil exp))
;; (defthm assum-proof-proves

;;              (implies (and (member exp given)
;;                            (g-formula exp symbols))
;;                       (proves (assum-proof exp) exp given defns symbols)))
;; (defthm memb-member (implies (member x y) (memb x y)))
;; (defun fun-defn-proof
;;       (fn vars x y exp pf1 pf2)
;;       (list 4 (list (cons fn vars) x exp y) (g-subst exp x (cons fn vars) 0) (list pf1 pf2)))
;; (defthm fun-defn-proof-proves

;;              (implies (and (var-list vars (degree fn))
;;                            (g-variable x)
;;                            (g-variable y)
;;                            (g-set (cons y (cons x vars)))
;;                            (g-function fn)
;;                            (symb fn symbols)
;;                            (g-formula a-prime symbols)
;;                            (subset (collect-free exp 0) (cons x vars))
;;                            (free-for exp x (cons fn vars) 0)
;;                            (free-for exp x y 0)
;;                            (equal a-prime (assoc fn defns))
;;                            (proves pf1 (forsome x exp) given defns (rest-of fn symbols))
;;                            (proves pf2
;;                                    (f-implies (f-and exp (g-subst exp x y 0)) (f-equal x y))
;;                                    given
;;                                    defns
;;                                    (rest-of fn symbols))
;;                            (equal a-prime (g-subst exp x (cons fn vars) 0)))
;;                       (proves (fun-defn-proof fn vars x y exp pf1 pf2)
;;                               a-prime
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable collect-free free-for symb eql subset set)))
;; (toggle g0591 fun-defn-proof t)
;; (defun pred-defn-proof (pr vars defn) (list 4 (list (cons pr vars)) (f-iff (cons pr vars) defn)))
;; (defthm var-list-termp

;;              (implies (var-list vars (length vars)) (g-termp vars 1 symbols)))
;; (defthm var-list-length

;;              (implies (not (equal (length vars) (fix n))) (not (var-list vars n))))
;; (defthm memb-rest-of (implies (not (memb x z)) (not (memb x (rest-of y z)))))
;; (defthm termp-rest-of

;;              (implies (not (g-termp exp flg symbols)) (not (g-termp exp flg (rest-of symb symbols)))))
;; (toggle g0594 atomp nil)
;; (defthm formula-rest-of

;;              (implies (not (g-formula exp symbols)) (not (g-formula exp (rest-of symb symbols)))))
;; (toggle g0595 atomp t)
;; (defthm pred-defn-proof-proves

;;              (implies (and (var-list vars (degree pr))
;;                            (g-set vars)
;;                            (predicate pr)
;;                            (symb pr symbols)
;;                            (equal defun (assoc pr defns))
;;                            (g-formula defun (rest-of pr symbols))
;;                            (subset (collect-free defun 0) vars)
;;                            (equal concl (f-iff (cons pr vars) defn)))
;;                       (proves (pred-defn-proof pr vars defn) concl given defns symbols))
;;              ((disable collect-free symb)))
;; (toggle g0592 pred-defn-proof t)
;; (defun expan-proof (a b pf) (list 2 (list 1 a) (f-or a b) (list pf)))
;; (defun contrac-proof (a pf) (list 2 (list 2 a) a (list pf)))
;; (defun assoc-proof (a b c pf) (list 2 (list 3 a b c) (f-or (f-or a b) c) (list pf)))
;; (defun cut-proof (a b c pf1 pf2) (list 2 (list 4 a b c) (f-or b c) (list pf1 pf2)))
;; (defun forsome-intro-proof
;;       (var a b pf)
;;       (list 2 (list 5 var a b) (f-implies (forsome var a) b) (list pf)))
;; (toggle g0624 fol-axiom-proof t)
;; (toggle g0625 fun-defn-proof t)
;; (defthm expan-proof-proves

;;              (implies (and (g-formula a symbols)
;;                            (proves pf b given defns symbols))
;;                       (proves (expan-proof a b pf) (f-or a b) given defns symbols)))
;; (defthm assoc-proof-proves

;;              (implies (proves pf (f-or a (f-or b c)) given defns symbols)
;;                       (proves (assoc-proof a b c pf) (f-or (f-or a b) c) given defns symbols)))
;; (defthm contrac-proof-proves

;;              (implies (proves pf (f-or a a) given defns symbols)
;;                       (proves (contrac-proof a pf) a given defns symbols)))
;; (defthm cut-proof-proves

;;              (implies (and (proves pf1 (f-or a b) given defns symbols)
;;                            (proves pf2 (f-or (f-not a) c) given defns symbols)
;;                            (g-formula (f-or b c) symbols))
;;                       (proves (cut-proof a b c pf1 pf2) (f-or b c) given defns symbols)))
;; (defthm forsome-intro-proves

;;              (implies (and (proves pf (f-implies a b) given defns symbols)
;;                            (not (memb var (collect-free b 0)))
;;                            (g-variable var)
;;                            (g-formula (f-implies (forsome var a) b) symbols))
;;                       (proves (forsome-intro-proof var a b pf)
;;                               (f-implies (forsome var a) b)
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable collect-free formula)))
;; (toggle g2752 prop-axiom-proof t)
;; (toggle g2753 subst-axiom-proof t)
;; (toggle g2754 equal-axiom1-proof t)
;; (toggle g2755 equal-axiom2-proof t)
;; (toggle g2756 ident-axiom-proof t)
;; (toggle g2757 assum-proof t)
;; (toggle g2758 fun-defn-proof t)
;; (toggle g2759 expan-proof t)
;; (toggle g2760 contrac-proof t)
;; (toggle g2761 assoc-proof t)
;; (toggle g2762 cut-proof t)
;; (toggle g2763 forsome-intro-proof t)
;; (toggle g0626 fol-rules t)
;; (defthm atom-proves

;;              (implies (atom pf) (not (proves pf exp given defns symbols))))
;; (defun ext-axiom
;;       (x terma termb)
;;       (f-iff (f-equal terma termb) (forall x (f-iff (isin x terma) (isin x termb)))))
;; (defun ext-axiom-proof (x terma termb) (list 3 (list 1 terma termb x) (ext-axiom x terma termb)))
;; (defthm ext-axiom-proof-proves

;;              (implies (and (not (memb x (collect-free terma 0)))
;;                            (not (memb x (collect-free termb 0)))
;;                            (g-variable x)
;;                            (memb (p 1 2) symbols)
;;                            (g-termp terma 0 symbols)
;;                            (g-termp termb 0 symbols))
;;                       (proves (ext-axiom-proof x terma termb)
;;                               (f-iff (f-equal terma termb)
;;                                      (forall x (f-iff (isin x terma) (isin x termb))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0374 ext-axiom-proof t)
;; (defun null-axiom (term) (f-not (isin term (phi))))
;; (defun null-axiom-proof (term) (list 3 (list 2 term) (null-axiom term)))
;; (defthm null-axiom-proof-proves

;;              (implies (and (subset (list (fn 0 0) (p 1 2)) symbols)
;;                            (g-termp term 0 symbols))
;;                       (proves (null-axiom-proof term)
;;                               (f-not (isin term (phi)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0375 null-axiom-proof t)
;; (defun pair-axiom
;;       (x terma termb)
;;       (f-iff (isin x (z-pair terma termb)) (f-or (f-equal x terma) (f-equal x termb))))
;; (defun pair-axiom-proof (x terma termb) (list 3 (list 3 terma termb x) (pair-axiom x terma termb)))
;; (defthm pair-axiom-proof-proves

;;              (implies (and (g-termp x 0 symbols)
;;                            (g-termp terma 0 symbols)
;;                            (g-termp termb 0 symbols)
;;                            (subset (list (fn 1 2) (p 1 2)) symbols))
;;                       (proves (pair-axiom-proof x terma termb)
;;                               (f-iff (isin x (z-pair terma termb))
;;                                      (f-or (f-equal x terma) (f-equal x termb)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0376 pair-axiom-proof t)
;; (defun union-axiom
;;       (x terma termb)
;;       (f-iff (isin x (z-union terma termb)) (f-or (isin x terma) (isin x termb))))
;; (defun union-axiom-proof
;;       (x terma termb)
;;       (list 3 (list 4 terma termb x) (union-axiom x terma termb)))
;; (defthm union-axiom-proof-proves

;;              (implies (and (g-termp x 0 symbols)
;;                            (g-termp terma 0 symbols)
;;                            (g-termp termb 0 symbols)
;;                            (memb (p 1 2) symbols)
;;                            (memb (fn 2 2) symbols))
;;                       (proves (union-axiom-proof x terma termb)
;;                               (f-iff (isin x (z-union terma termb))
;;                                      (f-or (isin x terma) (isin x termb)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0377 union-axiom-proof t)
;; (defun ind-axiom
;;       (form x)
;;       (f-implies (f-and (g-subst form x (phi) 0)
;;                         (forall x (f-implies (f-and (z-int x) form) (g-subst form x (z-succ x) 0))))
;;                  (forall x (f-implies (z-int x) form))))
;; (defun ind-axiom-proof (form x) (list 3 (list 5 form x) (ind-axiom form x)))
;; (toggle g0627 predicate nil)
;; (defthm ind-axiom-proof-proves

;;              (implies (and (g-formula form symbols)
;;                            (g-variable x)
;;                            (subset (list (fn 0 0) (fn 3 1) (p 2 1)) symbols)
;;                            (equal concl (ind-axiom form x)))
;;                       (proves (ind-axiom-proof form x) concl given defns symbols)))
;; (toggle g0629 predicate t)
;; (toggle g0378 ind-axiom-proof t)
;; (toggle g0379 prf t)
;; (defthm proves-is-formula

;;              (implies (proves pf exp given defns symbols) (g-formula exp symbols)))
;; (defthm proves-is-formula-again

;;              (implies (not (g-formula exp symbols)) (not (proves pf exp given defns symbols))))
;; (toggle g0380 proves t)
;; ;; the commutativity of disjunction is the first example of a `derived inference rule'.
;; ;; commut-proof constructs a proof of "(b or a)" given a proof of "(a or b)".
;; (defun commut-proof (a b pf) (cut-proof a b a pf (prop-axiom-proof a)))
;; ;; the lemma below establishes that this is the required proof.  the definition
;; ;; of commut-proof then becomes irrelevant and is disabled.
;; (defthm commut-proof-proves

;;              (implies (proves pf (f-or a b) given defns symbols)
;;                       (proves (commut-proof a b pf) (f-or b a) given defns symbols))
;;              ((use (proves-is-formula (exp (f-or a b)))) (disable proves-is-formula)))
;; (toggle g2766 commut-proof t)
;; (defun detach-proof
;;       (a b pf1 pf2)
;;       (contrac-proof b (cut-proof a b b (commut-proof b a (expan-proof b a pf1)) pf2)))
;; (toggle g0503 proves-is-formula t)
;; ;; modus ponens is proved as a derived inference rule below.
;; (defthm detach-proof-proves

;;              (implies (and (proves pf1 a given defns symbols)
;;                            (proves pf2 (f-implies a b) given defns symbols))
;;                       (proves (detach-proof a b pf1 pf2) b given defns symbols))
;;              ((use (proves-is-formula (pf pf2) (exp (f-implies a b))))))
;; (toggle g2767 detach-proof t)
;; (defthm formula-f-implies

;;              (equal (g-formula (f-implies x y) symbols)
;;                     (and (g-formula x symbols)
;;                          (g-formula y symbols))))
;; (defthm covering-f-implies

;;              (equal (covering (f-implies x y) var 0)
;;                     (g-append (covering x var 0) (covering y var 0))))
;; (defthm member-append

;;              (equal (member x (g-append y z))
;;                     (or (member x y)
;;                         (member x z))))
;; (defthm collect-free-f-implies

;;              (equal (collect-free (f-implies x y) 0)
;;                     (g-append (collect-free x 0) (collect-free y 0))))
;; (toggle g0344 f-implies t)
;; (defun list-implies
;;       (list conc)
;;       (if (atom list)
;;           conc
;;           (if (atom (cdr list))
;;               (f-implies (car list) conc)
;;               (f-implies (car list) (list-implies (cdr list) conc)))))
;; (defun list-detach-proof
;;       (alist b pflist pf2)
;;       (if (atom alist)
;;           pf2
;;           (if (atom (cdr alist))
;;               (detach-proof (car alist) b (car pflist) pf2)
;;               (list-detach-proof (cdr alist)
;;                                  b
;;                                  (cdr pflist)
;;                                  (detach-proof (car alist)
;;                                                (list-implies (cdr alist) b)
;;                                                (car pflist)
;;                                                pf2)))))
;; (defthm formula-list-implies
;;              nil
;;              (implies (and (g-formula (list-implies alist b) symbols)
;;                            (consp alist))
;;                       (g-formula (list-implies (cdr alist) b) symbols)))
;; ;; proves-list checks that pflist is a list of proofs of the elements of
;; ;; the list explist.
;; (defun proves-list
;;       (pflist explist given defns symbols)
;;       (if (atom explist)
;;           (equal pflist nil)
;;           (and (proves (car pflist) (car explist) given defns symbols)
;;                (proves-list (cdr pflist) (cdr explist) given defns symbols))))
;; (defthm detach-rule-corr

;;              (implies (and (proves-list pflist alist given defns symbols)
;;                            (proves pf2 (list-implies alist b) given defns symbols)
;;                            (g-formula b symbols))
;;                       (proves (list-detach-proof alist b pflist pf2) b given defns symbols))
;;              ((induct (list-detach-proof alist b pflist pf2)) (use (formula-list-implies))))
;; (toggle g0220 list-detach-proof t)
;; (defun rt-expan-proof (a b pf) (commut-proof b a (expan-proof b a pf)))
;; (defthm rt-expan-proof-proves

;;              (implies (and (proves pf a given defns symbols)
;;                            (g-formula b symbols))
;;                       (proves (rt-expan-proof a b pf) (f-or a b) given defns symbols)))
;; (toggle g0227 rt-expan-proof t)
;; ;; make-disjunct returns a disjunction of a given list of formulas.
;; (defun make-disjunct
;;       (flist)
;;       (if (atom flist)
;;           nil
;;           (if (atom (cdr flist)) (car flist) (f-or (car flist) (make-disjunct (cdr flist))))))
;; (defun m1-proof
;;       (exp flist pf)
;;       (if (atom flist)
;;           nil
;;           (if (atom (cdr flist))
;;               pf
;;               (if (equal exp (car flist))
;;                   (rt-expan-proof (car flist) (make-disjunct (cdr flist)) pf)
;;                   (expan-proof (car flist)
;;                                (make-disjunct (cdr flist))
;;                                (m1-proof exp (cdr flist) pf))))))
;; ;; the rule below asserts that if "a" is provable, so is any disjunction
;; ;; which contains "a" as a disjunct.
;; (defthm m1-proof-proves

;;              (implies (and (g-formula (make-disjunct flist) symbols)
;;                            (member exp flist)
;;                            (proves pf exp given defns symbols))
;;                       (proves (m1-proof exp flist pf) (make-disjunct flist) given defns symbols))
;;              ((induct (m1-proof exp flist pf))))
;; (toggle g0228 m1-proof t)
;; ;; note that the lemma in the above form contains make-disjunct in the
;; ;; conclusion which might prevent a match with a disjunction of the
;; ;; form "(a or b)".  this is remedied by moving it to the hypothesis in
;; ;; the rephrased form below.  the lemma had to first be proved in the
;; ;; above form to get the induction right.
;; (defthm m1-proof-proves1

;;              (implies (and (g-formula (make-disjunct flist) symbols)
;;                            (member exp flist)
;;                            (proves pf exp given defns symbols)
;;                            (equal concl (make-disjunct flist)))
;;                       (proves (m1-proof exp flist pf) concl given defns symbols))
;;              ((use (m1-proof-proves))))
;; (toggle g0504 m1-proof-proves t)
;; (defun rt-assoc-proof
;;       (a b c pf)
;;       (commut-proof (f-or b c)
;;                     a
;;                     (assoc-proof b
;;                                  c
;;                                  a
;;                                  (commut-proof (f-or c a)
;;                                                b
;;                                                (assoc-proof c
;;                                                             a
;;                                                             b
;;                                                             (commut-proof (f-or a b) c pf))))))
;; (defthm rt-assoc-proof-proves

;;              (implies (proves pf (f-or (f-or a b) c) given defns symbols)
;;                       (proves (rt-assoc-proof a b c pf) (f-or a (f-or b c)) given defns symbols))
;;              ((use (proves-is-formula (exp (f-or (f-or a b) c))))))
;; (toggle g0231 rt-assoc-proof t)
;; (defun insert-proof
;;       (a b c pf)
;;       (commut-proof (f-or a c)
;;                     b
;;                     (assoc-proof a c b (expan-proof a (f-or c b) (commut-proof b c pf)))))
;; (defthm insert-proof-proves

;;              (implies (and (proves pf (f-or b c) given defns symbols)
;;                            (g-formula a symbols))
;;                       (proves (insert-proof a b c pf) (f-or b (f-or a c)) given defns symbols))
;;              ((use (proves-is-formula (exp (f-or b c))))))
;; (toggle g0232 insert-proof t)
;; (defun m2-proof-step
;;       (exp1 exp2 flist pf)
;;       (if (atom flist)
;;           nil
;;           (if (atom (cdr flist))
;;               (if (equal exp2 (car flist)) pf nil)
;;               (if (equal exp2 (car flist))
;;                   (rt-assoc-proof exp1
;;                                   exp2
;;                                   (make-disjunct (cdr flist))
;;                                   (rt-expan-proof (f-or exp1 exp2)
;;                                                   (make-disjunct (cdr flist))
;;                                                   pf))
;;                   (insert-proof (car flist)
;;                                 exp1
;;                                 (make-disjunct (cdr flist))
;;                                 (m2-proof-step exp1 exp2 (cdr flist) pf))))))
;; (prove-lemma
;;  m2-proof-step-proves

;;  (implies (and (g-formula (make-disjunct flist) symbols)
;;                (member exp2 flist)
;;                (proves pf (f-or exp1 exp2) given defns symbols))
;;           (proves (m2-proof-step exp1 exp2 flist pf)
;;                   (f-or exp1 (make-disjunct flist))
;;                   given
;;                   defns
;;                   symbols))
;;  ((induct (m2-proof-step exp1 exp2 flist pf)) (use (proves-is-formula (exp (f-or exp1 exp2))))))
;; (defthm m2-proof-step-proves1

;;              (implies (and (g-formula (make-disjunct flist) symbols)
;;                            (member exp2 flist)
;;                            (proves pf (f-or exp1 exp2) given defns symbols)
;;                            (equal concl (f-or exp1 (make-disjunct flist))))
;;                       (proves (m2-proof-step exp1 exp2 flist pf) concl given defns symbols))
;;              ((use (m2-proof-step-proves))))
;; (toggle g0233 m2-proof-step t)
;; (toggle g0234 m2-proof-step-proves t)
;; (defun m2-proof
;;       (exp1 exp2 flist pf)
;;       (if (atom flist)
;;           nil
;;           (if (equal exp1 exp2)
;;               (m1-proof exp1 flist (contrac-proof exp1 pf))
;;               (if (equal exp1 (car flist))
;;                   (m2-proof-step exp1 exp2 (cdr flist) pf)
;;                   (if (equal exp2 (car flist))
;;                       (m2-proof-step exp2 exp1 (cdr flist) (commut-proof exp1 exp2 pf))
;;                       (expan-proof (car flist)
;;                                    (make-disjunct (cdr flist))
;;                                    (m2-proof exp1 exp2 (cdr flist) pf)))))))
;; ;; the rule below asserts that if "(a or b)" is provable, so is any
;; ;; disjunction which contains "a" and "b" as disjuncts.
;; (defthm m2-proof-proves

;;              (implies (and (g-formula (make-disjunct flist) symbols)
;;                            (member exp1 flist)
;;                            (member exp2 flist)
;;                            (proves pf (f-or exp1 exp2) given defns symbols))
;;                       (proves (m2-proof exp1 exp2 flist pf)
;;                               (make-disjunct flist)
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (m2-proof exp1 exp2 flist pf)) (use (proves-is-formula (exp (f-or exp1
;;                                                                                         exp2))))))
;; (defthm m2-proof-proves1

;;              (implies (and (g-formula (make-disjunct flist) symbols)
;;                            (member exp1 flist)
;;                            (member exp2 flist)
;;                            (proves pf (f-or exp1 exp2) given defns symbols)
;;                            (equal concl (make-disjunct flist)))
;;                       (proves (m2-proof exp1 exp2 flist pf) concl given defns symbols))
;;              ((use (m2-proof-proves))))
;; (toggle g0235 m2-proof t)
;; (toggle g0236 m2-proof-proves t)
;; (defn
;;  m3-proof
;;  (exp1 exp2 flist2 pf)
;;  (contrac-proof
;;   (make-disjunct flist2)
;;   (contrac-proof
;;    (f-or (make-disjunct flist2) (make-disjunct flist2))
;;    (m2-proof
;;     (f-or (make-disjunct flist2) (make-disjunct flist2))
;;     exp1
;;     (cons (f-or (make-disjunct flist2) (make-disjunct flist2))
;;           (cons (make-disjunct flist2) flist2))
;;     (assoc-proof (make-disjunct flist2)
;;                  (make-disjunct flist2)
;;                  exp1
;;                  (commut-proof (f-or (make-disjunct flist2) exp1)
;;                                (make-disjunct flist2)
;;                                (m2-proof (f-or (make-disjunct flist2) exp1)
;;                                          exp2
;;                                          (cons (f-or (make-disjunct flist2) exp1) flist2)
;;                                          (assoc-proof (make-disjunct flist2)
;;                                                       exp1
;;                                                       exp2
;;                                                       (commut-proof (f-or exp1 exp2)
;;                                                                     (make-disjunct flist2)
;;                                                                     pf)))))))))
;; (defun form-list
;;       (flist symbols)
;;       (if (consp flist)
;;           (and (g-formula (car flist) symbols)
;;                (form-list (cdr flist) symbols))
;;           t))
;; (defthm subset-cons (implies (subset x y) (subset x (cons z y))))
;; (defthm formlist-formula-make-disj

;;              (implies (and (consp flist)
;;                            (form-list flist symbols))
;;                       (g-formula (make-disjunct flist) symbols)))
;; (defthm m3-proof-proves

;;              (implies (and (proves pf
;;                                    (make-disjunct (cons (f-or exp1 exp2) flist2))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (member exp1 flist2)
;;                            (member exp2 flist2))
;;                       (proves (m3-proof exp1 exp2 flist2 pf)
;;                               (make-disjunct flist2)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (exp (make-disjunct (cons (f-or exp1 exp2) flist2)))))))
;; (toggle g0222 m3-proof t)
;; (defthm m3-proof-proves1

;;              (implies (and (proves pf
;;                                    (make-disjunct (cons (f-or exp1 exp2) flist2))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (member exp1 flist2)
;;                            (member exp2 flist2)
;;                            (equal concl (make-disjunct flist2)))
;;                       (proves (m3-proof exp1 exp2 flist2 pf) concl given defns symbols))
;;              ((use (m3-proof-proves))))
;; (toggle g0229 m3-proof-proves t)
;; (defun m-proof
;;       (flist1 flist2 pf)
;;       (if (atom flist1)
;;           nil
;;           (if (atom (cdr flist1))
;;               (m1-proof (car flist1) flist2 pf)
;;               (if (atom (cddr flist1))
;;                   (m2-proof (car flist1) (cadr flist1) flist2 pf)
;;                   (m3-proof (car flist1)
;;                             (cadr flist1)
;;                             flist2
;;                             (m-proof (cons (f-or (car flist1) (cadr flist1)) (cddr flist1))
;;                                      (cons (f-or (car flist1) (cadr flist1)) flist2)
;;                                      (assoc-proof (car flist1)
;;                                                   (cadr flist1)
;;                                                   (make-disjunct (cddr flist1))
;;                                                   pf))))))
;;       ((< (length flist1))))
;; ;; the rule below is the important lemma on disjuncts which asserts that
;; ;; if a disjunction of formulas {"a1",...,"am"} is provable, so is any
;; ;; disjunction of formulas {"b1",...,"bn"} which contains all the "ai".
;; (defthm m-proof-proves

;;              (implies (and (form-list flist2 symbols)
;;                            (consp flist1)
;;                            (consp flist2)
;;                            (subset flist1 flist2)
;;                            (proves pf (make-disjunct flist1) given defns symbols))
;;                       (proves (m-proof flist1 flist2 pf)
;;                               (make-disjunct flist2)
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (m-proof flist1 flist2 pf))))
;; (defun termp1
;;       (exp flg)
;;       (if (zerop flg)
;;           (if (consp exp)
;;               (and (g-function (car exp))
;;                    (equal (length (cdr exp)) (degree (car exp)))
;;                    (termp1 (cdr exp) 1))
;;               (g-variable exp))
;;           (if (atom exp)
;;               t
;;               (and (termp1 (car exp) 0)
;;                    (termp1 (cdr exp) 1)))))
;; (defthm termp-termp1 (implies (g-termp exp flg symbols) (termp1 exp flg)))
;; (defun atomp1
;;       (exp)
;;       (and (predicate (car exp))
;;            (equal (length (cdr exp)) (degree (car exp)))
;;            (termp1 (cdr exp) 1)))
;; (toggle g0345 atomp nil)
;; (defthm atomp-atomp1 (implies (g-atomp exp symbols) (atomp1 exp)))
;; (defun dble-neg-type
;;       (exp)
;;       (and (f-notp exp)
;;            (f-notp (arg exp))))
;; (defun neg
;;       (exp1 exp2)
;;       (or (equal exp1 (f-not exp2))
;;           (equal exp2 (f-not exp1))))
;; (defun neg-list (exp list) (if (f-notp exp) (member (arg exp) list) (member (f-not exp) list)))
;; (defun elem-form
;;       (exp)
;;       (or (atomp1 exp)
;;           (and (forsomep exp)
;;                (equal exp (forsome (bind exp) (g-body exp))))))
;; (defun neg-elem-form
;;       (exp)
;;       (and (f-notp exp)
;;            (elem-form (arg exp))))
;; (defun prop-atomp
;;       (exp)
;;       (or (elem-form exp)
;;           (neg-elem-form exp)))
;; (defun form-count
;;       (exp)
;;       (if (f-notp exp)
;;           (add1 (form-count (arg exp)))
;;           (if (f-orp exp) (add1 (plus (form-count (arg1 exp)) (form-count (arg2 exp)))) 1)))
;; (defun list-count (list) (if (consp list) (plus (form-count (car list)) (list-count (cdr list))) 0))
;; (defun nor-type
;;       (exp)
;;       (and (f-notp exp)
;;            (f-orp (arg exp))))
;; (defthm <-list-count

;;              (implies (consp flist) (< (list-count (cdr flist)) (list-count flist))))
;; (defthm f-orp-list-count

;;              (implies (and (f-orp (car flist))
;;                            (consp flist))
;;                       (< (list-count (cons (arg1 (car flist))
;;                                                (cons (arg2 (car flist)) (cdr flist))))
;;                              (list-count flist))))
;; (defthm nor-type-list-count1

;;              (implies (and (consp flist)
;;                            (nor-type (car flist)))
;;                       (< (list-count (cons (f-not (arg1 (arg (car flist)))) (cdr flist)))
;;                              (list-count flist))))
;; (defthm nor-type-list-count2

;;              (implies (and (consp flist)
;;                            (nor-type (car flist)))
;;                       (< (list-count (cons (f-not (arg2 (arg (car flist)))) (cdr flist)))
;;                              (list-count flist))))
;; (defthm dble-neg-list-count

;;              (implies (and (consp flist)
;;                            (dble-neg-type (car flist)))
;;                       (< (list-count (cons (arg (arg (car flist))) (cdr flist)))
;;                              (list-count flist))))
;; (toggle g0240 list-count t)
;; ;; tautologyp1 is the tautology-checker.  it recurses through a list of
;; ;; formulas flist and builds up a list of literals auxlist.  if auxlist
;; ;; is ever to contain a literal and its negation, tautologyp1 returns t.
;; ;; otherwise, it returns f.
;; (defun tautologyp1
;;       (flist auxlist)
;;       (if (consp flist)
;;           (if (f-orp (car flist))
;;               (tautologyp1 (cons (arg1 (car flist)) (cons (arg2 (car flist)) (cdr flist))) auxlist)
;;               (if (nor-type (car flist))
;;                   (and (tautologyp1 (cons (f-not (arg1 (arg (car flist)))) (cdr flist)) auxlist)
;;                        (tautologyp1 (cons (f-not (arg2 (arg (car flist)))) (cdr flist)) auxlist))
;;                   (if (dble-neg-type (car flist))
;;                       (tautologyp1 (cons (arg (arg (car flist))) (cdr flist)) auxlist)
;;                       (or (neg-list (car flist) auxlist)
;;                           (tautologyp1 (cdr flist) (cons (car flist) auxlist))))))
;;           nil)
;;       ((< (list-count flist))))
;; (defthm form-list-append

;;              (implies (and (form-list x symbols)
;;                            (form-list y symbols))
;;                       (form-list (g-append x y) symbols))
;;              ((induct (g-append x y)) (disable formula)))
;; (defun neg-proof
;;       (exp1 exp2)
;;       (if (equal exp1 (f-not exp2))
;;           (prop-axiom-proof exp2)
;;           (commut-proof exp2 exp1 (prop-axiom-proof exp1))))
;; (defthm neg-proof-proves

;;              (implies (and (g-formula exp1 symbols)
;;                            (g-formula exp2 symbols)
;;                            (neg exp1 exp2)
;;                            (equal concl (f-or exp1 exp2)))
;;                       (proves (neg-proof exp1 exp2) concl given defns symbols)))
;; (defun neg-list-proof
;;       (exp flist)
;;       (if (member (f-not exp) flist)
;;           (m2-proof exp (f-not exp) (cons exp flist) (neg-proof exp (f-not exp)))
;;           (m2-proof exp (arg exp) (cons exp flist) (neg-proof exp (arg exp)))))
;; (defthm neg-list-proof-proves

;;              (implies (and (g-formula exp symbols)
;;                            (form-list flist symbols)
;;                            (neg-list exp flist)
;;                            (equal concl (make-disjunct (cons exp flist))))
;;                       (proves (neg-list-proof exp flist) concl given defns symbols)))
;; (defthm subset-ident (subset x x))
;; (defthm subset-car (subset x (cons y x)))
;; (defthm subset-append (subset (cons exp list2) (g-append (cons exp list1) list2)))
;; (defthm m-proof-proves1

;;              (implies (and (form-list flist2 symbols)
;;                            (subset flist1 flist2)
;;                            (proves pf (make-disjunct flist1) given defns symbols)
;;                            (equal concl (make-disjunct flist2)))
;;                       (proves (m-proof flist1 flist2 pf) concl given defns symbols))
;;              ((use (m-proof-proves))))
;; (toggle g0505 m-proof-proves t)
;; (toggle g0256 neg-list-proof t)
;; (defun prop-atom-proof1
;;       (flist1 flist2)
;;       (m-proof (cons (car flist1) flist2)
;;                (g-append flist1 flist2)
;;                (neg-list-proof (car flist1) flist2)))
;; (defthm prop-atom-proof1-proves

;;              (implies (and (form-list flist1 symbols)
;;                            (consp flist1)
;;                            (form-list flist2 symbols)
;;                            (neg-list (car flist1) flist2)
;;                            (equal concl (make-disjunct (g-append flist1 flist2))))
;;                       (proves (prop-atom-proof1 flist1 flist2) concl given defns symbols))
;;              ((use (subset-append (exp (car flist1)) (list1 (cdr flist1)) (list2 flist2)))))
;; (toggle g0259 prop-atom-proof1 t)
;; (defthm subset-append-car

;;              (subset (g-append list1 (cons exp list2)) (g-append (cons exp list1) list2)))
;; (defthm form-list-append-car

;;              (implies (and (form-list (cons exp list1) symbols)
;;                            (or (equal list2 nil)
;;                                (form-list list2 symbols)))
;;                       (form-list (g-append list1 (cons exp list2)) symbols)))
;; (defun prop-atom-proof2
;;       (flist1 flist2 pf)
;;       (m-proof (g-append (cdr flist1) (cons (car flist1) flist2)) (g-append flist1 flist2) pf))
;; (defthm prop-atom-proof2-proves

;;              (implies (and (form-list flist1 symbols)
;;                            (consp flist1)
;;                            (form-list flist2 symbols)
;;                            (proves pf
;;                                    (make-disjunct (g-append (cdr flist1) (cons (car flist1) flist2)))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl (make-disjunct (g-append flist1 flist2))))
;;                       (proves (prop-atom-proof2 flist1 flist2 pf) concl given defns symbols))
;;              ((use (subset-append-car (list1 (cdr flist1)) (exp (car flist1)) (list2 flist2)))))
;; (toggle g0258 prop-atom-proof2 t)
;; (defun cancel-proof
;;       (a b pf1 pf2)
;;       (contrac-proof b (cut-proof a b b pf2 (rt-expan-proof (f-not a) b pf1))))
;; (defthm cancel-proof-proves

;;              (implies (and (proves pf1 (f-not a) given defns symbols)
;;                            (proves pf2 (f-or a b) given defns symbols))
;;                       (proves (cancel-proof a b pf1 pf2) b given defns symbols))
;;              ((use (proves-is-formula (exp (f-or a b)) (pf pf2)))))
;; (toggle g0255 cancel-proof t)
;; (defun atom-nor-type-proof
;;       (a b pf1 pf2)
;;       (cancel-proof b
;;                     (f-not (f-or a b))
;;                     pf2
;;                     (cancel-proof a
;;                                   (f-or b (f-not (f-or a b)))
;;                                   pf1
;;                                   (m-proof (list (f-not (f-or a b)) a b)
;;                                            (list a b (f-not (f-or a b)))
;;                                            (prop-axiom-proof (f-or a b))))))
;; (defn
;;  consp-nor-type-proof
;;  (a b c pf1 pf2)
;;  (m-proof
;;   (list (f-not (f-or a b)) c c)
;;   (list (f-not (f-or a b)) c)
;;   (rt-assoc-proof (f-not (f-or a b))
;;                   c
;;                   c
;;                   (cut-proof b
;;                              (f-or (f-not (f-or a b)) c)
;;                              c
;;                              (rt-assoc-proof b
;;                                              (f-not (f-or a b))
;;                                              c
;;                                              (cut-proof a
;;                                                         (f-or b (f-not (f-or a b)))
;;                                                         c
;;                                                         (m-proof (list (f-not (f-or a b)) a b)
;;                                                                  (list a b (f-not (f-or a b)))
;;                                                                  (prop-axiom-proof (f-or a b)))
;;                                                         pf1))
;;                              pf2))))
;; (defun nor-proof
;;       (a b clist pf1 pf2)
;;       (if (atom clist)
;;           (atom-nor-type-proof a b pf1 pf2)
;;           (consp-nor-type-proof a b (make-disjunct clist) pf1 pf2)))
;; (defun atom-dble-neg-proof
;;       (a pf)
;;       (contrac-proof (f-not (f-not a))
;;                      (cut-proof a
;;                                 (f-not (f-not a))
;;                                 (f-not (f-not a))
;;                                 (rt-expan-proof a (f-not (f-not a)) pf)
;;                                 (commut-proof (f-not (f-not a))
;;                                               (f-not a)
;;                                               (prop-axiom-proof (f-not a))))))
;; (defun consp-dble-neg-proof
;;       (a c pf)
;;       (commut-proof c
;;                     (f-not (f-not a))
;;                     (cut-proof a
;;                                c
;;                                (f-not (f-not a))
;;                                pf
;;                                (commut-proof (f-not (f-not a))
;;                                              (f-not a)
;;                                              (prop-axiom-proof (f-not a))))))
;; (defun dble-neg-proof
;;       (a clist pf)
;;       (if (atom clist)
;;           (atom-dble-neg-proof a pf)
;;           (consp-dble-neg-proof a (make-disjunct clist) pf)))
;; (defun f-orp-proof (a b clist pf) (if (atom clist) pf (assoc-proof a b (make-disjunct clist) pf)))
;; ;; taut-proof1 is the proof-constructor that constructs the proof for a formula
;; ;; asserted to be a tautology by tautologyp1.  taut-proof1 and tautologyp1 recurse
;; ;; in the same way.
;; (defun taut-proof1
;;       (flist auxlist)
;;       (if (consp flist)
;;           (if (f-orp (car flist))
;;               (f-orp-proof (arg1 (car flist))
;;                            (arg2 (car flist))
;;                            (g-append (cdr flist) auxlist)
;;                            (taut-proof1 (cons (arg1 (car flist))
;;                                               (cons (arg2 (car flist)) (cdr flist)))
;;                                         auxlist))
;;               (if (nor-type (car flist))
;;                   (nor-proof (arg1 (arg (car flist)))
;;                              (arg2 (arg (car flist)))
;;                              (g-append (cdr flist) auxlist)
;;                              (taut-proof1 (cons (f-not (arg1 (arg (car flist)))) (cdr flist))
;;                                           auxlist)
;;                              (taut-proof1 (cons (f-not (arg2 (arg (car flist)))) (cdr flist))
;;                                           auxlist))
;;                   (if (dble-neg-type (car flist))
;;                       (dble-neg-proof (arg (arg (car flist)))
;;                                       (g-append (cdr flist) auxlist)
;;                                       (taut-proof1 (cons (arg (arg (car flist))) (cdr flist))
;;                                                    auxlist))
;;                       (if (neg-list (car flist) auxlist)
;;                           (prop-atom-proof1 flist auxlist)
;;                           (prop-atom-proof2 flist
;;                                             auxlist
;;                                             (taut-proof1 (cdr flist)
;;                                                          (cons (car flist) auxlist)))))))
;;           nil)
;;       ((< (list-count flist))))
;; ;; the lemma below is a form of the tautology theorem.  if (tautologyp1 flist auxlist)
;; ;; is t, then (taut-proof1 flist auxlist) constructs a correct proof of
;; ;; the disjunction of the formulas in flist and auxlist.  we still have to
;; ;; show that the tautology-checker tautologyp1 is correct w.r.t the truth-table
;; ;; definition of a tautology.
;; (defthm taut-thm1

;;              (implies (and (form-list flist symbols)
;;                            (form-list auxlist symbols)
;;                            (tautologyp1 flist auxlist))
;;                       (proves (taut-proof1 flist auxlist)
;;                               (make-disjunct (g-append flist auxlist))
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (tautologyp1 flist auxlist))))
;; (toggle g0275 taut-proof1 t)
;; (defthm taut-thm2

;;              (implies (and (form-list flist symbols)
;;                            (form-list auxlist symbols)
;;                            (tautologyp1 flist auxlist)
;;                            (equal concl (make-disjunct (g-append flist auxlist))))
;;                       (proves (taut-proof1 flist auxlist) concl given defns symbols))
;;              ((use (taut-thm1 (concl (make-disjunct (g-append flist auxlist)))))))
;; ;; eval evaluates the truth-value of the boolean expression exp,
;; ;; where the truth-value assigned to atoms are specified in alist.
;; (defun eval
;;       (exp alist)
;;       (if (f-notp exp)
;;           (not (eval (arg exp) alist))
;;           (if (f-orp exp)
;;               (or (eval (arg1 exp) alist)
;;                   (eval (arg2 exp) alist))
;;               (member exp alist))))
;; (defthm member-eval

;;              (implies (and (member exp flist)
;;                            (eval exp alist))
;;                       (eval (make-disjunct flist) alist)))
;; (defthm eval-make-disjunct

;;              (implies (and (consp list1)
;;                            (consp list2))
;;                       (equal (eval (make-disjunct (g-append list1 list2)) alist)
;;                              (or (eval (make-disjunct list1) alist)
;;                                  (eval (make-disjunct list2) alist)))))
;; (defthm neg-list-eval

;;              (implies (and (consp flist1)
;;                            (neg-list (car flist1) flist2))
;;                       (eval (make-disjunct (g-append flist1 flist2)) alist))
;;              ((induct (member x flist2))))
;; (defthm eval-prop-atomp

;;              (implies (and (consp flist1)
;;                            (eval (make-disjunct (g-append (cdr flist1) (cons (car flist1) flist2)))
;;                                  alist))
;;                       (eval (make-disjunct (g-append flist1 flist2)) alist))
;;              ((induct (g-append flist flist2))))
;; (defthm eval-prop-atomp1

;;              (implies (and (consp flist1)
;;                            (eval (make-disjunct (g-append (cdr flist1) (cons (car flist1) flist2)))
;;                                  alist)
;;                            (equal concl (make-disjunct (g-append flist1 flist2))))
;;                       (eval concl alist))
;;              ((disable append)))
;; (defthm neg-list-eval1

;;              (implies (and (consp flist1)
;;                            (neg-list (car flist1) flist2)
;;                            (equal concl (make-disjunct (g-append flist1 flist2))))
;;                       (eval concl alist)))
;; ;; the lemma below is one half of the correctness of the tautology-checker.
;; ;; it asserts that any formula checked to be a tautology, evaluates to
;; ;; true under any assignment of truth-values to the atoms.
;; (defthm taut-eval

;;              (implies (tautologyp1 flist auxlist)
;;                       (eval (make-disjunct (g-append flist auxlist)) alist))
;;              ((disable eval-make-disjunct neg-list) (induct (tautologyp1 flist auxlist))))
;; ;; falsify attempts to return a falsifying assignment corresponding to a list of literals.
;; (defun falsify
;;       (list)
;;       (if (atom list)
;;           nil
;;           (if (f-notp (car list))
;;               (cons (arg (car list)) (falsify (cdr list)))
;;               (falsify (cdr list)))))
;; ;; falsify-taut attempts to return an assignment which falsifies a non-tautology.
;; (defun falsify-taut
;;       (flist auxlist)
;;       (if (consp flist)
;;           (if (f-orp (car flist))
;;               (falsify-taut (cons (arg1 (car flist)) (cons (arg2 (car flist)) (cdr flist)))
;;                             auxlist)
;;               (if (nor-type (car flist))
;;                   (if (falsify-taut (cons (f-not (arg2 (arg (car flist)))) (cdr flist)) auxlist)
;;                       (falsify-taut (cons (f-not (arg2 (arg (car flist)))) (cdr flist)) auxlist)
;;                       (falsify-taut (cons (f-not (arg1 (arg (car flist)))) (cdr flist)) auxlist))
;;                   (if (dble-neg-type (car flist))
;;                       (falsify-taut (cons (arg (arg (car flist))) (cdr flist)) auxlist)
;;                       (if (neg-list (car flist) auxlist)
;;                           nil
;;                           (falsify-taut (cdr flist) (cons (car flist) auxlist))))))
;;           (falsify auxlist))
;;       ((< (list-count flist))))
;; (defthm not-falsify-taut

;;              (equal (tautologyp1 flist auxlist) (not (falsify-taut flist auxlist)))
;;              ((induct (tautologyp1 flist auxlist))))
;; (defthm eval-member

;;              (implies (and (not (f-notp exp))
;;                            (not (f-orp exp))
;;                            (member exp alist))
;;                       (eval exp alist)))
;; (defun prop-atomp-list
;;       (flist)
;;       (if (consp flist)
;;           (and (not (f-orp (car flist)))
;;                (not (nor-type (car flist)))
;;                (not (dble-neg-type (car flist)))
;;                (not (neg-list (car flist) (cdr flist)))
;;                (prop-atomp-list (cdr flist)))
;;           t))
;; (defthm member-falsify

;;              (equal (member exp (falsify list)) (member (f-not exp) list)))
;; (defthm alist-cons-eval2

;;              (implies (and (not (member x flist))
;;                            (consp flist)
;;                            (prop-atomp-list flist)
;;                            (not (eval (make-disjunct flist) alist)))
;;                       (not (eval (make-disjunct flist) (cons x alist)))))
;; (defthm prop-atomp-list-eval

;;              (implies (and (consp flist)
;;                            (prop-atomp-list flist))
;;                       (not (eval (make-disjunct flist) (falsify flist)))))
;; (defthm not-eval-prop-atomp

;;              (equal (eval (make-disjunct (g-append flist1 (cons exp flist2))) alist)
;;                     (eval (make-disjunct (cons exp (g-append flist1 flist2))) alist)))
;; ;; the lemma below is the second half of the correctness of the tautology-checker.
;; ;; it asserts that if auxlist does not contain both a literal and its negation,
;; ;; then any formula which is checked to not be a tautology is falsifiable.
;; (defthm not-taut-false

;;              (implies (and (prop-atomp-list auxlist)
;;                            (not (tautologyp1 flist auxlist)))
;;                       (not (eval (make-disjunct (g-append flist auxlist))
;;                                  (falsify-taut flist auxlist))))
;;              ((induct (falsify-taut flist auxlist))))
;; ;; tautologyp is tautologyp1 with auxlist set to nil.
;; (defun tautologyp (flist) (tautologyp1 flist nil))
;; (defun taut-proof (flist) (taut-proof1 flist nil))
;; (defthm form-list-append-nil

;;              (equal (make-disjunct (g-append flist nil)) (make-disjunct flist)))
;; (defthm tautology-theorem

;;              (implies (and (form-list flist symbols)
;;                            (tautologyp flist)
;;                            (equal concl (make-disjunct flist)))
;;                       (proves (taut-proof flist) concl given defns symbols))
;;              ((disable taut-proof1 tautologyp1 formula not-falsify-taut)))
;; (defthm taut-eval2

;;              (implies (and (tautologyp1 flist auxlist)
;;                            (equal concl (make-disjunct (g-append flist auxlist))))
;;                       (eval concl alist))
;;              ((disable tautologyp1 not-falsify-taut)))
;; (defthm tautologies-are-true

;;              (implies (and (consp flist)
;;                            (tautologyp flist))
;;                       (eval (make-disjunct flist) alist))
;;              ((disable formula tautologyp1 not-falsify-taut)))
;; (defthm not-taut-falsify2

;;              (implies (and (prop-atomp-list auxlist)
;;                            (not (tautologyp1 flist auxlist))
;;                            (equal concl (make-disjunct (g-append flist auxlist))))
;;                       (not (eval concl (falsify-taut flist auxlist))))
;;              ((disable tautologyp1 not-falsify-taut formula)))
;; (defthm truths-are-tautologies

;;              (implies (not (tautologyp flist))
;;                       (not (eval (make-disjunct flist) (falsify-taut flist nil))))
;;              ((disable tautologyp1 not-falsify-taut formula)))
;; (defun lis-not (flist) (if (atom flist) nil (cons (f-not (car flist)) (lis-not (cdr flist)))))
;; (defun taut-conseq (flist exp) (tautologyp (g-append (lis-not flist) (cons exp nil))))
;; (defun tautconseq-proof
;;       (flist exp pflist)
;;       (list-detach-proof flist exp pflist (taut-proof (g-append (lis-not flist) (cons exp nil)))))
;; (toggle g0873 f-implies nil)
;; (defthm eval-f-implies

;;              (equal (eval (f-implies x y) alist) (implies (eval x alist) (eval y alist))))
;; (defthm list-implies-reduc

;;              (equal (list-implies flist exp)
;;                     (make-disjunct (g-append (lis-not flist) (cons exp nil)))))
;; (toggle g0874 f-implies t)
;; (defthm append-exp-form-list

;;              (implies (and (form-list flist symbols)
;;                            (g-formula exp symbols))
;;                       (form-list (g-append (lis-not flist) (cons exp nil)) symbols)))
;; (defthm eval-tautologyp

;;              (implies (eval (make-disjunct flist) (falsify-taut flist nil)) (tautologyp flist))
;;              ((disable tautologyp form-list falsify-taut) (use (truths-are-tautologies))))
;; (defthm proves-list-form-list

;;              (implies (proves-list pflist flist given defns symbols) (form-list flist symbols)))
;; (defthm taut-conseq-proves

;;              (implies (and (g-formula exp symbols)
;;                            (taut-conseq flist exp)
;;                            (proves-list pflist flist given defns symbols))
;;                       (proves (tautconseq-proof flist exp pflist) exp given defns symbols)))
;; (toggle g0276 tautconseq-proof t)
;; (prove-lemma
;;  eval-tautconseq

;;  (implies (and (form-list flist symbols)
;;                (g-formula exp symbols)
;;                (eval (make-disjunct (g-append (lis-not flist) (cons exp nil)))
;;                      (falsify-taut (g-append (lis-not flist) (cons exp nil)) nil)))
;;           (taut-conseq flist exp))
;;  ((disable tautologyp append formula lis-not eval-make-disjunct form-list)
;;   (use (eval-tautologyp (flist (g-append (lis-not flist) (cons exp nil)))))))
;; (toggle g0277 taut-conseq t)
;; (toggle g0282 falsify-taut t)
;; ;; the lemma below is the frequently used form of the tautology theorem.
;; ;; it asserts that if exp is a tautological consequence of a list of
;; ;; provable formulas flist, then exp is provable.  "b" is the
;; ;; tautological consequence of {"a1",...,"an"} if "(a1->(...->(an->b)))" is
;; ;; a tautology.  a formula is a tautology if it evaluates to true under its
;; ;; falsifying assignment.
;; (defthm eval-tautconseq-proof-proves

;;              (implies (and (g-formula exp symbols)
;;                            (eval (make-disjunct (g-append (lis-not flist) (cons exp nil)))
;;                                  (falsify-taut (g-append (lis-not flist) (cons exp nil)) nil))
;;                            (proves-list pflist flist given defns symbols))
;;                       (proves (tautconseq-proof flist exp pflist) exp given defns symbols))
;;              ((disable formula form-list proves-list-form-list) (use (proves-list-form-list))))
;; (toggle g0283 taut-conseq-proves t)
;; ;; the rules below are some properties of the various logical connectives which
;; ;; follow as straightforward consequences of the tautology theorem.
;; (defun f-iff-mp-proof1 (a b pf1 pf2) (tautconseq-proof (list (f-iff a b) a) b (list pf1 pf2)))
;; ;; the rule of detachment for `<->' (first form).
;; (defthm f-iff-mp-proves1

;;              (implies (and (proves pf1 (f-iff a b) given defns symbols)
;;                            (proves pf2 a given defns symbols))
;;                       (proves (f-iff-mp-proof1 a b pf1 pf2) b given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-iff a b))))))
;; (toggle g0284 f-iff-mp-proof1 t)
;; (defun f-iff-mp-proof2 (a b pf1 pf2) (tautconseq-proof (list (f-iff a b) b) a (list pf1 pf2)))
;; ;; the rule of detachment for `<->' (second form).
;; (defthm f-iff-mp-proves2

;;              (implies (and (proves pf1 (f-iff a b) given defns symbols)
;;                            (proves pf2 b given defns symbols))
;;                       (proves (f-iff-mp-proof2 a b pf1 pf2) a given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-iff a b))))))
;; (defun trans-implies-proof
;;       (a b c pf1 pf2)
;;       (tautconseq-proof (list (f-implies a b) (f-implies b c)) (f-implies a c) (list pf1 pf2)))
;; ;; the transitivity of `->'.
;; (defthm transitivity-of-implies

;;              (implies (and (proves pf1 (f-implies a b) given defns symbols)
;;                            (proves pf2 (f-implies b c) given defns symbols))
;;                       (proves (trans-implies-proof a b c pf1 pf2)
;;                               (f-implies a c)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies a b)))
;;                    (proves-is-formula (pf pf2) (exp (f-implies b c))))
;;               ))
;; (toggle g0285 trans-implies-proof t)
;; ;; the transitivity of `<->'.
;; (defun trans-f-iff-proof
;;       (a b c pf1 pf2)
;;       (tautconseq-proof (list (f-iff a b) (f-iff b c)) (f-iff a c) (list pf1 pf2)))
;; (defthm transitivity-of-iff

;;              (implies (and (proves pf1 (f-iff a b) given defns symbols)
;;                            (proves pf2 (f-iff b c) given defns symbols))
;;                       (proves (trans-f-iff-proof a b c pf1 pf2) (f-iff a c) given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-iff a b)))
;;                    (proves-is-formula (pf pf2) (exp (f-iff b c))))
;;               ))
;; (toggle g0286 trans-f-iff-proof t)
;; (defun and-split-proof1 (a b pf1) (tautconseq-proof (list (f-and a b)) a (list pf1)))
;; ;; derive "a" from "(a and b)".
;; (defthm and-split1

;;              (implies (proves pf1 (f-and a b) given defns symbols)
;;                       (proves (and-split-proof1 a b pf1) a given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-and a b))))))
;; (defun and-split-proof2 (a b pf1) (tautconseq-proof (list (f-and a b)) b (list pf1)))
;; ;; derive "b" from "(a and b)".
;; (defthm and-split2

;;              (implies (proves pf1 (f-and a b) given defns symbols)
;;                       (proves (and-split-proof2 a b pf1) b given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-and a b))))))
;; (defun and-join-proof (a b pf1 pf2) (tautconseq-proof (list a b) (f-and a b) (list pf1 pf2)))
;; ;; derive "(a and b)" from "a" and "b".
;; (defthm and-join

;;              (implies (and (proves pf1 a given defns symbols)
;;                            (proves pf2 b given defns symbols))
;;                       (proves (and-join-proof a b pf1 pf2) (f-and a b) given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp a)) (proves-is-formula (pf pf2) (exp b)))))
;; (toggle g0287 and-split-proof1 t)
;; (toggle g0288 and-split-proof2 t)
;; (toggle g0289 and-join-proof t)
;; (defun iff-split-proof1 (a b pf1) (tautconseq-proof (list (f-iff a b)) (f-implies a b) (list pf1)))
;; ;; derive "(a -> b)" from "(a <-> b)".
;; (defthm iff-split1

;;              (implies (proves pf1 (f-iff a b) given defns symbols)
;;                       (proves (iff-split-proof1 a b pf1) (f-implies a b) given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-iff a b))))))
;; (toggle g0290 iff-split-proof1 t)
;; (defun iff-split-proof2 (a b pf1) (tautconseq-proof (list (f-iff a b)) (f-implies b a) (list pf1)))
;; ;; derive "(b -> a)" from "(a <-> b)".
;; (defthm iff-split2

;;              (implies (proves pf1 (f-iff a b) given defns symbols)
;;                       (proves (iff-split-proof2 a b pf1) (f-implies b a) given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-iff a b))))))
;; (toggle g0291 iff-split-proof2 t)
;; (defun iff-join-proof
;;       (a b pf1 pf2)
;;       (tautconseq-proof (list (f-implies a b) (f-implies b a)) (f-iff a b) (list pf1 pf2)))
;; ;; derive "(a <-> b)" from "(a -> b)" and "(b -> a)".
;; (defthm iff-join

;;              (implies (and (proves pf1 (f-implies a b) given defns symbols)
;;                            (proves pf2 (f-implies b a) given defns symbols))
;;                       (proves (iff-join-proof a b pf1 pf2) (f-iff a b) given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies a b))))))
;; (toggle g0292 iff-join-proof t)
;; (defun contra-pos-proof1
;;       (a b pf1)
;;       (tautconseq-proof (list (f-implies a b)) (f-implies (f-not b) (f-not a)) (list pf1)))
;; ;; derive "((not b) -> (not a))" from "(a -> b)".
;; (defthm contra-pos1

;;              (implies (proves pf1 (f-implies a b) given defns symbols)
;;                       (proves (contra-pos-proof1 a b pf1)
;;                               (f-implies (f-not b) (f-not a))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies a b))))))
;; (toggle g0293 contra-pos-proof1 t)
;; (defun contra-pos-proof2
;;       (a b pf)
;;       (tautconseq-proof (list (f-implies (f-not b) (f-not a))) (f-implies a b) (list pf)))
;; ;; derive "(a -> b)" from "((not b) -> (not a))".
;; (defthm contra-pos2

;;              (implies (proves pf (f-implies (f-not b) (f-not a)) given defns symbols)
;;                       (proves (contra-pos-proof2 a b pf) (f-implies a b) given defns symbols))
;;              ((use (proves-is-formula (exp (f-implies (f-not b) (f-not a)))))))
;; (toggle g0294 contra-pos-proof2 t)
;; (defun iff-commute-proof (a b pf) (tautconseq-proof (list (f-iff a b)) (f-iff b a) (list pf)))
;; ;; derive "(b <-> a)" from "(a <-> b)".
;; (defthm iff-commute-proof-proves

;;              (implies (proves pf (f-iff a b) given defns symbols)
;;                       (proves (iff-commute-proof a b pf) (f-iff b a) given defns symbols))
;;              ((use (proves-is-formula (exp (f-iff a b))))))
;; (toggle g0884 iff-commute-proof t)
;; (defthm formula-f-iff

;;              (equal (g-formula (f-iff a b) symbols)
;;                     (and (g-formula a symbols)
;;                          (g-formula b symbols))))
;; (defthm collect-free-f-iff

;;              (equal (member var (collect-free (f-iff a b) 0))
;;                     (or (member var (collect-free a 0))
;;                         (member var (collect-free b 0)))))
;; (defthm covering-f-iff

;;              (equal (covering (f-iff a b) var 0)
;;                     (g-append (g-append (covering a var 0) (covering b var 0))
;;                             (g-append (covering b var 0) (covering a var 0)))))
;; (defthm eval-f-iff

;;              (equal (eval (f-iff a b) alist) (equal (eval a alist) (eval b alist))))
;; (toggle g0885 f-iff t)
;; ;; now we get into some rules about quantifiers.
;; (defun forall-intro-proof
;;       (a b var pf)
;;       (tautconseq-proof (list (f-implies (forsome var (f-not b)) (f-not a)))
;;                         (f-implies a (f-not (forsome var (f-not b))))
;;                         (list (forsome-intro-proof var
;;                                                    (f-not b)
;;                                                    (f-not a)
;;                                                    (contra-pos-proof1 a b pf)))))
;; (defthm memb-member-acl2-numberp (implies (acl2-numberp x) (equal (memb x y) (member x y))))
;; ;; derive "(a -> (forall x b))" from "(a -> b)", provided "x" does not occur free in "a".
;; (defthm forall-intro-proof-proves

;;              (implies (and (proves pf (f-implies a b) given defns symbols)
;;                            (g-variable var)
;;                            (not (member var (collect-free (f-not a) 0)))
;;                            (equal concl (f-implies a (forall var b))))
;;                       (proves (forall-intro-proof a b var pf) concl given defns symbols))
;;              ((use (proves-is-formula (exp (f-implies a b)))) (disable collect-free
;;                                                                        proves-is-formula)))
;; (toggle g0295 forall-intro-proof t)
;; (defn
;;  generalise-proof
;;  (var a pf1)
;;  (tautconseq-proof (list (f-implies (f-not (forall var a)) (forall var a)))
;;                    (forall var a)
;;                    (list (forall-intro-proof (f-not (forall var a))
;;                                              a
;;                                              var
;;                                              (tautconseq-proof (list a)
;;                                                                (f-implies (f-not (forall var
;;                                                                                          a))
;;                                                                           a)
;;                                                                (list pf1))))))
;; (defthm collect-free-flg

;;              (implies (not (acl2-numberp flg)) (equal (collect-free exp flg) (collect-free exp 0))))
;; (defthm covering-flg

;;              (implies (not (acl2-numberp flg)) (equal (covering exp var flg) (covering exp var 0))))
;; (defthm subst-flg

;;              (implies (not (acl2-numberp flg)) (equal (g-subst exp var term flg) (g-subst exp var term 0))))
;; (defthm variablep-collect-free

;;              (implies (not (g-variable var)) (not (member var (collect-free exp flg)))))
;; (defthm member-del (not (member x (del x y))))
;; (defthm forsome-collect-free-reduc

;;              (implies (acl2-numberp var) (not (member var (collect-free (forsome var exp) 0)))))
;; ;; derive "(forall x a)" from "a".
;; (defthm generalise-proof-proves

;;              (implies (and (proves pf1 a given defns symbols)
;;                            (g-variable var)
;;                            (equal concl (forall var a)))
;;                       (proves (generalise-proof var a pf1) concl given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp a)))))
;; (toggle g0300 generalise-proof t)
;; (defun subst-rule-proof
;;       (a var term pf1)
;;       (tautconseq-proof (list (f-implies (f-not (g-subst a var term 0)) (forsome var (f-not a)))
;;                               (f-not (forsome var (f-not a))))
;;                         (g-subst a var term 0)
;;                         (list (subst-axiom-proof (f-not a) var term)
;;                               (generalise-proof var a pf1))))
;; ;; derive "[t/x]a" from "a", where "t" is free for "x" in "a".
;; (defthm subst-rule-proof-proves

;;              (implies (and (g-variable var)
;;                            (g-termp term 0 symbols)
;;                            (proves pf1 a given defns symbols)
;;                            (free-for a var term 0)
;;                            (equal a-prime (g-subst a var term 0)))
;;                       (proves (subst-rule-proof a var term pf1) a-prime given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp a)))))
;; (toggle g0886 subst-rule-proof t)
;; ;; "[x/x]a" is equal to "a".
;; (defthm subst-var-var (equal (g-subst exp var var flg) exp))
;; (defun e-intro-proof (var c) (subst-axiom-proof c var var))
;; (defthm append-nil-intersect

;;              (equal (nil-intersect (g-append x y) z)
;;                     (and (nil-intersect x z)
;;                          (nil-intersect y z))))
;; (defthm var-covering-var (not (member var (covering exp var flg))))
;; (defthm nil-intersect-cons

;;              (implies (and (not (memb z x))
;;                            (nil-intersect x y))
;;                       (nil-intersect x (cons z y))))
;; (defthm nil-intersect-nil (nil-intersect x nil))
;; ;; "(c -> (forsome x c))" is a theorem.
;; (defthm e-intro-proof-proves

;;              (implies (and (g-formula c symbols)
;;                            (g-variable var))
;;                       (proves (e-intro-proof var c)
;;                               (f-implies c (forsome var c))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0306 e-intro-proof t)
;; (defun all-elim-proof
;;       (var c)
;;       (tautconseq-proof (list (f-implies (f-not c) (forsome var (f-not c))))
;;                         (f-implies (forall var c) c)
;;                         (list (e-intro-proof var (f-not c)))))
;; ;; "((forall x c) -> c)" is a theorem.
;; (defthm all-elim-proof-proves

;;              (implies (and (g-formula c symbols)
;;                            (g-variable var))
;;                       (proves (all-elim-proof var c)
;;                               (f-implies (forall var c) c)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0307 all-elim-proof t)
;; (defthm member-del1

;;              (implies (not (g-eql x y)) (equal (member x (del y z)) (member x z))))
;; ;; "[t/x]a" is equal to "a", if "x" does not occur free in "a".
;; (defthm subst-ident

;;              (implies (not (member var (collect-free exp flg)))
;;                       (equal (g-subst exp var term flg) exp)))
;; ;; "y" is free in "[t/x]a" iff either "y" is free in "t" and "x" is free in "a"
;; ;;                                 or "y" is not "x" and "y" is free in "a".
;; (defthm collect-free-subst

;;              (implies (and (g-variable var)
;;                            (g-variable var1)
;;                            (not (member var (covering exp var1 flg))))
;;                       (equal (member var (collect-free (g-subst exp var1 term flg) flg))
;;                              (or (and (not (equal var var1))
;;                                       (member var (collect-free exp flg)))
;;                                  (and (member var1 (collect-free exp flg))
;;                                       (member var (collect-free term 0)))))))
;; ;; if "y" is a `new' variable, the bound variables governing free occurrences
;; ;; of "y" in "[y/x]a" are the ones that govern free occurrences of "x" in "a".
;; (defthm free-for-subst

;;              (implies (and (g-variable aux)
;;                            (g-variable var)
;;                            (not (member aux (collect-free a flg)))
;;                            (not (member aux (covering a var flg))))
;;                       (equal (covering (g-subst a var aux flg) aux flg) (covering a var flg)))
;;              ((induct (covering a var flg))))
;; (defthm not-free-covering

;;              (implies (and (g-variable var)
;;                            (not (member var (collect-free exp flg))))
;;                       (equal (covering exp var flg) nil)))
;; (defthm not-member-delete2

;;              (equal (member x (del y z))
;;                     (and (not (g-eql x y))
;;                          (member x z))))
;; (defthm collect-free-subst1

;;              (implies (and (g-variable var1)
;;                            (g-variable var)
;;                            (not (member var (collect-free exp flg)))
;;                            (not (member var (collect-free term 0))))
;;                       (not (member var (collect-free (g-subst exp var1 term flg) flg)))))
;; (defthm collect-free-subst2

;;              (implies (and (g-variable var)
;;                            (g-variable var1)
;;                            (not (equal var var1))
;;                            (member var (collect-free exp flg)))
;;                       (member var (collect-free (g-subst exp var1 term flg) flg))))
;; (defthm subst-covering-unchanged

;;              (implies (and (g-variable var)
;;                            (g-variable var1)
;;                            (not (equal var var1))
;;                            (not (member var (collect-free term 0))))
;;                       (equal (covering (g-subst exp var1 term flg) var flg) (covering exp var flg))))
;; (defun var-set
;;       (list n)
;;       (if (zerop n)
;;           (equal list nil)
;;           (and (g-variable (car list))
;;                (not (member (car list) (cdr list)))
;;                (var-set (cdr list) (sub1 n)))))
;; (defthm nil-intersect-append

;;              (equal (nil-intersect x (g-append y z))
;;                     (and (nil-intersect x y)
;;                          (nil-intersect x z))))
;; (defthm var-set-length (implies (var-set x count) (var-set x (length x))))
;; (defthm nil-intersect-subst

;;              (implies (and (g-variable var)
;;                            (var-set x (length x))
;;                            (nil-intersect x (collect-free exp flg))
;;                            (nil-intersect x (collect-free term 0)))
;;                       (nil-intersect x (collect-free (g-subst exp var term flg) flg)))
;;              ((induct (nil-intersect x y))))
;; (defthm nil-intersect-cons2

;;              (equal (nil-intersect x (cons y z))
;;                     (and (not (memb y x))
;;                          (nil-intersect x z))))
;; ;; par-subst is the first definition of simultaneous substitution.
;; ;; it returns "[t1/x1, t2/x2,...,tn/xn]a".  it employs a list of
;; ;; new variables "yi" and evaluates "[t1/y1]...[tn/yn][yn/xn]...[y1/x1]a".
;; ;; this is in order to avoid substituting for an occurrence of an "xi"
;; ;; in some "tj".  this definition of simultaneous substitution while
;; ;; clumsy, turns out to be convenient for the proof of instantiation rule,
;; ;; which by necessity must be derived from the substitution rule above.
;; (defun par-subst
;;       (exp vars terms auxvars)
;;       (if (and (consp vars)
;;                (consp terms)
;;                (consp auxvars))
;;           (g-subst (par-subst (g-subst exp (car vars) (car auxvars) 0)
;;                             (cdr vars)
;;                             (cdr terms)
;;                             (cdr auxvars))
;;                  (car auxvars)
;;                  (car terms)
;;                  0)
;;           exp))
;; ;; the unsubstituted free variables in exp remain free after par-subst.
;; (defthm par-subst-collect-free

;;              (implies (and (g-variable aux)
;;                            (member aux (collect-free exp 0))
;;                            (var-set auxlist (length varlist))
;;                            (var-set varlist (length varlist))
;;                            (not (member aux varlist))
;;                            (not (member aux auxlist)))
;;                       (member aux (collect-free (par-subst exp varlist termlist auxlist) 0))))
;; ;; the covering of an unsubsubstituted free variables in exp is unchanged
;; ;; after par-subst, provided it does not occur free in termlist.
;; (defthm par-subst-covering

;;              (implies (and (equal (length termlist) (length varlist))
;;                            (not (member aux (collect-free termlist 1)))
;;                            (not (member aux auxlist))
;;                            (not (member aux varlist))
;;                            (var-set varlist (length varlist))
;;                            (var-set auxlist (length varlist))
;;                            (g-variable aux))
;;                       (equal (covering (par-subst exp varlist termlist auxlist) aux 0)
;;                              (covering exp aux 0))))
;; ;; free-for-list checks if each term in termlist is free for the corresponding
;; ;; variable in varlist, in a.
;; (defun free-for-list
;;       (a varlist termlist)
;;       (if (and (consp varlist)
;;                (consp termlist))
;;           (and (free-for a (car varlist) (car termlist) 0)
;;                (free-for-list a (cdr varlist) (cdr termlist)))
;;           t))
;; ;; the variables covering aux in (g-subst exp var aux 0) are the ones covering var
;; ;; in exp, and that is unaffected by par-subst, when the hypotheses below hold.
;; (defthm covering-par-subst

;;              (implies (and (g-variable var)
;;                            (g-variable aux)
;;                            (not (member aux (collect-free termlist 1)))
;;                            (not (member aux (collect-free exp 0)))
;;                            (not (member aux (covering exp var 0)))
;;                            (not (member aux auxlist))
;;                            (not (member aux varlist))
;;                            (var-set varlist (length varlist))
;;                            (var-set auxlist (length varlist))
;;                            (equal (length termlist) (length varlist)))
;;                       (equal (covering (par-subst (g-subst exp var aux 0) varlist termlist auxlist)
;;                                        aux
;;                                        0)
;;                              (covering exp var 0))))
;; ;; inst-conditions lays down the various conditions for par-subst to be a proper
;; ;; simultaneous substitution: (1) vars and auxvars must be sets of variables,
;; ;; (2) terms must be a list of terms, (3) auxvars must be a list of new variables,
;; ;; (4) the auxvars must be free the respective vars in a, and (5) the terms must
;; ;; be free for the respective vars in a.
;; (defun inst-conditions
;;       (a vars terms auxvars symbols)
;;       (and (var-set vars (length vars))
;;            (var-set auxvars (length vars))
;;            (g-termp terms 1 symbols)
;;            (equal (length terms) (length vars))
;;            (nil-intersect auxvars (collect-free terms 1))
;;            (nil-intersect auxvars (collect-free a 0))
;;            (nil-intersect auxvars vars)
;;            (free-for-list a vars auxvars)
;;            (free-for-list a vars terms)))
;; ;; free-for-list is unaffected by an irrelevant substitution into a.
;; (defthm free-for-list-elim

;;              (implies (and (g-variable var)
;;                            (g-variable aux)
;;                            (var-set vars (length vars))
;;                            (not (member var vars))
;;                            (not (member aux vars))
;;                            (free-for-list a vars terms))
;;                       (free-for-list (g-subst a var aux 0) vars terms)))
;; ;; par-subst-proof constructs the proof of the instance of a, given the proof of a.
;; (defun par-subst-proof
;;       (a vars terms auxvars pf1)
;;       (if (and (consp vars)
;;                (consp terms)
;;                (consp auxvars))
;;           (subst-rule-proof (par-subst (g-subst a (car vars) (car auxvars) 0)
;;                                        (cdr vars)
;;                                        (cdr terms)
;;                                        (cdr auxvars))
;;                             (car auxvars)
;;                             (car terms)
;;                             (par-subst-proof (g-subst a (car vars) (car auxvars) 0)
;;                                              (cdr vars)
;;                                              (cdr terms)
;;                                              (cdr auxvars)
;;                                              (subst-rule-proof a (car vars) (car auxvars) pf1)))
;;           pf1))
;; ;; the lemma below is the first form of the instantiation rule.
;; ;; it asserts that if a is provable, so is any instance of it as
;; ;; constructed by par-subst.
;; (defthm par-subst-proof-proves

;;              (implies (and (inst-conditions a vars terms auxvars symbols)
;;                            (proves pf1 a given defns symbols))
;;                       (proves (par-subst-proof a vars terms auxvars pf1)
;;                               (par-subst a vars terms auxvars)
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (par-subst-proof a vars terms auxvars pf1))))
;; ;; since par-subst is not a very efficient way to carry out simultaneous
;; ;; substitution, we will prove it to be equivalent to a different
;; ;; form of simultaneous substitution.
;; (defun del-pairs
;;       (var vars terms)
;;       (if (and (consp vars)
;;                (consp terms))
;;           (if (g-eql (car vars) var)
;;               (del-pairs var (cdr vars) (cdr terms))
;;               (cons (car terms) (del-pairs var (cdr vars) (cdr terms))))
;;           terms))
;; (defun getsub
;;       (var vars terms)
;;       (if (and (consp vars)
;;                (consp terms))
;;           (if (g-eql (car vars) var) (car terms) (getsub var (cdr vars) (cdr terms)))
;;           var))
;; (defthm del-pairs-getsub

;;              (implies (g-variable var)
;;                       (equal (getsub var (del var vars) (del-pairs var vars terms)) var)))
;; ;; parallel-subst below is the more efficient form of simultaneous substitution.
;; ;; it recurses down exp and replaces any free occurrence of a variable in
;; ;; vars by the corresponding term in terms.
;; (defun parallel-subst
;;       (exp vars terms flg)
;;       (if (zerop flg)
;;           (if (g-variable exp)
;;               (getsub exp vars terms)
;;               (if (f-notp exp)
;;                   (f-not (parallel-subst (arg exp) vars terms 0))
;;                   (if (f-orp exp)
;;                       (f-or (parallel-subst (arg1 exp) vars terms 0)
;;                             (parallel-subst (arg2 exp) vars terms 0))
;;                       (if (forsomep exp)
;;                           (forsome (bind exp)
;;                                    (parallel-subst (g-body exp)
;;                                                    (del (bind exp) vars)
;;                                                    (del-pairs (bind exp) vars terms)
;;                                                    0))
;;                           (if (consp exp)
;;                               (cons (car exp) (parallel-subst (cdr exp) vars terms 1))
;;                               exp)))))
;;           (if (consp exp)
;;               (cons (parallel-subst (car exp) vars terms 0)
;;                     (parallel-subst (cdr exp) vars terms 1))
;;               exp)))
;; (defthm getsub-not-memb

;;              (implies (not (memb var varlist)) (equal (getsub var varlist terms) var)))
;; (defthm eql-trans

;;              (implies (and (g-eql x y)
;;                            (g-eql y z))
;;                       (g-eql x z)))
;; (defthm getsub-del-pairs

;;              (implies (equal (getsub var vars terms) var)
;;                       (equal (getsub var (del var1 vars) (del-pairs var1 vars terms)) var)))
;; (toggle g0636 eql-trans t)
;; ;; the lemma below asserts that the effect of a single substitution
;; ;; followed by a simultaneous substitution, can be got by extending the
;; ;; simultaneous substitution.
;; (defthm newvar-unchanged-by-parallel-subst

;;              (implies (and (equal (getsub newvar vars terms) newvar)
;;                            (g-variable var)
;;                            (g-variable newvar))
;;                       (equal (parallel-subst (g-subst exp var newvar flg) vars terms flg)
;;                              (parallel-subst exp (cons var vars) (cons newvar terms) flg)))
;;              ((induct (parallel-subst exp vars terms flg))))
;; (defthm not-free-in-terms-step

;;              (implies (and (g-variable var)
;;                            (g-variable newvar)
;;                            (not (equal newvar var))
;;                            (not (member newvar (collect-free terms 1))))
;;                       (not (member newvar (collect-free (getsub var vars terms) 0)))))
;; (defthm collect-terms-del-pairs

;;              (implies (not (member newvar (collect-free terms 1)))
;;                       (not (member newvar (collect-free (del-pairs var vars terms) 1)))))
;; (defthm collect-free-parallel-subst

;;              (implies (and (g-variable newvar)
;;                            (not (member newvar (collect-free exp flg)))
;;                            (not (member newvar (collect-free terms 1))))
;;                       (not (member newvar
;;                                    (collect-free (parallel-subst exp vars terms flg) flg)))))
;; (defthm parallel-subst-not-free-var

;;              (implies (and (g-variable var)
;;                            (not (member var (collect-free exp flg))))
;;                       (equal (parallel-subst exp (cons var vars) (cons term terms) flg)
;;                              (parallel-subst exp vars terms flg))))
;; (defthm subst-parallel-subst

;;              (implies (and (g-variable newvar)
;;                            (not (member newvar (collect-free exp flg)))
;;                            (not (member newvar (collect-free terms 1))))
;;                       (equal (g-subst (parallel-subst exp vars terms flg) newvar newterm flg)
;;                              (parallel-subst exp vars terms flg))))
;; ;; a parallel-subst where var is replaced by newvar, followed by a single substitution
;; ;; where newvar is replaced by newterm, is equivalent to the same parallel-subst
;; ;; with var replaced by newterm instead.
;; (defthm parallel-subst-subst

;;              (implies (and (g-variable newvar)
;;                            (g-variable var)
;;                            (not (member newvar (collect-free exp flg)))
;;                            (not (member newvar (collect-free terms 1)))
;;                            (not (member newvar (covering exp var flg))))
;;                       (equal (g-subst (parallel-subst exp (cons var vars) (cons newvar terms) flg)
;;                                     newvar
;;                                     newterm
;;                                     flg)
;;                              (parallel-subst exp (cons var vars) (cons newterm terms) flg)))
;;              ((induct (parallel-subst exp vars terms flg))))

;; ;; a null parallel-substitution leaved exp unchanged.
;; (defthm parallel-subst-nil

;;              (implies (or (atom vars)
;;                           (atom terms))
;;                       (equal (parallel-subst exp vars terms flg) exp)))
;; ;; finally, the desired lemma that par-subst is equivalent to parallel-subst,
;; ;; if the hypothesis conditions hold.
;; (defthm parallel-subst-same-as-par-subst

;;              (implies (and (var-set vars (length vars))
;;                            (var-set auxvars (length auxvars))
;;                            (equal (length auxvars) (length vars))
;;                            (nil-intersect auxvars vars)
;;                            (free-for-list exp vars auxvars)
;;                            (nil-intersect auxvars (collect-free terms 1))
;;                            (nil-intersect auxvars (collect-free exp 0)))
;;                       (equal (par-subst exp vars terms auxvars) (parallel-subst exp vars terms 0)))
;;              ((induct (par-subst exp vars terms auxvars)) (disable subst-parallel-subst)))
;; ;; we still have to show that list of new variables auxvars can be constructed.
;; ;; that is done in the sequence of events (definitions and lemmas) below.
;; (defun make-newvars
;;       (index number)
;;       (if (zerop number) nil (cons (add1 index) (make-newvars (add1 index) (sub1 number)))))
;; (defun find-hi-index
;;       (varlist)
;;       (if (consp varlist)
;;           (if (< (car varlist) (find-hi-index (cdr varlist)))
;;               (find-hi-index (cdr varlist))
;;               (fix (car varlist)))
;;           0))
;; (defun make-auxvars (varlist number) (make-newvars (find-hi-index varlist) number))
;; (defthm not-member-varlist

;;              (implies (< (find-hi-index varlist) var) (not (member var varlist))))
;; (defthm newvars-make-newvars

;;              (implies (leq (find-hi-index varlist) index)
;;                       (nil-intersect (make-newvars index number) varlist))
;;              ((induct (make-newvars index number))))
;; (defthm var-set-make-newvars-step

;;              (implies (leq var index) (not (member var (make-newvars index number)))))
;; (defthm append-var-list

;;              (implies (and (var-list x (length x))
;;                            (var-list y (length y)))
;;                       (var-list (g-append x y) (length (g-append x y)))))
;; (defun covering-list
;;       (exp vars flg)
;;       (if (consp vars)
;;           (g-append (covering exp (car vars) flg) (covering-list exp (cdr vars) flg))
;;           nil))
;; (defthm free-for-list-newvars-covering-list

;;              (implies (and (var-set newvars (length newvars))
;;                            (nil-intersect newvars (covering-list exp vars 0)))
;;                       (free-for-list exp vars newvars)))
;; (defthm var-list-var-set (implies (var-set vars length) (var-list vars length)))
;; (defthm find-hi-index-append

;;              (equal (find-hi-index (g-append list1 list2))
;;                     (if (< (find-hi-index list1) (find-hi-index list2))
;;                         (find-hi-index list2)
;;                         (find-hi-index list1))))
;; (defun collect-vars
;;       (exp vars terms)
;;       (g-append vars
;;               (g-append (collect-free terms 1)
;;                       (g-append (collect-free exp 0) (covering-list exp vars 0)))))
;; (defthm nil-intersect-newvars-vars

;;              (nil-intersect (make-newvars (find-hi-index (collect-vars exp vars terms)) length)
;;                             vars))
;; (defthm nil-intersect-newvars-terms

;;              (nil-intersect (make-newvars (find-hi-index (collect-vars exp vars terms)) length)
;;                             (collect-free terms 1))
;;              ((disable collect-free)))
;; (defthm nil-intersect-newvars-exp

;;              (nil-intersect (make-newvars (find-hi-index (collect-vars exp vars terms)) length)
;;                             (collect-free exp 0))
;;              ((disable collect-free)))
;; (defthm var-set-make-newvars-again (var-set (make-newvars index number) number))
;; (defthm length-make-newvars (equal (length (make-newvars x n)) (fix n)))
;; (defthm free-for-list-newvars-exp

;;              (free-for-list exp
;;                             vars
;;                             (make-newvars (find-hi-index (collect-vars exp vars terms)) length)))
;; (toggle g0347 make-newvars t)
;; (defun instance-proof
;;       (a vars terms pf1)
;;       (par-subst-proof a vars terms (make-auxvars (collect-vars a vars terms) (length vars)) pf1))
;; (defthm par-subst-proof-proves1

;;              (implies (and (equal concl (par-subst a vars terms auxvars))
;;                            (inst-conditions a vars terms auxvars symbols)
;;                            (proves pf1 a given defns symbols))
;;                       (proves (par-subst-proof a vars terms auxvars pf1)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (par-subst-proof-proves)) (disable inst-conditions)))
;; (toggle g0346 par-subst-proof t)
;; (toggle g0350 find-hi-index t)
;; (toggle g0351 find-hi-index-append t)
;; ;; the instantiation rule can then be phrased as shown below, in terms
;; ;; of parallel-subst instead of par-subst.
;; (defthm instance-proof-proves

;;              (implies (and (equal a-prime (parallel-subst a vars terms 0))
;;                            (var-set vars (length vars))
;;                            (g-termp terms 1 symbols)
;;                            (equal (length terms) (length vars))
;;                            (free-for-list a vars terms)
;;                            (proves pf1 a given defns symbols))
;;                       (proves (instance-proof a vars terms pf1) a-prime given defns symbols))
;;              ((disable collect-vars)))
;; (defun list-exis-quantify
;;       (vars a)
;;       (if (consp vars) (forsome (car vars) (list-exis-quantify (cdr vars) a)) a))
;; (defthm not-member-del-pairs (implies (not (memb x y)) (equal (del-pairs x y z) z)))
;; (defthm not-member-delete-equals (implies (not (memb x y)) (equal (del x y) y)))
;; (defun pairlist
;;       (vars terms)
;;       (if (and (consp vars)
;;                (consp terms))
;;           (cons (cons (car vars) (car terms)) (pairlist (cdr vars) (cdr terms)))
;;           nil))
;; (defthm parallel-subst-list-exis-quant

;;              (implies (var-set vars (length vars))
;;                       (equal (parallel-subst (list-exis-quantify vars a) vars terms 0)
;;                              (list-exis-quantify vars a)))
;;              ((induct (pairlist vars terms))))
;; (defun list-e-intro-proof
;;       (varlist a)
;;       (if (consp varlist)
;;           (if (consp (cdr varlist))
;;               (trans-implies-proof a
;;                                    (list-exis-quantify (cdr varlist) a)
;;                                    (list-exis-quantify varlist a)
;;                                    (list-e-intro-proof (cdr varlist) a)
;;                                    (e-intro-proof (car varlist)
;;                                                   (list-exis-quantify (cdr varlist) a)))
;;               (e-intro-proof (car varlist) a))
;;           (prop-axiom-proof a)))
;; (defthm formula-list-exis

;;              (implies (and (g-formula a symbols)
;;                            (var-set vars (length vars)))
;;                       (g-formula (list-exis-quantify vars a) symbols)))
;; (toggle g0353 instance-proof t)
;; (toggle g0354 f-implies nil)
;; (defthm a-implies-a

;;              (implies (g-formula a symbols)
;;                       (proves (prop-axiom-proof a) (f-implies a a) given defns symbols)))
;; (defthm parallel-subst-f-implies

;;              (equal (parallel-subst (f-implies a b) vars terms 0)
;;                     (f-implies (parallel-subst a vars terms 0) (parallel-subst b vars terms 0))))
;; (defthm subst-f-implies

;;              (equal (g-subst (f-implies x y) var term 0)
;;                     (f-implies (g-subst x var term 0) (g-subst y var term 0))))
;; (toggle g0355 f-implies t)
;; ;; the iterated forsome-introduction rule:
;; ;;    "a -> (forsome x1 (...(forsome xn a)))".
;; (defthm list-e-intro-proof-proves1
;;              nil
;;              (implies (and (var-set varlist (length varlist))
;;                            (g-formula a symbols))
;;                       (proves (list-e-intro-proof varlist a)
;;                               (f-implies a (list-exis-quantify varlist a))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0348 list-e-intro-proof t)
;; (defthm list-e-intro-proof-proves

;;              (implies (and (var-set varlist (length varlist))
;;                            (g-formula a symbols)
;;                            (equal a-prime (list-exis-quantify varlist a)))
;;                       (proves (list-e-intro-proof varlist a)
;;                               (f-implies a a-prime)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (list-e-intro-proof-proves1))))
;; (defun subst-thm-a-proof
;;       (a vars terms)
;;       (instance-proof (f-implies a (list-exis-quantify vars a))
;;                       vars
;;                       terms
;;                       (list-e-intro-proof vars a)))
;; (defthm not-free-list-exis

;;              (implies (and (var-set vars (length vars))
;;                            (member var vars))
;;                       (not (member var (collect-free (list-exis-quantify vars a) 0)))))
;; (defthm not-memb-del2 (implies (not (memb x y)) (not (memb x (del z y)))))
;; (defthm covering-list-exis

;;              (implies (and (var-set vars (length vars))
;;                            (member var vars)
;;                            (acl2-numberp var))
;;                       (equal (covering (list-exis-quantify vars a) var 0) nil)))
;; (defthm free-for-list-step1

;;              (implies (and (var-set vars (length vars))
;;                            (var-set bvars (length bvars))
;;                            (subset vars bvars)
;;                            (free-for-list a vars terms))
;;                       (free-for-list (f-implies a (list-exis-quantify bvars a)) vars terms))
;;              ((disable list-exis-quantify)))
;; ;; the first substitution theorem:
;; ;;  "[t1/x1, t2/x2,...,tn/xn]a -> (forsome x1 (...(forsome xn a)))".
;; (defthm subst-thm-a

;;              (implies (and (var-set vars (length vars))
;;                            (g-termp terms 1 symbols)
;;                            (equal (length terms) (length vars))
;;                            (free-for-list a vars terms)
;;                            (g-formula a symbols)
;;                            (equal a-prime
;;                                   (f-implies (parallel-subst a vars terms 0)
;;                                              (list-exis-quantify vars a))))
;;                       (proves (subst-thm-a-proof a vars terms) a-prime given defns symbols)))
;; (toggle g0356 subst-thm-a-proof t)
;; (defun list-all-quantify
;;       (vars a)
;;       (if (consp vars) (forall (car vars) (list-all-quantify (cdr vars) a)) a))
;; (defthm parallel-subst-list-all-quant

;;              (implies (var-set vars (length vars))
;;                       (equal (parallel-subst (list-all-quantify vars a) vars terms 0)
;;                              (list-all-quantify vars a)))
;;              ((induct (pairlist vars terms))))
;; (defun list-all-elim-proof
;;       (vars a)
;;       (if (consp vars)
;;           (if (atom (cdr vars))
;;               (all-elim-proof (car vars) a)
;;               (trans-implies-proof (list-all-quantify vars a)
;;                                    (list-all-quantify (cdr vars) a)
;;                                    a
;;                                    (all-elim-proof (car vars) (list-all-quantify (cdr vars) a))
;;                                    (list-all-elim-proof (cdr vars) a)))
;;           (prop-axiom-proof a)))
;; (defthm formula-list-all-quant

;;              (implies (and (var-set vars (length vars))
;;                            (g-formula a symbols))
;;                       (g-formula (list-all-quantify vars a) symbols)))
;; (defthm all-elim-proof-proves-again

;;              (implies (and (g-variable var)
;;                            (g-formula a symbols)
;;                            (equal a-prime (f-implies (forall var a) a)))
;;                       (proves (all-elim-proof var a) a-prime given defns symbols))
;;              ((use (all-elim-proof-proves (c a)))))
;; (defthm list-all-elim-proof-proves1
;;              nil
;;              (implies (and (var-set vars (length vars))
;;                            (g-formula a symbols))
;;                       (proves (list-all-elim-proof vars a)
;;                               (f-implies (list-all-quantify vars a) a)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0357 list-all-elim-proof t)
;; (defthm not-free-list-all

;;              (implies (and (var-set vars (length vars))
;;                            (member var vars))
;;                       (not (member var (collect-free (list-all-quantify vars a) 0)))))
;; (defthm covering-list-all

;;              (implies (and (var-set vars (length vars))
;;                            (member var vars)
;;                            (acl2-numberp var))
;;                       (equal (covering (list-all-quantify vars a) var 0) nil)))
;; (defthm free-for-list-step2

;;              (implies (and (var-set vars (length vars))
;;                            (var-set bvars (length bvars))
;;                            (subset vars bvars)
;;                            (free-for-list a vars terms))
;;                       (free-for-list (f-implies (list-all-quantify bvars a) a) vars terms))
;;              ((disable list-exis-quantify)))
;; (defun subst-thm-b-proof
;;       (a vars terms)
;;       (instance-proof (f-implies (list-all-quantify vars a) a)
;;                       vars
;;                       terms
;;                       (list-all-elim-proof vars a)))
;; (defthm list-all-elim-proof-proves

;;              (implies (and (var-set vars (length vars))
;;                            (g-formula a symbols)
;;                            (equal a-prime (f-implies (list-all-quantify vars a) a)))
;;                       (proves (list-all-elim-proof vars a) a-prime given defns symbols))
;;              ((use (list-all-elim-proof-proves1))))
;; ;; the second substitution theorem:
;; ;;     "(forall x1 (...(forall xn a))) -> [t1/x1, ..., tn/xn]a".
;; (defthm subst-thm-b

;;              (implies (and (var-set vars (length vars))
;;                            (g-termp terms 1 symbols)
;;                            (equal (length terms) (length vars))
;;                            (g-formula a symbols)
;;                            (free-for-list a vars terms)
;;                            (equal a-prime
;;                                   (f-implies (list-all-quantify vars a)
;;                                              (parallel-subst a vars terms 0))))
;;                       (proves (subst-thm-b-proof a vars terms) a-prime given defns symbols)))
;; (toggle g0358 subst-thm-b-proof t)
;; (defun distrib-rule-proof-a
;;       (var a b pf1)
;;       (forsome-intro-proof var
;;                            a
;;                            (forsome var b)
;;                            (trans-implies-proof a b (forsome var b) pf1 (e-intro-proof var b))))
;; ;; the first distribution rule:  derive "(forsome x a) -> (forsome x b)" from "a -> b".
;; (prove-lemma
;;  distrib-rule-proof-a-proves

;;  (implies (and (g-variable var)
;;                (proves pf1 (f-implies a b) given defns symbols))
;;           (proves (distrib-rule-proof-a var a b pf1)
;;                   (f-implies (forsome var a) (forsome var b))
;;                   given
;;                   defns
;;                   symbols))
;;  ((use (proves-is-formula-again (exp (f-implies a b)) (pf pf1))) (disable proves-is-formula)))
;; (toggle g0360 distrib-rule-proof-a t)
;; (defun distrib-rule-proof-b
;;       (var a b pf1)
;;       (forall-intro-proof (forall var a)
;;                           b
;;                           var
;;                           (trans-implies-proof (forall var a) a b (all-elim-proof var a) pf1)))
;; ;; the second distribution rule:  derive "(forall x a) -> (forall x b)" from "a -> b".
;; (defthm distrib-rule-proof-b-proves

;;              (implies (and (g-variable var)
;;                            (proves pf (f-implies a b) given defns symbols)
;;                            (equal a-prime (f-implies (forall var a) (forall var b))))
;;                       (proves (distrib-rule-proof-b var a b pf) a-prime given defns symbols))
;;              ((use (proves-is-formula-again (exp (f-implies a b)))) (disable proves-is-formula)))
;; (toggle g0361 distrib-rule-proof-b t)
;; (defthm formula-forall

;;              (equal (g-formula (forall var exp) symbols) (g-formula exp symbols)))
;; (defthm collect-free-forsome

;;              (implies (g-variable var)
;;                       (equal (collect-free (forsome var exp) 0) (del var (collect-free exp 0)))))
;; (defthm collect-free-forall

;;              (implies (g-variable var)
;;                       (equal (collect-free (forall var exp) 0) (del var (collect-free exp 0)))))
;; (defthm covering-forall

;;              (implies (g-variable var)
;;                       (equal (covering (forall var exp) x 0)
;;                              (if (memb x (collect-free (forall var exp) 0))
;;                                  (cons var (covering exp x 0))
;;                                  nil))))
;; (defthm parallel-subst-forall

;;              (implies (g-variable var)
;;                       (equal (parallel-subst (forall var exp) vars terms 0)
;;                              (forall var
;;                                      (parallel-subst exp
;;                                                      (del var vars)
;;                                                      (del-pairs var vars terms)
;;                                                      0)))))
;; (defthm subst-forall

;;              (implies (g-variable var)
;;                       (equal (g-subst (forall var exp) x term 0)
;;                              (if (equal var x)
;;                                  (forall var exp)
;;                                  (forall var (g-subst exp x term 0))))))
;; (toggle g0363 forall t)
;; (defun list-f-iff
;;       (lhs rhs)
;;       (if (and (consp lhs)
;;                (consp rhs))
;;           (cons (f-iff (car lhs) (car rhs)) (list-f-iff (cdr lhs) (cdr rhs)))
;;           nil))
;; (defun f-iff-distrib-rule-a-proof
;;       (var a a-prime pf)
;;       (iff-join-proof (forsome var a)
;;                       (forsome var a-prime)
;;                       (distrib-rule-proof-a var a a-prime (iff-split-proof1 a a-prime pf))
;;                       (distrib-rule-proof-a var a-prime a (iff-split-proof2 a a-prime pf))))
;; (defthm f-iff-distrib-rule-a-proof-proves

;;              (implies (and (proves pf (f-iff a a-prime) given defns symbols)
;;                            (g-variable var))
;;                       (proves (f-iff-distrib-rule-a-proof var a a-prime pf)
;;                               (f-iff (forsome var a) (forsome var a-prime))
;;                               given
;;                               defns
;;                               symbols)))
;; (defun not-iff-proof
;;       (a b pf)
;;       (tautconseq-proof (list (f-iff a b)) (f-iff (f-not a) (f-not b)) (list pf)))
;; (defthm not-iff-proof-proves

;;              (implies (proves pf (f-iff a b) given defns symbols)
;;                       (proves (not-iff-proof a b pf)
;;                               (f-iff (f-not a) (f-not b))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (exp (f-iff a b))))))
;; (toggle g0317 not-iff-proof t)
;; (toggle g0318 f-iff-distrib-rule-a-proof t)
;; (defun or-iff-proof
;;       (a1 a2 b1 b2 pf1 pf2)
;;       (tautconseq-proof (list (f-iff a1 b1) (f-iff a2 b2))
;;                         (f-iff (f-or a1 a2) (f-or b1 b2))
;;                         (list pf1 pf2)))
;; (defthm or-iff-proof-proves

;;              (implies (and (proves pf1 (f-iff a1 b1) given defns symbols)
;;                            (proves pf2 (f-iff a2 b2) given defns symbols))
;;                       (proves (or-iff-proof a1 a2 b1 b2 pf1 pf2)
;;                               (f-iff (f-or a1 a2) (f-or b1 b2))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-iff a1 b1)))
;;                    (proves-is-formula (pf pf2) (exp (f-iff a2 b2))))
;;               ))
;; (toggle g0319 or-iff-proof t)
;; ;; eqn-form checks if a and a-prime are identical modulo the equivalences
;; ;; given in the list given.  it is used to prove the equivalence theorem.
;; (defun eqn-form
;;       (a-prime a given)
;;       (if (equal a-prime a)
;;           t
;;           (if (member (f-iff a a-prime) given)
;;               t
;;               (if (and (f-notp a)
;;                        (f-notp a-prime))
;;                   (eqn-form (arg a-prime) (arg a) given)
;;                   (if (and (f-orp a)
;;                            (f-orp a-prime))
;;                       (and (eqn-form (arg1 a-prime) (arg1 a) given)
;;                            (eqn-form (arg2 a-prime) (arg2 a) given))
;;                       (if (and (forsomep a)
;;                                (forsomep a-prime))
;;                           (and (equal (bind a) (bind a-prime))
;;                                (eqn-form (g-body a-prime) (g-body a) given))
;;                           nil))))))
;; (defun getpf
;;       (x y z)
;;       (if (and (consp y)
;;                (consp z))
;;           (if (equal x (car y)) (car z) (getpf x (cdr y) (cdr z)))
;;           x))
;; (defthm getpf-proves

;;              (implies (and (proves-list pflist list given defns symbols)
;;                            (member concl list))
;;                       (proves (getpf concl list pflist) concl given defns symbols)))
;; (toggle g0596 proves nil)
;; (defthm eql-trans2

;;              (implies (and (g-eql x z)
;;                            (g-eql y z))
;;                       (g-eql x y)))
;; (defthm eql-trans3

;;              (implies (and (g-eql x y)
;;                            (g-eql x z))
;;                       (g-eql y z)))
;; (defthm proves-eql

;;              (implies (and (proves pf conc1 given defns symbols)
;;                            (g-eql conc1 conc2)
;;                            (g-formula conc2 symbols))
;;                       (proves pf conc2 given defns symbols)))
;; (toggle g0598 proves t)
;; (defthm getsub-proves

;;              (implies (and (proves-list pflist list given defns symbols)
;;                            (memb concl list)
;;                            (g-formula concl symbols))
;;                       (proves (getsub concl list pflist) concl given defns symbols)))
;; (toggle g0600 proves-eql t)
;; ;; eqn-form-proof is the proof-constructor which constructs the proof of the
;; ;; equivalence of a and a-prime from the proofs of the equivalences in given.
;; (defun eqn-form-proof
;;       (a-prime a given pflist)
;;       (if (equal a-prime a)
;;           (tautconseq-proof nil (f-iff a a) nil)
;;           (if (member (f-iff a a-prime) given)
;;               (getpf (f-iff a a-prime) given pflist)
;;               (if (and (f-notp a)
;;                        (f-notp a-prime))
;;                   (not-iff-proof (arg a)
;;                                  (arg a-prime)
;;                                  (eqn-form-proof (arg a-prime) (arg a) given pflist))
;;                   (if (and (f-orp a)
;;                            (f-orp a-prime))
;;                       (or-iff-proof (arg1 a)
;;                                     (arg2 a)
;;                                     (arg1 a-prime)
;;                                     (arg2 a-prime)
;;                                     (eqn-form-proof (arg1 a-prime) (arg1 a) given pflist)
;;                                     (eqn-form-proof (arg2 a-prime) (arg2 a) given pflist))
;;                       (if (and (forsomep a)
;;                                (forsomep a-prime))
;;                           (f-iff-distrib-rule-a-proof (bind a)
;;                                                       (g-body a)
;;                                                       (g-body a-prime)
;;                                                       (eqn-form-proof (g-body a-prime)
;;                                                                       (g-body a)
;;                                                                       given
;;                                                                       pflist))
;;                           nil))))))
;; ;; the equivalence theorem:  if a and a-prime are identical modulo the
;; ;; proven equivalences in given (whose proofs are in pflist), then
;; ;;  "a <-> a-prime" is provable.
;; (defthm eqn-form-proof-proves1

;;              (implies (and (g-formula (f-iff a a-prime) symbols)
;;                            (eqn-form a-prime a list)
;;                            (proves-list pflist list given defns symbols))
;;                       (proves (eqn-form-proof a-prime a list pflist)
;;                               (f-iff a a-prime)
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (eqn-form a-prime a list))))
;; (toggle g0338 eqn-form-proof t)
;; (defun elim-link-proof
;;       (x y z pf1 pf2)
;;       (tautconseq-proof (list (f-implies x (f-implies y z)) (f-implies x y))
;;                         (f-implies x z)
;;                         (list pf1 pf2)))
;; (defthm elim-link-proof-proves

;;              (implies (and (proves pf1 (f-implies x (f-implies y z)) given defns symbols)
;;                            (proves pf2 (f-implies x y) given defns symbols))
;;                       (proves (elim-link-proof x y z pf1 pf2) (f-implies x z) given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies x (f-implies y z)))))))
;; (toggle g0499 elim-link-proof t)
;; (defun elim-args-proof
;;       (hyp args exp pflist pf)
;;       (if (consp args)
;;           (elim-args-proof hyp
;;                            (cdr args)
;;                            exp
;;                            (cdr pflist)
;;                            (elim-link-proof hyp
;;                                             (car args)
;;                                             (list-implies (cdr args) exp)
;;                                             pf
;;                                             (car pflist)))
;;           pf))
;; (defun dist-f-implies
;;       (hyp list)
;;       (if (consp list) (cons (f-implies hyp (car list)) (dist-f-implies hyp (cdr list))) nil))
;; (toggle g0506 list-implies-reduc t)
;; (prove-lemma
;;  elim-args-proof-proves

;;  (implies (and (g-formula exp symbols)
;;                (proves-list pflist (dist-f-implies hyp args) given defns symbols)
;;                (proves pf (f-implies hyp (list-implies args exp)) given defns symbols))
;;           (proves (elim-args-proof hyp args exp pflist pf)
;;                   (f-implies hyp exp)
;;                   given
;;                   defns
;;                   symbols))
;;  ((induct (elim-args-proof hyp args exp pflist pf))
;;   (use (proves-list-form-list (flist (dist-f-implies hyp args))))))
;; (toggle g0507 elim-args-proof t)
;; (defun symmetry-proof1
;;       (x y)
;;       (tautconseq-proof (list (f-equal x x)
;;                               (f-implies (f-equal x y)
;;                                          (f-implies (f-equal x x)
;;                                                     (f-implies (f-equal x x) (f-equal y x)))))
;;                         (f-implies (f-equal x y) (f-equal y x))
;;                         (list (ident-axiom-proof x)
;;                               (equal-axiom2-proof (p 0 2) (list x x) (list y x)))))
;; (toggle g0365 f-equal nil)
;; (defthm equal-equal-axiom2

;;              (implies (g-formula (f-implies (f-equal x y)
;;                                           (f-implies (f-equal u v)
;;                                                      (f-implies (f-equal x u) (f-equal y v))))
;;                                symbols)
;;                       (proves (equal-axiom2-proof (p 0 2) (list x u) (list y v))
;;                               (f-implies (f-equal x y)
;;                                          (f-implies (f-equal u v)
;;                                                     (f-implies (f-equal x u) (f-equal y v))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0368 f-equal t)
;; ;; the symmetry theorem: "(x = y) -> (y = x)"
;; ;; the next few events lead up to the proof of the equality theorem.
;; (defthm symmetry-theorem1

;;              (implies (g-formula (f-equal x y) symbols)
;;                       (proves (symmetry-proof1 x y)
;;                               (f-implies (f-equal x y) (f-equal y x))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0372 symmetry-proof1 t)
;; (defun list-f-and
;;       (list)
;;       (if (consp list)
;;           (if (consp (cdr list)) (f-and (car list) (list-f-and (cdr list))) (car list))
;;           nil))
;; (defthm formula-list-f-and

;;              (implies (and (form-list list symbols)
;;                            (consp list))
;;                       (g-formula (list-f-and list) symbols)))
;; (defun list-f-and-member-proof
;;       (x list)
;;       (if (consp list)
;;           (if (consp (cdr list))
;;               (if (equal x (car list))
;;                   (tautconseq-proof nil (f-implies (f-and x (list-f-and (cdr list))) x) nil)
;;                   (tautconseq-proof (list (f-implies (list-f-and (cdr list)) x))
;;                                     (f-implies (list-f-and list) x)
;;                                     (list (list-f-and-member-proof x (cdr list)))))
;;               (tautconseq-proof nil (f-implies x x) nil))
;;           nil))
;; (defthm list-f-and-member-proof-proves

;;              (implies (and (form-list list symbols)
;;                            (member x list)
;;                            (g-formula x symbols))
;;                       (proves (list-f-and-member-proof x list)
;;                               (f-implies (list-f-and list) x)
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (list-f-and-member-proof x list))))
;; (toggle g0508 list-f-and t)
;; (defun add-hyp-proof (hyp exp pf) (tautconseq-proof (list exp) (f-implies hyp exp) (list pf)))
;; (defthm add-hyp-proof-proves

;;              (implies (and (g-formula hyp symbols)
;;                            (proves pf exp given defns symbols))
;;                       (proves (add-hyp-proof hyp exp pf) (f-implies hyp exp) given defns symbols))
;;              ((use (proves-is-formula))))
;; (toggle g0509 add-hyp-proof t)
;; (defun list-f-equal
;;       (lista listb)
;;       (if (and (consp lista)
;;                (consp listb))
;;           (cons (f-equal (car lista) (car listb)) (list-f-equal (cdr lista) (cdr listb)))
;;           nil))
;; (defun flg-f-implies-equal
;;       (hyp terma termb flg)
;;       (if (zerop flg)
;;           (f-implies hyp (f-equal terma termb))
;;           (dist-f-implies hyp (list-f-equal terma termb))))
;; (defun flg-proves
;;       (pf exp given defns symbols flg)
;;       (if (zerop flg)
;;           (proves pf exp given defns symbols)
;;           (proves-list pf exp given defns symbols)))
;; (defun term-list
;;       (terms symbols)
;;       (if (consp terms)
;;           (and (g-termp (car terms) 0 symbols)
;;                (term-list (cdr terms) symbols))
;;           t))
;; (defun flg-termp
;;       (term flg symbols)
;;       (if (zerop flg) (g-termp term 0 symbols) (term-list term symbols)))
;; (defthm termp-term-list (implies (g-termp exp 1 symbols) (term-list exp symbols)))
;; (defthm pairequals-reduc

;;              (equal (pairequals vars1 vars2 exp) (list-implies (list-f-equal vars1 vars2) exp))
;;              ((disable list-implies-reduc)))
;; (defthm formula-list-implies1

;;              (equal (g-formula (list-implies list exp) symbols)
;;                     (and (form-list list symbols)
;;                          (g-formula exp symbols))))
;; (defthm form-list-f-equal

;;              (implies (and (term-list terms1 symbols)
;;                            (term-list terms2 symbols))
;;                       (form-list (list-f-equal terms1 terms2) symbols)))
;; (defun symmetry-proof
;;       (a b)
;;       (iff-join-proof (f-equal a b) (f-equal b a) (symmetry-proof1 a b) (symmetry-proof1 b a)))
;; (defthm symmetry-theorem

;;              (implies (g-formula (f-equal a b) symbols)
;;                       (proves (symmetry-proof a b)
;;                               (f-iff (f-equal a b) (f-equal b a))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0373 symmetry-proof t)
;; (defun commute-equal-proof
;;       (x y pf)
;;       (detach-proof (f-equal x y) (f-equal y x) pf (symmetry-proof1 x y)))
;; (defthm commute-equal-proof-proves

;;              (implies (and (proves pf (f-equal x y) given defns symbols)
;;                            (equal concl (f-equal y x)))
;;                       (proves (commute-equal-proof x y pf) concl given defns symbols))
;;              ((use (proves-is-formula (exp (f-equal x y)))) (disable proves-is-formula)))
;; (toggle g0370 commute-equal-proof t)
;; (defun list-commute-equal-proof
;;       (lista listb pflist)
;;       (if (and (consp lista)
;;                (consp listb))
;;           (cons (commute-equal-proof (car lista) (car listb) (car pflist))
;;                 (list-commute-equal-proof (cdr lista) (cdr listb) (cdr pflist)))
;;           nil))
;; (defthm list-commute-equal-proof-proves

;;              (implies (proves-list pflist (list-f-equal lista listb) given defns symbols)
;;                       (proves-list (list-commute-equal-proof lista listb pflist)
;;                                    (list-f-equal listb lista)
;;                                    given
;;                                    defns
;;                                    symbols)))
;; (toggle g0371 list-commute-equal-proof t)
;; (defn
;;  forall-over-implies-proof
;;  (x a b)
;;  (tautconseq-proof
;;   (list (f-implies (forsome x a) (f-implies (forall x (f-implies a b)) (forsome x b))))
;;   (f-implies (forall x (f-implies a b)) (f-implies (forsome x a) (forsome x b)))
;;   (list (forsome-intro-proof x
;;                              a
;;                              (f-implies (forall x (f-implies a b)) (forsome x b))
;;                              (tautconseq-proof (list (f-implies (forall x (f-implies a b))
;;                                                                 (f-implies a b))
;;                                                      (f-implies b (forsome x b)))
;;                                                (f-implies a
;;                                                           (f-implies (forall x
;;                                                                              (f-implies a b))
;;                                                                      (forsome x b)))
;;                                                (list (all-elim-proof x (f-implies a b))
;;                                                      (e-intro-proof x b)))))))
;; (defthm forall-over-implies-proof-proves

;;              (implies (and (g-variable x)
;;                            (g-formula a symbols)
;;                            (g-formula b symbols))
;;                       (proves (forall-over-implies-proof x a b)
;;                               (f-implies (forall x (f-implies a b))
;;                                          (f-implies (forsome x a) (forsome x b)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0910 forall-over-implies-proof t)
;; (defn
;;  forall-over-iff-proof
;;  (x a b)
;;  (tautconseq-proof
;;   (list (f-implies (forsome x a) (f-implies (forall x (f-iff a b)) (forsome x b)))
;;         (f-implies (forsome x b) (f-implies (forall x (f-iff a b)) (forsome x a))))
;;   (f-implies (forall x (f-iff a b)) (f-iff (forsome x a) (forsome x b)))
;;   (list (forsome-intro-proof x
;;                              a
;;                              (f-implies (forall x (f-iff a b)) (forsome x b))
;;                              (tautconseq-proof (list (f-implies (forall x (f-iff a b))
;;                                                                 (f-iff a b))
;;                                                      (f-implies b (forsome x b)))
;;                                                (f-implies a
;;                                                           (f-implies (forall x (f-iff a b))
;;                                                                      (forsome x b)))
;;                                                (list (all-elim-proof x (f-iff a b))
;;                                                      (e-intro-proof x b))))
;;         (forsome-intro-proof x
;;                              b
;;                              (f-implies (forall x (f-iff a b)) (forsome x a))
;;                              (tautconseq-proof (list (f-implies (forall x (f-iff a b))
;;                                                                 (f-iff a b))
;;                                                      (f-implies a (forsome x a)))
;;                                                (f-implies b
;;                                                           (f-implies (forall x (f-iff a b))
;;                                                                      (forsome x a)))
;;                                                (list (all-elim-proof x (f-iff a b))
;;                                                      (e-intro-proof x a)))))))
;; (prove-lemma
;;  forall-over-iff-proof-proves

;;  (implies (and (g-variable x)
;;                (g-formula a symbols)
;;                (g-formula b symbols))
;;           (proves (forall-over-iff-proof x a b)
;;                   (f-implies (forall x (f-iff a b)) (f-iff (forsome x a) (forsome x b)))
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable eval-tautconseq-proof-proves)
;;   (use
;;    (eval-tautconseq-proof-proves (flist (list (f-implies (forall x (f-iff a b)) (f-iff a b))
;;                                               (f-implies b (forsome x b))))
;;                                  (exp (f-implies a
;;                                                  (f-implies (forall x (f-iff a b))
;;                                                             (forsome x b))))
;;                                  (pflist (list (all-elim-proof x (f-iff a b))
;;                                                (e-intro-proof x b))))
;;    (eval-tautconseq-proof-proves (flist (list (f-implies (forall x (f-iff a b)) (f-iff a b))
;;                                               (f-implies a (forsome x a))))
;;                                  (exp (f-implies b
;;                                                  (f-implies (forall x (f-iff a b))
;;                                                             (forsome x a))))
;;                                  (pflist (list (all-elim-proof x (f-iff a b))
;;                                                (e-intro-proof x a))))
;;    (eval-tautconseq-proof-proves
;;     (flist (list (f-implies (forsome x a) (f-implies (forall x (f-iff a b)) (forsome x b)))
;;                  (f-implies (forsome x b) (f-implies (forall x (f-iff a b)) (forsome x a)))))
;;     (exp (f-implies (forall x (f-iff a b)) (f-iff (forsome x a) (forsome x b))))
;;     (pflist
;;      (list (forsome-intro-proof x
;;                                 a
;;                                 (f-implies (forall x (f-iff a b)) (forsome x b))
;;                                 (tautconseq-proof (list (f-implies (forall x (f-iff a b))
;;                                                                    (f-iff a b))
;;                                                         (f-implies b (forsome x b)))
;;                                                   (f-implies a
;;                                                              (f-implies (forall x
;;                                                                                 (f-iff a b))
;;                                                                         (forsome x b)))
;;                                                   (list (all-elim-proof x (f-iff a b))
;;                                                         (e-intro-proof x b))))
;;            (forsome-intro-proof x
;;                                 b
;;                                 (f-implies (forall x (f-iff a b)) (forsome x a))
;;                                 (tautconseq-proof (list (f-implies (forall x (f-iff a b))
;;                                                                    (f-iff a b))
;;                                                         (f-implies a (forsome x a)))
;;                                                   (f-implies b
;;                                                              (f-implies (forall x
;;                                                                                 (f-iff a
;;                                                                                        b))
;;                                                                         (forsome x a)))
;;                                                   (list (all-elim-proof x (f-iff a b))
;;                                                         (e-intro-proof x a))))))))))
;; (toggle g0911 forall-over-iff-proof t)
;; (defun elim-free-terms
;;       (x list)
;;       (if (consp list)
;;           (if (member x (collect-free (car list) 0))
;;               (elim-free-terms x (cdr list))
;;               (cons (car list) (elim-free-terms x (cdr list))))
;;           nil))
;; (defthm subset-elim-free-terms (subset (elim-free-terms x list) list))
;; (defthm not-free-elim-free-terms

;;              (not (member x (collect-free (elim-free-terms x list) 1))))
;; (toggle g0912 list-f-and nil)
;; (defthm collect-free-list-f-and

;;              (equal (member x (collect-free (list-f-and list) 0))
;;                     (member x (collect-free list 1))))
;; (defthm formula-f-and

;;              (equal (g-formula (f-and x y) symbols)
;;                     (and (g-formula x symbols)
;;                          (g-formula y symbols))))
;; (defthm covering-f-and

;;              (equal (covering (f-and x y) var 0) (g-append (covering x var 0) (covering y var 0))))
;; (defthm collect-free-f-and

;;              (equal (collect-free (f-and y z) 0) (g-append (collect-free y 0) (collect-free z 0))))
;; (defthm subst-f-and

;;              (equal (g-subst (f-and x y) var term 0)
;;                     (f-and (g-subst x var term 0) (g-subst y var term 0))))
;; (defthm parallel-subst-f-and

;;              (equal (parallel-subst (f-and x y) vars terms 0)
;;                     (f-and (parallel-subst x vars terms 0) (parallel-subst y vars terms 0))))
;; (defthm eval-f-and

;;              (equal (eval (f-and x y) alist)
;;                     (and (eval x alist)
;;                          (eval y alist))))
;; (toggle g0384 f-and t)
;; (defun subset-list-f-and-proof
;;       (list1 list2)
;;       (if (consp list2)
;;           (if (consp (cdr list2))
;;               (tautconseq-proof (list (f-implies (list-f-and list1) (car list2))
;;                                       (f-implies (list-f-and list1) (list-f-and (cdr list2))))
;;                                 (f-implies (list-f-and list1) (list-f-and list2))
;;                                 (list (list-f-and-member-proof (car list2) list1)
;;                                       (subset-list-f-and-proof list1 (cdr list2))))
;;               (list-f-and-member-proof (car list2) list1))
;;           nil))
;; (defthm subset-list-f-and-proof-proves

;;              (implies (and (form-list list1 symbols)
;;                            (form-list list2 symbols)
;;                            (consp list1)
;;                            (consp list2)
;;                            (subset list2 list1))
;;                       (proves (subset-list-f-and-proof list1 list2)
;;                               (f-implies (list-f-and list1) (list-f-and list2))
;;                               given
;;                               defns
;;                               symbols)))
;; (defun list-f-implies
;;       (x y)
;;       (if (and (consp x)
;;                (consp y))
;;           (cons (f-implies (car x) (car y)) (list-f-implies (cdr x) (cdr y)))
;;           nil))
;; (defun implies-implies-proof
;;       (x y u v pf1 pf2)
;;       (tautconseq-proof (list (f-implies u x) (f-implies y v))
;;                         (f-implies (f-implies x y) (f-implies u v))
;;                         (list pf1 pf2)))
;; (defthm implies-implies-proof-proves

;;              (implies (and (proves pf1 (f-implies u x) given defns symbols)
;;                            (proves pf2 (f-implies y v) given defns symbols))
;;                       (proves (implies-implies-proof x y u v pf1 pf2)
;;                               (f-implies (f-implies x y) (f-implies u v))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies u x)))
;;                    (proves-is-formula (pf pf2) (exp (f-implies y v))))
;;               ))
;; (toggle g0876 implies-implies-proof t)
;; (defun list-implies-implies-proof
;;       (x y z pflist)
;;       (if (and (consp x)
;;                (consp y))
;;           (implies-implies-proof (car y)
;;                                  (list-implies (cdr y) z)
;;                                  (car x)
;;                                  (list-implies (cdr x) z)
;;                                  (car pflist)
;;                                  (list-implies-implies-proof (cdr x) (cdr y) z (cdr pflist)))
;;           (tautconseq-proof nil (f-implies z z) nil)))
;; (defthm list-implies-implies-proof-proves

;;              (implies (and (equal (length x) (length y))
;;                            (g-formula z symbols)
;;                            (proves-list pflist (list-f-implies x y) given defns symbols))
;;                       (proves (list-implies-implies-proof x y z pflist)
;;                               (f-implies (list-implies y z) (list-implies x z))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-list-form-list (flist (list-f-implies x y))))))
;; (toggle g0877 list-implies-implies-proof t)
;; (defun list-symmetry-proof1
;;       (x y)
;;       (if (and (consp x)
;;                (consp y))
;;           (cons (symmetry-proof1 (car x) (car y)) (list-symmetry-proof1 (cdr x) (cdr y)))
;;           nil))
;; (defthm list-symmetry-proof1-proves

;;              (implies (and (term-list x symbols)
;;                            (term-list y symbols))
;;                       (proves-list (list-symmetry-proof1 x y)
;;                                    (list-f-implies (list-f-equal x y) (list-f-equal y x))
;;                                    given
;;                                    defns
;;                                    symbols))
;;              ((induct (list-symmetry-proof1 x y))))
;; (toggle g0878 list-symmetry-proof1 t)
;; (defun imp-iff-not-proof
;;       (x y z pf)
;;       (tautconseq-proof (list (f-implies x (f-iff y z)))
;;                         (f-implies x (f-iff (f-not y) (f-not z)))
;;                         (list pf)))
;; (defthm imp-iff-not-proof-proves

;;              (implies (proves pf (f-implies x (f-iff y z)) given defns symbols)
;;                       (proves (imp-iff-not-proof x y z pf)
;;                               (f-implies x (f-iff (f-not y) (f-not z)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (exp (f-implies x (f-iff y z))))
;;                    (eval-tautconseq-proof-proves (flist (list (f-implies x (f-iff y z))))
;;                                                  (exp (f-implies x (f-iff (f-not y) (f-not z))))
;;                                                  (pflist (list pf))))
;;               ))
;; (toggle g0879 imp-iff-not-proof t)
;; (defun imp-iff-or-proof
;;       (x y1 z1 y2 z2 pf1 pf2)
;;       (tautconseq-proof (list (f-implies x (f-iff y1 z1)) (f-implies x (f-iff y2 z2)))
;;                         (f-implies x (f-iff (f-or y1 y2) (f-or z1 z2)))
;;                         (list pf1 pf2)))
;; (defthm imp-iff-or-proof-proves

;;              (implies (and (proves pf1 (f-implies x (f-iff y1 z1)) given defns symbols)
;;                            (proves pf2 (f-implies x (f-iff y2 z2)) given defns symbols))
;;                       (proves (imp-iff-or-proof x y1 z1 y2 z2 pf1 pf2)
;;                               (f-implies x (f-iff (f-or y1 y2) (f-or z1 z2)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies x (f-iff y1 z1))))
;;                    (proves-is-formula (pf pf2) (exp (f-implies x (f-iff y2 z2))))
;;                    (eval-tautconseq-proof-proves (flist (list (f-implies x (f-iff y1 z1))
;;                                                               (f-implies x (f-iff y2 z2))))
;;                                                  (exp (f-implies x
;;                                                                  (f-iff (f-or y1 y2)
;;                                                                         (f-or z1 z2))))
;;                                                  (pflist (list pf1 pf2))))
;;               ))
;; (toggle g0880 imp-iff-or-proof t)
;; (defun make-chain
;;       (a b list)
;;       (if (consp list)
;;           (cons (f-implies a (car list)) (make-chain (car list) b (cdr list)))
;;           (list (f-implies a b))))
;; (defun chain-proof
;;       (a b list pflist)
;;       (if (consp list)
;;           (trans-implies-proof a
;;                                (car list)
;;                                b
;;                                (car pflist)
;;                                (chain-proof (car list) b (cdr list) (cdr pflist)))
;;           (car pflist)))
;; ;; the chain rule below is a frequently used rule of inference.
;; ;; it asserts that "a -> b" is provable if there is a chain of provable
;; ;; implications leading from "a" to "b".
;; (defthm chain-rule

;;              (implies (proves-list pflist (make-chain a b list) given defns symbols)
;;                       (proves (chain-proof a b list pflist) (f-implies a b) given defns symbols)))
;; (toggle g0396 chain-proof t)
;; (defun make-iff-chain
;;       (a b list)
;;       (if (consp list)
;;           (cons (f-iff a (car list)) (make-iff-chain (car list) b (cdr list)))
;;           (list (f-iff a b))))
;; (defun chain-iff-proof
;;       (a b list pflist)
;;       (if (consp list)
;;           (trans-f-iff-proof a
;;                              (car list)
;;                              b
;;                              (car pflist)
;;                              (chain-iff-proof (car list) b (cdr list) (cdr pflist)))
;;           (car pflist)))
;; ;; the chain rule form "<->".
;; (defthm chain-iff-proof-proves

;;              (implies (proves-list pflist (make-iff-chain a b list) given defns symbols)
;;                       (proves (chain-iff-proof a b list pflist) (f-iff a b) given defns symbols)))
;; (toggle g0386 chain-iff-proof t)
;; (defun imp-iff-forsome-proof
;;       (x y z var pf)
;;       (chain-proof x
;;                    (f-iff (forsome var y) (forsome var z))
;;                    (list (forall var (f-iff y z)))
;;                    (list (forall-intro-proof x (f-iff y z) var pf)
;;                          (forall-over-iff-proof var y z))))
;; (defthm imp-iff-forsome-proof-proves

;;              (implies (and (g-variable var)
;;                            (not (member var (collect-free x 0)))
;;                            (proves pf (f-implies x (f-iff y z)) given defns symbols))
;;                       (proves (imp-iff-forsome-proof x y z var pf)
;;                               (f-implies x (f-iff (forsome var y) (forsome var z)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (exp (f-implies x (f-iff y z)))))))
;; (toggle g0881 imp-iff-forsome-proof t)
;; (defun dist-f-implies-symmetry-proof
;;       (x list1 list2 pflist)
;;       (if (and (consp list1)
;;                (consp list2))
;;           (cons (chain-proof x
;;                              (f-equal (car list2) (car list1))
;;                              (list (f-equal (car list1) (car list2)))
;;                              (list (car pflist) (symmetry-proof1 (car list1) (car list2))))
;;                 (dist-f-implies-symmetry-proof x (cdr list1) (cdr list2) (cdr pflist)))
;;           nil))
;; (prove-lemma
;;  dist-f-implies-symmetry-proof-proves

;;  (implies (proves-list pflist (dist-f-implies x (list-f-equal list1 list2)) given defns symbols)
;;           (proves-list (dist-f-implies-symmetry-proof x list1 list2 pflist)
;;                        (dist-f-implies x (list-f-equal list2 list1))
;;                        given
;;                        defns
;;                        symbols))
;;  ((use (proves-list-form-list (flist (dist-f-implies x (list-f-equal list1 list2)))))
;;   (disable proves-list-form-list)))
;; (toggle g0882 dist-f-implies-symmetry-proof t)
;; (defun imp-iff-implies-proof
;;       (x y z pf1 pf2)
;;       (tautconseq-proof (list (f-implies x (f-implies y z)) (f-implies x (f-implies z y)))
;;                         (f-implies x (f-iff y z))
;;                         (list pf1 pf2)))
;; (defthm imp-iff-implies-proof-proves

;;              (implies (and (proves pf1 (f-implies x (f-implies y z)) given defns symbols)
;;                            (proves pf2 (f-implies x (f-implies z y)) given defns symbols))
;;                       (proves (imp-iff-implies-proof x y z pf1 pf2)
;;                               (f-implies x (f-iff y z))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies x (f-implies y z))))
;;                    (proves-is-formula (pf pf2) (exp (f-implies x (f-implies z y)))))
;;               ))
;; (toggle g0883 imp-iff-implies-proof t)
;; ;; term-equal-proof is the proof-constructor for the equality theorem
;; ;; for terms.
;; (defn
;;  term-equal-proof
;;  (terma termb list flg)
;;  (if (zerop flg)
;;      (if (equal terma termb)
;;          (add-hyp-proof (list-f-and list) (f-equal terma terma) (ident-axiom-proof terma))
;;          (if (member (f-equal terma termb) list)
;;              (list-f-and-member-proof (f-equal terma termb) list)
;;              (if (member (f-equal termb terma) list)
;;                  (chain-proof (list-f-and list)
;;                               (f-equal terma termb)
;;                               (list (f-equal termb terma))
;;                               (list (list-f-and-member-proof (f-equal termb terma) list)
;;                                     (symmetry-proof1 termb terma)))
;;                  (if (and (consp terma)
;;                           (consp termb))
;;                      (elim-args-proof (list-f-and list)
;;                                       (list-f-equal (cdr terma) (cdr termb))
;;                                       (f-equal terma termb)
;;                                       (term-equal-proof (cdr terma) (cdr termb) list 1)
;;                                       (add-hyp-proof (list-f-and list)
;;                                                      (list-implies (list-f-equal (cdr terma)
;;                                                                                  (cdr termb))
;;                                                                    (f-equal terma termb))
;;                                                      (equal-axiom1-proof (car terma)
;;                                                                          (cdr terma)
;;                                                                          (cdr termb))))
;;                      nil))))
;;      (if (and (consp terma)
;;               (consp termb))
;;          (cons (term-equal-proof (car terma) (car termb) list 0)
;;                (term-equal-proof (cdr terma) (cdr termb) list 1))
;;          nil)))
;; ;; term-equal checks if terma and termb are identical modulo the list of
;; ;; equalities in list.
;; (defun term-equal
;;       (terma termb list flg)
;;       (if (zerop flg)
;;           (if (equal terma termb)
;;               t
;;               (if (member (f-equal terma termb) list)
;;                   t
;;                   (if (member (f-equal termb terma) list)
;;                       t
;;                       (if (and (consp terma)
;;                                (consp termb))
;;                           (and (equal (car terma) (car termb))
;;                                (term-equal (cdr terma) (cdr termb) list 1))
;;                           nil))))
;;           (if (and (consp terma)
;;                    (consp termb))
;;               (and (term-equal (car terma) (car termb) list 0)
;;                    (term-equal (cdr terma) (cdr termb) list 1))
;;               (equal terma termb))))
;; ;; the equality theorem for terms:  if "a" and "b" are identical
;; ;; modulo the equalities "x1 = y1",..., "xn = yn", etc., then
;; ;; it is provable that, "((x1=y1) ^ ... ^ (xn=yn))->(a=b)".
;; (defthm term-equal-proof-proves

;;              (implies (and (flg-termp terma flg symbols)
;;                            (flg-termp termb flg symbols)
;;                            (consp list)
;;                            (form-list list symbols)
;;                            (term-equal terma termb list flg))
;;                       (flg-proves (term-equal-proof terma termb list flg)
;;                                   (flg-f-implies-equal (list-f-and list) terma termb flg)
;;                                   given
;;                                   defns
;;                                   symbols
;;                                   flg))
;;              ((induct (term-equal terma termb list flg))))
;; (toggle g0364 term-equal-proof t)
;; (defthm term-equal-proof-proves1

;;              (implies (and (g-termp terma 0 symbols)
;;                            (g-termp termb 0 symbols)
;;                            (consp list)
;;                            (form-list list symbols)
;;                            (term-equal terma termb list 0))
;;                       (proves (term-equal-proof terma termb list 0)
;;                               (f-implies (list-f-and list) (f-equal terma termb))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (term-equal-proof-proves (flg 0)))))
;; (defthm term-equal-proof-proves2

;;              (implies (and (term-list terma symbols)
;;                            (term-list termb symbols)
;;                            (consp list)
;;                            (form-list list symbols)
;;                            (term-equal terma termb list 1)
;;                            (equal concl
;;                                   (dist-f-implies (list-f-and list) (list-f-equal terma termb))))
;;                       (proves-list (term-equal-proof terma termb list 1)
;;                                    concl
;;                                    given
;;                                    defns
;;                                    symbols))
;;              ((use (term-equal-proof-proves (flg 1)))))
;; (toggle g0887 term-equal-proof-proves t)
;; ;; form-equal is used in the equality theorem for formulas.
;; ;; it checks that forma and formb are identical modulo the equalities in list.
;; (defun form-equal
;;       (forma formb list)
;;       (if (equal forma formb)
;;           t
;;           (if (and (f-notp forma)
;;                    (f-notp formb))
;;               (form-equal (arg forma) (arg formb) list)
;;               (if (and (f-orp forma)
;;                        (f-orp formb))
;;                   (and (form-equal (arg1 forma) (arg1 formb) list)
;;                        (form-equal (arg2 forma) (arg2 formb) list))
;;                   (if (and (forsomep forma)
;;                            (forsomep formb))
;;                       (and (equal (bind forma) (bind formb))
;;                            (consp (elim-free-terms (bind forma) list))
;;                            (form-equal (g-body forma)
;;                                        (g-body formb)
;;                                        (elim-free-terms (bind forma) list)))
;;                       (if (and (consp forma)
;;                                (consp formb))
;;                           (and (equal (car forma) (car formb))
;;                                (term-equal (cdr forma) (cdr formb) list 1))
;;                           nil))))))
;; ;; form-equal-proof is the corresponding proof-constructor.
;; (defn
;;  form-equal-proof
;;  (forma formb list)
;;  (if
;;   (equal forma formb)
;;   (add-hyp-proof (list-f-and list) (f-iff forma formb) (eqn-form-proof forma formb nil nil))
;;   (if
;;    (and (f-notp forma)
;;         (f-notp formb))
;;    (imp-iff-not-proof (list-f-and list)
;;                       (arg forma)
;;                       (arg formb)
;;                       (form-equal-proof (arg forma) (arg formb) list))
;;    (if
;;     (and (f-orp forma)
;;          (f-orp formb))
;;     (imp-iff-or-proof (list-f-and list)
;;                       (arg1 forma)
;;                       (arg1 formb)
;;                       (arg2 forma)
;;                       (arg2 formb)
;;                       (form-equal-proof (arg1 forma) (arg1 formb) list)
;;                       (form-equal-proof (arg2 forma) (arg2 formb) list))
;;     (if
;;      (and (forsomep forma)
;;           (forsomep formb))
;;      (chain-proof
;;       (list-f-and list)
;;       (f-iff forma formb)
;;       (list (list-f-and (elim-free-terms (bind forma) list)))
;;       (list (subset-list-f-and-proof list (elim-free-terms (bind forma) list))
;;             (imp-iff-forsome-proof (list-f-and (elim-free-terms (bind forma) list))
;;                                    (g-body forma)
;;                                    (g-body formb)
;;                                    (bind forma)
;;                                    (form-equal-proof (g-body forma)
;;                                                      (g-body formb)
;;                                                      (elim-free-terms (bind forma) list)))))
;;      (imp-iff-implies-proof
;;       (list-f-and list)
;;       forma
;;       formb
;;       (elim-args-proof (list-f-and list)
;;                        (list-f-equal (cdr forma) (cdr formb))
;;                        (f-implies forma formb)
;;                        (term-equal-proof (cdr forma) (cdr formb) list 1)
;;                        (add-hyp-proof (list-f-and list)
;;                                       (list-implies (list-f-equal (cdr forma) (cdr formb))
;;                                                     (f-implies forma formb))
;;                                       (equal-axiom2-proof (car forma)
;;                                                           (cdr forma)
;;                                                           (cdr formb))))
;;       (elim-args-proof (list-f-and list)
;;                        (list-f-equal (cdr formb) (cdr forma))
;;                        (f-implies formb forma)
;;                        (dist-f-implies-symmetry-proof (list-f-and list)
;;                                                       (cdr forma)
;;                                                       (cdr formb)
;;                                                       (term-equal-proof (cdr forma)
;;                                                                         (cdr formb)
;;                                                                         list
;;                                                                         1))
;;                        (add-hyp-proof (list-f-and list)
;;                                       (list-implies (list-f-equal (cdr formb) (cdr forma))
;;                                                     (f-implies formb forma))
;;                                       (equal-axiom2-proof (car forma)
;;                                                           (cdr formb)
;;                                                           (cdr forma))))))))))
;; (defthm form-list-elim-free-terms

;;              (implies (form-list list symbols) (form-list (elim-free-terms x list) symbols)))
;; ;; the equality theorem for formulas:  if "a" is identical to "b" modulo
;; ;; the equalities "x1=y1", ..., "xn=yn", etc., then it is provable that
;; ;;  "((x1=y1) ^ ... ^ (xn=yn)) -> (a <-> b)".
;; (defthm form-equal-proof-proves

;;              (implies (and (g-formula forma symbols)
;;                            (g-formula formb symbols)
;;                            (form-equal forma formb list)
;;                            (consp list)
;;                            (form-list list symbols))
;;                       (proves (form-equal-proof forma formb list)
;;                               (f-implies (list-f-and list) (f-iff forma formb))
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (form-equal forma formb list)) (disable list-implies-reduc)))
;; (toggle g0893 form-equal-proof t)
;; (defthm get-list-f-equal

;;              (implies (not (equal exp (getpf exp vars terms)))
;;                       (member (f-equal exp (getpf exp vars terms)) (list-f-equal vars terms))))
;; (defthm getsub-getpf (implies (acl2-numberp x) (equal (getsub x y z) (getpf x y z))))
;; (defthm term-equal-parallel-subst

;;              (implies (g-termp exp flg symbols)
;;                       (term-equal exp
;;                                   (parallel-subst exp vars terms flg)
;;                                   (list-f-equal vars terms)
;;                                   flg)))
;; (defthm delete-delete (equal (del x (del y z)) (del y (del x z))))
;; (defthm del-pairs-del-pairs

;;              (equal (del-pairs x (del y vars) (del-pairs y vars terms))
;;                     (del-pairs y (del x vars) (del-pairs x vars terms))))
;; (defthm not-free-del-pairs-parallel-subst

;;              (implies (not (member x (collect-free exp flg)))
;;                       (equal (parallel-subst exp (del x vars) (del-pairs x vars terms) flg)
;;                              (parallel-subst exp vars terms flg))))
;; (toggle g0894 f-equal nil)
;; (defthm collect-free-f-equal

;;              (equal (member x (collect-free (f-equal y z) 0))
;;                     (or (member x (collect-free y 0))
;;                         (member x (collect-free z 0)))))
;; (toggle g0895 f-equal t)
;; (defthm del-pairs-elim-free

;;              (implies (and (g-variable x)
;;                            (var-list vars (length vars))
;;                            (not (member x (collect-free terms 1))))
;;                       (equal (list-f-equal (del x vars) (del-pairs x vars terms))
;;                              (elim-free-terms x (list-f-equal vars terms))))
;;              ((induct (del-pairs x vars terms))))
;; (defthm var-list-del

;;              (implies (var-list vars (length vars)) (var-list (del x vars) (length (del x vars)))))
;; (defthm append-nil-one (implies (not (equal y nil)) (not (equal (g-append x y) nil))))
;; (defthm append-nil-two

;;              (implies (not (equal (g-append x nil) nil)) (not (equal (g-append x y) nil))))
;; (defthm del-pairs-collect-free

;;              (implies (equal (collect-free terms 1) nil)
;;                       (equal (collect-free (del-pairs x vars terms) 1) nil))
;;              ((induct (del-pairs x vars terms))))
;; (defthm atom-term-equal

;;              (implies (and (not (equal x y))
;;                            (atom list))
;;                       (not (term-equal x y list flg))))
;; (defthm atom-form-equal

;;              (implies (and (not (equal x y))
;;                            (atom list))
;;                       (not (form-equal x y list))))
;; (defthm form-equal-parallel-subst

;;              (implies (and (var-list vars (length vars))
;;                            (g-formula exp symbols)
;;                            (equal (collect-free terms 1) nil))
;;                       (form-equal exp
;;                                   (parallel-subst exp vars terms 0)
;;                                   (list-f-equal vars terms))))
;; (defthm term-equal-subst

;;              (implies (and (g-variable var)
;;                            (g-termp exp flg symbols))
;;                       (term-equal exp (g-subst exp var term flg) (list (f-equal var term)) flg)))
;; (defthm form-equal-subst

;;              (implies (and (g-variable var)
;;                            (g-formula exp symbols)
;;                            (free-for exp var term 0))
;;                       (form-equal exp (g-subst exp var term 0) (list (f-equal var term)))))
;; (defthm symb-equals

;;              (equal (symb sym symbols)
;;                     (or (memb sym symbols)
;;                         (equal sym (p 0 2)))))
;; (defthm index-not-equal

;;              (implies (and (acl2-numberp x)
;;                            (not (equal x 0)))
;;                       (not (equal (p x y) (p 0 2))))
;;              ((enable p)))
;; (defthm fn-p-not-equal (not (equal (fn x y) (p 0 2))) ((enable fn p)))
;; (defthm memb-fn

;;              (equal (memb (fn x y) symbols) (member (fn x y) symbols))
;;              ((enable fn)))
;; (defthm memb-p (equal (memb (p x y) symbols) (member (p x y) symbols)) ((enable p)))
;; ;; the next section contains results that follow from the z2 set axioms.
;; (defthm formula-isin

;;              (equal (g-formula (isin x y) symbols)
;;                     (and (memb (p 1 2) symbols)
;;                          (g-termp x 0 symbols)
;;                          (g-termp y 0 symbols)))
;;              ((disable symb)))
;; (defthm equal-axiom2-isin

;;              (implies (and (g-termp (list x y u v) 1 symbols)
;;                            (member (p 1 2) symbols))
;;                       (proves (equal-axiom2-proof (p 1 2) (list x y) (list u v))
;;                               (f-implies (f-equal x u)
;;                                          (f-implies (f-equal y v)
;;                                                     (f-implies (isin x y) (isin u v))))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable pairequals-reduc)))
;; (defthm collect-free-isin

;;              (equal (collect-free (isin y z) 0) (collect-free (list y z) 1)))
;; (defthm covering-isin (equal (covering (isin x y) z 0) (covering (list x y) z 1)))
;; (defthm subst-isin

;;              (equal (g-subst (isin x y) var term 0)
;;                     (isin (g-subst x var term 0) (g-subst y var term 0))))
;; (defthm parallel-subst-isin

;;              (equal (parallel-subst (isin x y) vars terms 0)
;;                     (isin (parallel-subst x vars terms 0) (parallel-subst y vars terms 0))))
;; (toggle g0381 isin t)
;; (defun mk-bnd (list n) (plus (add1 n) (find-hi-index (collect-free list 1))))
;; (defthm <-mk-bnd (< (find-hi-index (collect-free list 1)) (mk-bnd list n)))
;; (defthm mk-bnd-nequal

;;              (implies (not (equal (fix m) (fix n))) (not (equal (mk-bnd list m) (mk-bnd list n)))))
;; (toggle g0612 mk-bnd t)
;; (defthm mk-bnd-not-free1

;;              (not (member (mk-bnd (list x) n) (collect-free x 0)))
;;              ((use (not-member-varlist (var (mk-bnd (list x) n))
;;                                        (varlist (collect-free (list x) 1))))
;;               (disable not-member-varlist)))
;; (defthm mk-bnd-not-free2

;;              (and (not (member (mk-bnd (list x y) n) (collect-free x 0)))
;;                   (not (member (mk-bnd (list x y) n) (collect-free y 0))))
;;              ((use (not-member-varlist (var (mk-bnd (list x y) n))
;;                                        (varlist (collect-free (list x y) 1))))
;;               (disable not-member-varlist)))
;; (defthm mk-bnd-not-free3

;;              (and (not (member (mk-bnd (list x y z) n) (collect-free x 0)))
;;                   (not (member (mk-bnd (list x y z) n) (collect-free y 0)))
;;                   (not (member (mk-bnd (list x y z) n) (collect-free z 0))))
;;              ((use (not-member-varlist (var (mk-bnd (list x y z) n))
;;                                        (varlist (collect-free (list x y z) 1))))
;;               (disable not-member-varlist)))
;; ;; the next few rules are usable versions of the set-theory axioms.
;; (defun ext-axiom-eq-elim1-proof
;;       (terma termb termc pf)
;;       (tautconseq-proof (list (ext-axiom (mk-bnd (list terma termb) 0) terma termb)
;;                               (f-implies (forall (mk-bnd (list terma termb) 0)
;;                                                  (f-iff (isin (mk-bnd (list terma termb) 0)
;;                                                               terma)
;;                                                         (isin (mk-bnd (list terma termb) 0)
;;                                                               termb)))
;;                                          (f-iff (isin termc terma) (isin termc termb)))
;;                               (isin termc terma))
;;                         (f-implies (f-equal terma termb) (isin termc termb))
;;                         (list (ext-axiom-proof (mk-bnd (list terma termb) 0) terma termb)
;;                               (subst-thm-b-proof (f-iff (isin (mk-bnd (list terma termb) 0)
;;                                                               terma)
;;                                                         (isin (mk-bnd (list terma termb) 0)
;;                                                               termb))
;;                                                  (list (mk-bnd (list terma termb) 0))
;;                                                  (list termc))
;;                               pf)))
;; (defthm nil-intersect-del

;;              (implies (nil-intersect x (del y z)) (nil-intersect (del y x) z)))
;; (defthm not-free-parallel-subst

;;              (implies (nil-intersect vars (collect-free exp flg))
;;                       (equal (parallel-subst exp vars terms flg) exp)))
;; (defthm parallel-subst-f-iff

;;              (equal (parallel-subst (f-iff x y) vars terms 0)
;;                     (f-iff (parallel-subst x vars terms 0) (parallel-subst y vars terms 0)))
;;              ((enable f-iff)))
;; ;; one case of the extensionality axiom: "(c in a)"|- "(a=b)->(c in b)".
;; (prove-lemma
;;  ext-axiom-eq-elim1

;;  (implies (and (g-termp termb 0 symbols)
;;                (member (p 1 2) symbols)
;;                (proves pf (isin termc terma) given defns symbols))
;;           (proves (ext-axiom-eq-elim1-proof terma termb termc pf)
;;                   (f-implies (f-equal terma termb) (isin termc termb))
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable eval-tautconseq-proof-proves)
;;   (use
;;    (proves-is-formula (exp (isin termc terma)))
;;    (eval-tautconseq-proof-proves
;;     (flist (list (ext-axiom (mk-bnd (list terma termb) 0) terma termb)
;;                  (f-implies (forall (mk-bnd (list terma termb) 0)
;;                                     (f-iff (isin (mk-bnd (list terma termb) 0) terma)
;;                                            (isin (mk-bnd (list terma termb) 0) termb)))
;;                             (f-iff (isin termc terma) (isin termc termb)))
;;                  (isin termc terma)))
;;     (exp (f-implies (f-equal terma termb) (isin termc termb)))
;;     (pflist (list (ext-axiom-proof (mk-bnd (list terma termb) 0) terma termb)
;;                   (subst-thm-b-proof (f-iff (isin (mk-bnd (list terma termb) 0) terma)
;;                                             (isin (mk-bnd (list terma termb) 0) termb))
;;                                      (list (mk-bnd (list terma termb) 0))
;;                                      (list termc))
;;                   pf))))))
;; (defun ext-axiom-eq-elim2-proof
;;       (terma termb termc pf)
;;       (tautconseq-proof (list (ext-axiom (mk-bnd (list terma termb) 0) terma termb)
;;                               (f-implies (forall (mk-bnd (list terma termb) 0)
;;                                                  (f-iff (isin (mk-bnd (list terma termb) 0)
;;                                                               terma)
;;                                                         (isin (mk-bnd (list terma termb) 0)
;;                                                               termb)))
;;                                          (f-iff (isin termc terma) (isin termc termb)))
;;                               (isin termc termb))
;;                         (f-implies (f-equal terma termb) (isin termc terma))
;;                         (list (ext-axiom-proof (mk-bnd (list terma termb) 0) terma termb)
;;                               (subst-thm-b-proof (f-iff (isin (mk-bnd (list terma termb) 0)
;;                                                               terma)
;;                                                         (isin (mk-bnd (list terma termb) 0)
;;                                                               termb))
;;                                                  (list (mk-bnd (list terma termb) 0))
;;                                                  (list termc))
;;                               pf)))
;; ;; second case of the extensionality axiom: "(c in b)" |- "(a=b)->(c in a)".
;; (prove-lemma
;;  ext-axiom-eq-elim2

;;  (implies (and (g-termp terma 0 symbols)
;;                (member (p 1 2) symbols)
;;                (proves pf (isin termc termb) given defns symbols))
;;           (proves (ext-axiom-eq-elim2-proof terma termb termc pf)
;;                   (f-implies (f-equal terma termb) (isin termc terma))
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable eval-tautconseq-proof-proves)
;;   (use
;;    (proves-is-formula (exp (isin termc termb)))
;;    (eval-tautconseq-proof-proves
;;     (flist (list (ext-axiom (mk-bnd (list terma termb) 0) terma termb)
;;                  (f-implies (forall (mk-bnd (list terma termb) 0)
;;                                     (f-iff (isin (mk-bnd (list terma termb) 0) terma)
;;                                            (isin (mk-bnd (list terma termb) 0) termb)))
;;                             (f-iff (isin termc terma) (isin termc termb)))
;;                  (isin termc termb)))
;;     (exp (f-implies (f-equal terma termb) (isin termc terma)))
;;     (pflist (list (ext-axiom-proof (mk-bnd (list terma termb) 0) terma termb)
;;                   (subst-thm-b-proof (f-iff (isin (mk-bnd (list terma termb) 0) terma)
;;                                             (isin (mk-bnd (list terma termb) 0) termb))
;;                                      (list (mk-bnd (list terma termb) 0))
;;                                      (list termc))
;;                   pf))))))
;; (toggle g0631 ext-axiom-eq-elim1-proof t)
;; (toggle g0632 ext-axiom-eq-elim2-proof t)
;; (toggle g0633 f-iff-mp-proof2 t)
;; (defun ext-axiom-eq-intro-proof
;;       (x terma termb pf)
;;       (f-iff-mp-proof2 (f-equal terma termb)
;;                        (forall x (f-iff (isin x terma) (isin x termb)))
;;                        (ext-axiom-proof x terma termb)
;;                        (generalise-proof x (f-iff (isin x terma) (isin x termb)) pf)))
;; ;; third case of ext. axiom:  "(x in a) <-> (x in b)" |- "(a=b)".
;; (defthm ext-axiom-eql-intro

;;              (implies (and (g-variable x)
;;                            (not (member x (collect-free (list terma termb) 1)))
;;                            (proves pf (f-iff (isin x terma) (isin x termb)) given defns symbols))
;;                       (proves (ext-axiom-eq-intro-proof x terma termb pf)
;;                               (f-equal terma termb)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (exp (f-iff (isin x terma) (isin x termb)))))))
;; (toggle g0634 ext-axiom-eq-intro-proof t)
;; (defthm symb-reduc (implies (member sym symbols) (symb sym symbols)))
;; (toggle g0635 symb t)
;; (defthm equal-axiom1-z-pair

;;              (implies (and (g-termp (list x y u v) 1 symbols)
;;                            (member (fn 1 2) symbols))
;;                       (proves (equal-axiom1-proof (fn 1 2) (list x y) (list u v))
;;                               (f-implies (f-equal x u)
;;                                          (f-implies (f-equal y v)
;;                                                     (f-equal (z-pair x y) (z-pair u v))))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable pairequals-reduc)))
;; (defthm equal-axiom1-z-union

;;              (implies (and (g-termp (list x y u v) 1 symbols)
;;                            (member (fn 2 2) symbols))
;;                       (proves (equal-axiom1-proof (fn 2 2) (list x y) (list u v))
;;                               (f-implies (f-equal x u)
;;                                          (f-implies (f-equal y v)
;;                                                     (f-equal (z-union x y) (z-union u v))))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable pairequals-reduc)))
;; (defthm collect-free-z-pair

;;              (equal (collect-free (z-pair y z) 0) (collect-free (list y z) 1)))
;; (defthm covering-z-pair

;;              (equal (covering (z-pair x y) var 0) (covering (list x y) var 1)))
;; (defthm subst-z-pair

;;              (equal (g-subst (z-pair x y) var term 0)
;;                     (z-pair (g-subst x var term 0) (g-subst y var term 0))))
;; (defthm parallel-subst-z-pair

;;              (equal (parallel-subst (z-pair x y) vars terms 0)
;;                     (z-pair (parallel-subst x vars terms 0) (parallel-subst y vars terms 0))))
;; (defthm termp-z-pair

;;              (equal (g-termp (z-pair x y) 0 symbols)
;;                     (and (member (fn 1 2) symbols)
;;                          (g-termp x 0 symbols)
;;                          (g-termp y 0 symbols))))
;; (defthm term-equal-z-pair

;;              (implies (and (term-equal x u list 0)
;;                            (term-equal y v list 0))
;;                       (term-equal (z-pair x y) (z-pair u v) list 0)))
;; (defthm term-equal-z-union

;;              (implies (and (term-equal x u list 0)
;;                            (term-equal y v list 0))
;;                       (term-equal (z-union x y) (z-union u v) list 0)))
;; (toggle g0387 z-pair t)
;; (defthm termp-z-union

;;              (equal (g-termp (z-union x y) 0 symbols)
;;                     (and (member (fn 2 2) symbols)
;;                          (g-termp x 0 symbols)
;;                          (g-termp y 0 symbols))))
;; (defthm collect-free-z-union

;;              (equal (collect-free (z-union y z) 0) (collect-free (list y z) 1)))
;; (defthm covering-z-union

;;              (equal (covering (z-union x y) var 0) (covering (list x y) var 1)))
;; (defthm subst-z-union

;;              (equal (g-subst (z-union x y) var term 0)
;;                     (z-union (g-subst x var term 0) (g-subst y var term 0))))
;; (defthm parallel-subst-z-union

;;              (equal (parallel-subst (z-union x y) vars terms 0)
;;                     (z-union (parallel-subst x vars terms 0) (parallel-subst y vars terms 0))))
;; (toggle g0388 z-union t)
;; (defun z-pair-elim-proof
;;       (x terma termb exp pf1 pf2)
;;       (tautconseq-proof (list (f-iff (isin x (z-pair terma termb))
;;                                      (f-or (f-equal x terma) (f-equal x termb)))
;;                               (f-implies (f-equal x terma) exp)
;;                               (f-implies (f-equal x termb) exp))
;;                         (f-implies (isin x (z-pair terma termb)) exp)
;;                         (list (pair-axiom-proof x terma termb) pf1 pf2)))
;; ;; pair-elimination:  if |-"(x = a)->exp" and |-"(x=b)->exp",
;; ;; then |-"(x in {a,b}) -> exp".
;; (prove-lemma
;;  z-pair-elim

;;  (implies (and (subset (list (p 1 2) (fn 1 2)) symbols)
;;                (proves pf1 (f-implies (f-equal x terma) exp) given defns symbols)
;;                (proves pf2 (f-implies (f-equal x termb) exp) given defns symbols))
;;           (proves (z-pair-elim-proof x terma termb exp pf1 pf2)
;;                   (f-implies (isin x (z-pair terma termb)) exp)
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable eval-tautconseq-proof-proves)
;;   (use (proves-is-formula (pf pf1) (exp (f-implies (f-equal x terma) exp)))
;;        (proves-is-formula (pf pf2) (exp (f-implies (f-equal x termb) exp)))
;;        (eval-tautconseq-proof-proves (flist (list (f-iff (isin x (z-pair terma termb))
;;                                                          (f-or (f-equal x terma)
;;                                                                (f-equal x termb)))
;;                                                   (f-implies (f-equal x terma) exp)
;;                                                   (f-implies (f-equal x termb) exp)))
;;                                      (exp (f-implies (isin x (z-pair terma termb)) exp))
;;                                      (pflist (list (pair-axiom-proof x terma termb) pf1 pf2))))))
;; (toggle g0643 z-pair-elim-proof t)
;; (defun isin-pair1-proof
;;       (terma termb)
;;       (f-iff-mp-proof2 (isin terma (z-pair terma termb))
;;                        (f-or (f-equal terma terma) (f-equal terma termb))
;;                        (pair-axiom-proof terma terma termb)
;;                        (rt-expan-proof (f-equal terma terma)
;;                                        (f-equal terma termb)
;;                                        (ident-axiom-proof terma))))
;; ;;  |-"(x in {x, y})".
;; (defthm isin-pair1-proof-proves

;;              (implies (g-formula (isin terma (z-pair terma termb)) symbols)
;;                       (proves (isin-pair1-proof terma termb)
;;                               (isin terma (z-pair terma termb))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0391 isin-pair1-proof t)
;; (defun isin-pair2-proof
;;       (terma termb)
;;       (f-iff-mp-proof2 (isin termb (z-pair terma termb))
;;                        (f-or (f-equal termb terma) (f-equal termb termb))
;;                        (pair-axiom-proof termb terma termb)
;;                        (expan-proof (f-equal termb terma)
;;                                     (f-equal termb termb)
;;                                     (ident-axiom-proof termb))))
;; ;;  |- "(y in {x,y})".
;; (defthm isin-pair2-proof-proves

;;              (implies (g-formula (isin termb (z-pair terma termb)) symbols)
;;                       (proves (isin-pair2-proof terma termb)
;;                               (isin termb (z-pair terma termb))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0392 isin-pair2-proof t)
;; (defun z-sing (x) (z-pair x x))
;; (defun isin-sing-proof
;;       (x y)
;;       (chain-iff-proof (isin y (z-sing x))
;;                        (f-equal y x)
;;                        (list (f-or (f-equal y x) (f-equal y x)))
;;                        (list (pair-axiom-proof y x x)
;;                              (tautconseq-proof nil
;;                                                (f-iff (f-or (f-equal y x) (f-equal y x))
;;                                                       (f-equal y x))
;;                                                nil))))
;; ;;  |- "(y in {x}) <-> (y=x)".
;; (defthm isin-sing

;;              (implies (g-formula (f-iff (isin y (z-sing x)) (f-equal y x)) symbols)
;;                       (proves (isin-sing-proof x y)
;;                               (f-iff (isin y (z-sing x)) (f-equal y x))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0913 isin-sing-proof t)
;; (defthm termp-z-sing

;;              (equal (g-termp (z-sing x) 0 symbols)
;;                     (and (member (fn 1 2) symbols)
;;                          (g-termp x 0 symbols))))
;; (defthm collect-free-z-sing

;;              (equal (collect-free (z-sing y) 0) (collect-free (list y y) 1)))
;; (defthm covering-z-sing

;;              (equal (covering (z-sing x) var 0) (covering (list x x) var 1)))
;; (defthm subst-z-sing

;;              (equal (g-subst (z-sing x) var term 0) (z-sing (g-subst x var term 0))))
;; (defthm parallel-subst-z-sing

;;              (equal (parallel-subst (z-sing x) vars terms 0)
;;                     (z-sing (parallel-subst x vars terms 0))))
;; (defthm term-equal-z-sing

;;              (implies (term-equal x y list 0) (term-equal (z-sing x) (z-sing y) list 0)))
;; (toggle g0389 z-sing t)
;; (defun isin-sing1-proof
;;       (x)
;;       (f-iff-mp-proof2 (isin x (z-sing x))
;;                        (f-equal x x)
;;                        (isin-sing-proof x x)
;;                        (ident-axiom-proof x)))
;; ;;  |- "(x in {x})".
;; (defthm isin-sing1-proof-proves

;;              (implies (g-formula (isin term (z-sing term)) symbols)
;;                       (proves (isin-sing1-proof term)
;;                               (isin term (z-sing term))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0393 isin-sing1-proof t)
;; (defun del-forsome-proof
;;       (x exp)
;;       (iff-join-proof (forsome x exp)
;;                       exp
;;                       (forsome-intro-proof x exp exp (prop-axiom-proof exp))
;;                       (subst-thm-a-proof exp (list x) (list x))))
;; ;;  if "x" not free in "exp", then |- "(forsome x exp) <-> exp".
;; (defthm del-forsome-proof-proves

;;              (implies (and (g-variable x)
;;                            (g-formula exp symbols)
;;                            (not (member x (collect-free exp 0))))
;;                       (proves (del-forsome-proof x exp)
;;                               (f-iff (forsome x exp) exp)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0597 del-forsome-proof t)
;; (defun del-forall-proof
;;       (x exp)
;;       (iff-join-proof (forall x exp)
;;                       exp
;;                       (subst-thm-b-proof exp (list x) (list x))
;;                       (forall-intro-proof exp exp x (prop-axiom-proof exp))))
;; ;;  if "x" not free in "exp", then |- "(forall x exp) <-> exp".
;; (defthm del-forall-proof-proves

;;              (implies (and (g-variable x)
;;                            (g-formula exp symbols)
;;                            (not (member x (collect-free exp 0))))
;;                       (proves (del-forall-proof x exp)
;;                               (f-iff (forall x exp) exp)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0599 del-forall-proof t)
;; (defun sing-sing-equal-proof
;;       (x y)
;;       (chain-proof (f-equal (z-sing x) (z-sing y))
;;                    (f-equal x y)
;;                    (list (isin x (z-sing y)))
;;                    (list (ext-axiom-eq-elim1-proof (z-sing x) (z-sing y) x (isin-sing1-proof x))
;;                          (iff-split-proof1 (isin x (z-sing y))
;;                                            (f-equal x y)
;;                                            (isin-sing-proof y x)))))
;; ;;  |- "({x}={y}) -> (x=y)".
;; (defthm sing-sing-equal-proof-proves

;;              (implies (and (g-termp (list x y) 1 symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (sing-sing-equal-proof x y)
;;                               (f-implies (f-equal (z-sing x) (z-sing y)) (f-equal x y))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0652 sing-sing-equal-proof t)
;; (defun sing-pair-equal-proof1
;;       (x u v)
;;       (chain-proof (f-equal (z-sing x) (z-pair u v))
;;                    (f-equal x u)
;;                    (list (isin u (z-sing x)) (f-equal u x))
;;                    (list (ext-axiom-eq-elim2-proof (z-sing x)
;;                                                    (z-pair u v)
;;                                                    u
;;                                                    (isin-pair1-proof u v))
;;                          (iff-split-proof1 (isin u (z-sing x))
;;                                            (f-equal u x)
;;                                            (isin-sing-proof x u))
;;                          (symmetry-proof1 u x))))
;; ;;  |- "({x}={u,v}) -> (x=u)".
;; (defthm sing-pair-equal-proof1-proves

;;              (implies (and (g-termp (list x u v) 1 symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (sing-pair-equal-proof1 x u v)
;;                               (f-implies (f-equal (z-sing x) (z-pair u v)) (f-equal x u))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0653 sing-pair-equal-proof1 t)
;; (defun sing-pair-equal-proof2
;;       (x u v)
;;       (chain-proof (f-equal (z-sing x) (z-pair u v))
;;                    (f-equal x v)
;;                    (list (isin v (z-sing x)) (f-equal v x))
;;                    (list (ext-axiom-eq-elim2-proof (z-sing x)
;;                                                    (z-pair u v)
;;                                                    v
;;                                                    (isin-pair2-proof u v))
;;                          (iff-split-proof1 (isin v (z-sing x))
;;                                            (f-equal v x)
;;                                            (isin-sing-proof x v))
;;                          (symmetry-proof1 v x))))
;; ;;  |-"({x}={u,v}) -> (x=v)".
;; (defthm sing-pair-equal-proof-proves

;;              (implies (and (g-termp (list x u v) 1 symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (sing-pair-equal-proof2 x u v)
;;                               (f-implies (f-equal (z-sing x) (z-pair u v)) (f-equal x v))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0654 sing-pair-equal-proof2 t)
;; (defun z-opair (x y) (z-pair (z-sing x) (z-pair x y)))
;; (defthm termp-z-opair

;;              (equal (g-termp (z-opair x y) 0 symbols)
;;                     (and (member (fn 1 2) symbols)
;;                          (g-termp x 0 symbols)
;;                          (g-termp y 0 symbols))))
;; (defthm term-equal-z-opair

;;              (implies (and (member (f-equal x u) list)
;;                            (member (f-equal y v) list))
;;                       (term-equal (z-opair x y) (z-opair u v) list 0)))
;; (defun z-car-unique-proof
;;       (x y u v)
;;       (chain-proof (f-equal (z-opair x y) (z-opair u v))
;;                    (f-equal x u)
;;                    (list (isin (z-sing x) (z-opair u v)))
;;                    (list (ext-axiom-eq-elim1-proof (z-opair x y)
;;                                                    (z-opair u v)
;;                                                    (z-sing x)
;;                                                    (isin-pair1-proof (z-sing x) (z-pair x y)))
;;                          (z-pair-elim-proof (z-sing x)
;;                                             (z-sing u)
;;                                             (z-pair u v)
;;                                             (f-equal x u)
;;                                             (sing-sing-equal-proof x u)
;;                                             (sing-pair-equal-proof1 x u v)))))
;; ;;  |- "(<x y>=<u v>)-> (x=u)".
;; (defthm z-car-unique-proof-proves

;;              (implies (and (g-termp (list x y u v) 1 symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (z-car-unique-proof x y u v)
;;                               (f-implies (f-equal (z-opair x y) (z-opair u v)) (f-equal x u))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0656 z-car-unique-proof t)
;; (defn
;;  z-cdr-unique-step-proof
;;  (x y u v)
;;  (chain-proof
;;   (f-equal (z-opair x y) (z-opair u v))
;;   (f-or (f-equal y u) (f-equal y v))
;;   (list (isin (z-pair x y) (z-opair u v)))
;;   (list
;;    (ext-axiom-eq-elim1-proof (z-opair x y)
;;                              (z-opair u v)
;;                              (z-pair x y)
;;                              (isin-pair2-proof (z-sing x) (z-pair x y)))
;;    (z-pair-elim-proof (z-pair x y)
;;                       (z-sing u)
;;                       (z-pair u v)
;;                       (f-or (f-equal y u) (f-equal y v))
;;                       (tautconseq-proof (list (f-implies (f-equal (z-pair x y) (z-sing u))
;;                                                          (f-equal y u)))
;;                                         (f-implies (f-equal (z-pair x y) (z-sing u))
;;                                                    (f-or (f-equal y u) (f-equal y v)))
;;                                         (list (chain-proof (f-equal (z-pair x y) (z-sing u))
;;                                                            (f-equal y u)
;;                                                            (list (f-equal (z-sing u)
;;                                                                           (z-pair x y))
;;                                                                  (f-equal u y))
;;                                                            (list (symmetry-proof1 (z-pair x
;;                                                                                           y)
;;                                                                                   (z-sing u))
;;                                                                  (sing-pair-equal-proof2 u
;;                                                                                          x
;;                                                                                          y)
;;                                                                  (symmetry-proof1 u y)))))
;;                       (chain-proof (f-equal (z-pair x y) (z-pair u v))
;;                                    (f-or (f-equal y u) (f-equal y v))
;;                                    (list (isin y (z-pair u v)))
;;                                    (list (ext-axiom-eq-elim1-proof (z-pair x y)
;;                                                                    (z-pair u v)
;;                                                                    y
;;                                                                    (isin-pair2-proof x y))
;;                                          (iff-split-proof1 (isin y (z-pair u v))
;;                                                            (f-or (f-equal y u) (f-equal y v))
;;                                                            (pair-axiom-proof y u v))))))))

;; ;;  |- "(<x y>=<u v>) -> ((y=u) v (y=v))".
;; (defthm z-cdr-unique-step

;;              (implies (and (g-termp (list x y u v) 1 symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (z-cdr-unique-step-proof x y u v)
;;                               (f-implies (f-equal (z-opair x y) (z-opair u v))
;;                                          (f-or (f-equal y u) (f-equal y v)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0657 z-cdr-unique-step-proof t)
;; (defun trans-equal-proof1
;;       (x y z)
;;       (tautconseq-proof (list (list-implies (list (f-equal y x) (f-equal z z) (f-equal y z))
;;                                             (f-equal x z))
;;                               (f-equal z z))
;;                         (list-implies (list (f-equal y x) (f-equal y z)) (f-equal x z))
;;                         (list (equal-axiom2-proof (p 0 2) (list y z) (list x z))
;;                               (ident-axiom-proof z))))
;; ;;  |-"(y = x) -> ((y = z) -> (x = z))".
;; (defthm trans-equal-proof-proves

;;              (implies (and (g-termp x 0 symbols)
;;                            (g-termp y 0 symbols)
;;                            (g-termp z 0 symbols))
;;                       (proves (trans-equal-proof1 x y z)
;;                               (f-implies (f-equal y x) (f-implies (f-equal y z) (f-equal x z)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0362 trans-equal-proof1 t)
;; (defthm termp-covering

;;              (implies (g-termp exp flg symbols) (equal (covering exp var flg) nil)))
;; (defthm atomp-covering

;;              (implies (g-atomp exp symbols) (equal (covering exp var 0) nil)))
;; (defthm collect-free-z-opair

;;              (equal (collect-free (z-opair y z) 0)
;;                     (collect-free (list (z-sing y) (z-pair y z)) 1)))
;; (toggle g0366 z-opair t)
;; (defun trans-equal-proof2
;;       (x y z)
;;       (tautconseq-proof (list (f-implies (f-equal x y) (f-equal y x))
;;                               (f-implies (f-equal z y) (f-equal y z))
;;                               (f-implies (f-equal y x) (f-implies (f-equal y z) (f-equal x z))))
;;                         (f-implies (f-equal x y) (f-implies (f-equal z y) (f-equal x z)))
;;                         (list (symmetry-proof1 x y)
;;                               (symmetry-proof1 z y)
;;                               (trans-equal-proof1 x y z))))
;; ;;  |- "(x = y) -> ((z = y) -> (x = z))".
;; (defthm trans-equal-proof2-proves

;;              (implies (and (g-termp x 0 symbols)
;;                            (g-termp y 0 symbols)
;;                            (g-termp z 0 symbols))
;;                       (proves (trans-equal-proof2 x y z)
;;                               (f-implies (f-equal x y) (f-implies (f-equal z y) (f-equal x z)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0367 trans-equal-proof2 t)
;; (defun trans-equal-proof3
;;       (x y z)
;;       (tautconseq-proof (list (f-implies (f-equal y z) (f-implies (f-equal x y) (f-equal x z))))
;;                         (f-implies (f-equal x y) (f-implies (f-equal y z) (f-equal x z)))
;;                         (list (detach-proof (f-equal x x)
;;                                             (f-implies (f-equal y z)
;;                                                        (f-implies (f-equal x y) (f-equal x z)))
;;                                             (ident-axiom-proof x)
;;                                             (equal-axiom2-proof (p 0 2) (list x y) (list x z))))))
;; ;;  |- "(x = y) -> ((y = z) -> (x = z))".
;; (defthm trans-equal-proof3-proves

;;              (implies (and (g-termp x 0 symbols)
;;                            (g-termp y 0 symbols)
;;                            (g-termp z 0 symbols))
;;                       (proves (trans-equal-proof3 x y z)
;;                               (f-implies (f-equal x y) (f-implies (f-equal y z) (f-equal x z)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0736 trans-equal-proof3 t)
;; (defun z-cdr-unique-proof
;;       (x u y v)
;;       (tautconseq-proof (list (f-implies (f-equal (z-opair x u) (z-opair y v))
;;                                          (f-or (f-equal u y) (f-equal u v)))
;;                               (f-implies (f-equal (z-opair x u) (z-opair y v))
;;                                          (f-or (f-equal v x) (f-equal v u)))
;;                               (f-implies (f-equal (z-opair x u) (z-opair y v)) (f-equal x y))
;;                               (f-implies (f-equal v u) (f-equal u v))
;;                               (f-implies (f-equal u y) (f-implies (f-equal x y) (f-equal u x)))
;;                               (f-implies (f-equal u x) (f-implies (f-equal v x) (f-equal u v))))
;;                         (f-implies (f-equal (z-opair x u) (z-opair y v)) (f-equal u v))
;;                         (list (z-cdr-unique-step-proof x u y v)
;;                               (chain-proof (f-equal (z-opair x u) (z-opair y v))
;;                                            (f-or (f-equal v x) (f-equal v u))
;;                                            (list (f-equal (z-opair y v) (z-opair x u)))
;;                                            (list (symmetry-proof1 (z-opair x u) (z-opair y v))
;;                                                  (z-cdr-unique-step-proof y v x u)))
;;                               (z-car-unique-proof x u y v)
;;                               (symmetry-proof1 v u)
;;                               (trans-equal-proof2 u y x)
;;                               (trans-equal-proof2 u x v))))
;; ;;  |- "(<x u>=<u v>) -> (u = v)".
;; (prove-lemma
;;  z-cdr-unique-proof-proves

;;  (implies (and (g-termp x 0 symbols)
;;                (g-termp u 0 symbols)
;;                (g-termp y 0 symbols)
;;                (g-termp v 0 symbols)
;;                (member (p 1 2) symbols)
;;                (member (fn 1 2) symbols))
;;           (proves (z-cdr-unique-proof x u y v)
;;                   (f-implies (f-equal (z-opair x u) (z-opair y v)) (f-equal u v))
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable eval-tautconseq-proof-proves)
;;   (use
;;    (eval-tautconseq-proof-proves
;;     (flist (list (f-implies (f-equal (z-opair x u) (z-opair y v))
;;                             (f-or (f-equal u y) (f-equal u v)))
;;                  (f-implies (f-equal (z-opair x u) (z-opair y v))
;;                             (f-or (f-equal v x) (f-equal v u)))
;;                  (f-implies (f-equal (z-opair x u) (z-opair y v)) (f-equal x y))
;;                  (f-implies (f-equal v u) (f-equal u v))
;;                  (f-implies (f-equal u y) (f-implies (f-equal x y) (f-equal u x)))
;;                  (f-implies (f-equal u x) (f-implies (f-equal v x) (f-equal u v)))))
;;     (exp (f-implies (f-equal (z-opair x u) (z-opair y v)) (f-equal u v)))
;;     (pflist (list (z-cdr-unique-step-proof x u y v)
;;                   (chain-proof (f-equal (z-opair x u) (z-opair y v))
;;                                (f-or (f-equal v x) (f-equal v u))
;;                                (list (f-equal (z-opair y v) (z-opair x u)))
;;                                (list (symmetry-proof1 (z-opair x u) (z-opair y v))
;;                                      (z-cdr-unique-step-proof y v x u)))
;;                   (z-car-unique-proof x u y v)
;;                   (symmetry-proof1 v u)
;;                   (trans-equal-proof2 u y x)
;;                   (trans-equal-proof2 u x v)))))))
;; (toggle g0369 z-cdr-unique-proof t)
;; ;; the next definition introduces the "if" connective which
;; ;; plays an important role in the proofs to follow.
;; ;; def.: "(if a b c)" =  "((a ^ b) v ((not a) ^ c))".
;; (defun f-if (x y z) (f-or (f-and x y) (f-and (f-not x) z)))
;; (defun f-if-intro-step-proof1
;;       (x y z)
;;       (tautconseq-proof nil (f-implies x (f-implies y (f-if x y z))) nil))
;; ;;  |- "(a -> (b -> (if a b c)))".
;; (defthm f-if-intro-step1

;;              (implies (and (g-formula x symbols)
;;                            (g-formula y symbols)
;;                            (g-formula z symbols))
;;                       (proves (f-if-intro-step-proof1 x y z)
;;                               (f-implies x (f-implies y (f-if x y z)))
;;                               given
;;                               defns
;;                               symbols)))
;; (defun f-if-intro-step-proof2
;;       (x y z)
;;       (tautconseq-proof nil (f-implies (f-not x) (f-implies z (f-if x y z))) nil))
;; ;;  |- "((not a) -> (c -> (if a b c)))".
;; (defthm f-if-intro-step2

;;              (implies (and (g-formula x symbols)
;;                            (g-formula y symbols)
;;                            (g-formula z symbols))
;;                       (proves (f-if-intro-step-proof2 x y z)
;;                               (f-implies (f-not x) (f-implies z (f-if x y z)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0663 f-if-intro-step-proof1 t)
;; (toggle g0664 f-if-intro-step-proof2 t)
;; (defun f-if-intro-proof1 (x y z pfx pfy) (tautconseq-proof (list x y) (f-if x y z) (list pfx pfy)))
;; ;;  if |- "a" and |- "b", then |- "(if a b c)".
;; (defthm f-if-intro-proof1-proves

;;              (implies (and (g-formula x symbols)
;;                            (g-formula y symbols)
;;                            (g-formula z symbols)
;;                            (proves pfx x given defns symbols)
;;                            (proves pfy y given defns symbols))
;;                       (proves (f-if-intro-proof1 x y z pfx pfy) (f-if x y z) given defns symbols)))
;; (toggle g0902 f-if-intro-proof1 t)
;; (defun f-if-intro-proof2
;;       (x y z pfnx pfz)
;;       (tautconseq-proof (list (f-not x) z) (f-if x y z) (list pfnx pfz)))
;; ;;  if |- "(not a)" and |- "c", then |- "(if a b c)".
;; (defthm f-if-intro-proof2-proves

;;              (implies (and (g-formula x symbols)
;;                            (g-formula y symbols)
;;                            (g-formula z symbols)
;;                            (proves pfnx (f-not x) given defns symbols)
;;                            (proves pfz z given defns symbols))
;;                       (proves (f-if-intro-proof2 x y z pfnx pfz)
;;                               (f-if x y z)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0903 f-if-intro-proof2 t)
;; (defun f-if-elim-proof1
;;       (x y z pfx)
;;       (tautconseq-proof (list x) (f-implies (f-if x y z) y) (list pfx)))
;; ;;  if |- "a", then |- "((if a b c) -> c)".
;; (defthm f-if-elim-proof1-proves

;;              (implies (and (g-formula x symbols)
;;                            (g-formula y symbols)
;;                            (g-formula z symbols)
;;                            (proves pfx x given defns symbols))
;;                       (proves (f-if-elim-proof1 x y z pfx)
;;                               (f-implies (f-if x y z) y)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0904 f-if-elim-proof1 t)
;; (defun f-if-elim-proof2
;;       (x y z pfnx)
;;       (tautconseq-proof (list (f-not x)) (f-implies (f-if x y z) z) (list pfnx)))
;; ;;  if |-"(not a)", then |-"((if a b c) -> c)".
;; (defthm f-if-elim-proof2-proves

;;              (implies (and (g-formula x symbols)
;;                            (g-formula y symbols)
;;                            (g-formula z symbols)
;;                            (proves pfnx (f-not x) given defns symbols))
;;                       (proves (f-if-elim-proof2 x y z pfnx)
;;                               (f-implies (f-if x y z) z)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0905 f-if-elim-proof2 t)
;; (defthm formula-f-if

;;              (equal (g-formula (f-if x y z) symbols)
;;                     (and (g-formula x symbols)
;;                          (g-formula y symbols)
;;                          (g-formula z symbols))))
;; (defthm collect-free-f-if

;;              (equal (collect-free (f-if x y z) 0)
;;                     (collect-free (f-or (f-and x y) (f-and (f-not x) z)) 0)))
;; (defthm subst-f-if

;;              (equal (g-subst (f-if x y z) var term 0)
;;                     (f-if (g-subst x var term 0) (g-subst y var term 0) (g-subst z var term 0))))
;; (defthm parallel-subst-f-if

;;              (equal (parallel-subst (f-if x y z) vars terms 0)
;;                     (f-if (parallel-subst x vars terms 0)
;;                           (parallel-subst y vars terms 0)
;;                           (parallel-subst z vars terms 0))))
;; (defthm covering-f-if

;;              (equal (covering (f-if x y z) var 0)
;;                     (g-append (g-append (covering x var 0) (covering y var 0))
;;                             (g-append (covering x var 0) (covering z var 0)))))
;; (defthm eval-f-if

;;              (equal (eval (f-if x y z) alist) (if (eval x alist) (eval y alist) (eval z alist))))
;; (toggle g0909 f-if t)
;; (defun case-split-proof
;;       (x y pf1 pf2)
;;       (tautconseq-proof (list (f-implies x y) (f-implies (f-not x) y)) y (list pf1 pf2)))
;; ;; if |- "(a -> b)" and |- "((not a) -> b)", then |- "b".
;; (defthm case-split-proof-proves

;;              (implies (and (proves pf1 (f-implies x y) given defns symbols)
;;                            (proves pf2 (f-implies (f-not x) y) given defns symbols))
;;                       (proves (case-split-proof x y pf1 pf2) y given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies x y))))))
;; (toggle g0601 case-split-proof t)
;; (defthm termp-phi (equal (g-termp (phi) 0 symbols) (member (fn 0 0) symbols)))
;; (defthm collect-free-phi (equal (collect-free (phi) 0) nil))
;; (defthm covering-phi (equal (covering (phi) var 0) nil))
;; (defthm subst-phi (equal (g-subst (phi) var term 0) (phi)))
;; (defthm parallel-subst-phi (equal (parallel-subst (phi) vars terms 0) (phi)))
;; (toggle g0668 phi t)
;; (defthm proves-list-nil (proves-list nil nil given defns symbols))
;; (defun forsome-distrib-or-proof1
;;       (x a b)
;;       (forsome-intro-proof x
;;                            (f-or a b)
;;                            (f-or (forsome x a) (forsome x b))
;;                            (tautconseq-proof (list (f-implies a (forsome x a))
;;                                                    (f-implies b (forsome x b)))
;;                                              (f-implies (f-or a b)
;;                                                         (f-or (forsome x a) (forsome x b)))
;;                                              (list (e-intro-proof x a) (e-intro-proof x b)))))
;; ;;  |- "((forsome x (a v b)) -> ((forsome x a) v (forsome x b)))".
;; (defthm forsome-distrib-or-proof-proves1

;;              (implies (and (g-variable x)
;;                            (g-formula a symbols)
;;                            (g-formula b symbols))
;;                       (proves (forsome-distrib-or-proof1 x a b)
;;                               (f-implies (forsome x (f-or a b))
;;                                          (f-or (forsome x a) (forsome x b)))
;;                               given
;;                               defns
;;                               symbols)))
;; (defun forsome-distrib-step-proof
;;       (x a b)
;;       (forsome-intro-proof x
;;                            b
;;                            (forsome x (f-or a b))
;;                            (chain-proof b
;;                                         (forsome x (f-or a b))
;;                                         (list (f-or a b))
;;                                         (list (tautconseq-proof nil
;;                                                                 (f-implies b (f-or a b))
;;                                                                 nil)
;;                                               (e-intro-proof x (f-or a b))))))
;; ;;  |- "(forsome x b) -> (forsome x (a v b))".
;; (defthm forsome-distrib-step-proof-proves

;;              (implies (and (g-variable x)
;;                            (g-formula a symbols)
;;                            (g-formula b symbols))
;;                       (proves (forsome-distrib-step-proof x a b)
;;                               (f-implies (forsome x b) (forsome x (f-or a b)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0669 forsome-distrib-or-proof1 t)
;; (toggle g0670 forsome-distrib-step-proof t)
;; (defn
;;  forsome-distrib-or-proof2
;;  (x a b)
;;  (tautconseq-proof
;;   (list (f-implies (forsome x a) (forsome x (f-or a b)))
;;         (f-implies (forsome x b) (forsome x (f-or a b))))
;;   (f-implies (f-or (forsome x a) (forsome x b)) (forsome x (f-or a b)))
;;   (list (forsome-intro-proof x
;;                              a
;;                              (forsome x (f-or a b))
;;                              (chain-proof a
;;                                           (forsome x (f-or a b))
;;                                           (list (f-or a b))
;;                                           (list (tautconseq-proof nil
;;                                                                   (f-implies a (f-or a b))
;;                                                                   nil)
;;                                                 (e-intro-proof x (f-or a b)))))
;;         (forsome-distrib-step-proof x a b))))
;; ;;  |- "(((forsome x a) v (forsome x b)) -> (forsome x (a v b)))".
;; (defthm forsome-distrib-or-proof-proves2

;;              (implies (and (g-variable x)
;;                            (g-formula a symbols)
;;                            (g-formula b symbols))
;;                       (proves (forsome-distrib-or-proof2 x a b)
;;                               (f-implies (f-or (forsome x a) (forsome x b))
;;                                          (forsome x (f-or a b)))
;;                               given
;;                               defns
;;                               symbols)))
;; (defn
;;  forall-distrib-or-proof
;;  (x a b)
;;  (tautconseq-proof (list (f-implies (forall x a) (forall x (f-or a b)))
;;                          (f-implies (forall x b) (forall x (f-or a b))))
;;                    (f-implies (f-or (forall x a) (forall x b)) (forall x (f-or a b)))
;;                    (list (forall-intro-proof (forall x a)
;;                                              (f-or a b)
;;                                              x
;;                                              (tautconseq-proof (list (f-implies (forall x a) a))
;;                                                                (f-implies (forall x a)
;;                                                                           (f-or a b))
;;                                                                (list (all-elim-proof x a))))
;;                          (forall-intro-proof (forall x b)
;;                                              (f-or a b)
;;                                              x
;;                                              (tautconseq-proof (list (f-implies (forall x b)
;;                                                                                 b))
;;                                                                (f-implies (forall x b)
;;                                                                           (f-or a b))
;;                                                                (list (all-elim-proof x b)))))))
;; (defthm proves-list-reduc

;;              (equal (proves-list (cons pf1 pf2) (cons exp1 exp2) given defns symbols)
;;                     (and (proves pf1 exp1 given defns symbols)
;;                          (proves-list pf2 exp2 given defns symbols))))
;; ;;  |-"((forall x a) v (forall x b)) -> (forall x (a v b))".
;; (defthm forall-distrib-or

;;              (implies (and (g-variable x)
;;                            (g-formula a symbols)
;;                            (g-formula b symbols))
;;                       (proves (forall-distrib-or-proof x a b)
;;                               (f-implies (f-or (forall x a) (forall x b)) (forall x (f-or a b)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0672 forall-distrib-or-proof t)
;; (toggle g0673 forall nil)
;; (defun forsome-forall-proof
;;       (x a)
;;       (tautconseq-proof (list (f-iff (forsome x (f-not (f-not a))) (forsome x a)))
;;                         (f-iff (f-not (forsome x a)) (forall x (f-not a)))
;;                         (list (eqn-form-proof (forsome x a)
;;                                               (forsome x (f-not (f-not a)))
;;                                               (list (f-iff (f-not (f-not a)) a))
;;                                               (list (tautconseq-proof nil
;;                                                                       (f-iff (f-not (f-not a))
;;                                                                              a)
;;                                                                       nil))))))
;; ;;  |- "(not (forsome x a)) <-> (forall x (not a))".
;; (defthm forsome-forall

;;              (implies (and (g-variable x)
;;                            (g-formula a symbols))
;;                       (proves (forsome-forall-proof x a)
;;                               (f-iff (f-not (forsome x a)) (forall x (f-not a)))
;;                               given
;;                               defns
;;                               symbols)))
;; (defun forall-forsome-proof
;;       (x a)
;;       (tautconseq-proof nil (f-iff (f-not (forall x a)) (forsome x (f-not a))) nil))
;; ;;  |- "(not (forall x a)) <-> (forsome x (not a))".
;; (defthm forall-forsome

;;              (implies (and (g-variable x)
;;                            (g-formula a symbols))
;;                       (proves (forall-forsome-proof x a)
;;                               (f-iff (f-not (forall x a)) (forsome x (f-not a)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0674 forsome-forall-proof t)
;; (toggle g0675 forall-forsome-proof t)
;; (toggle g0593 forsome-distrib-or-proof2 t)
;; (toggle g0676 forall t)
;; (defn
;;  forsome-distrib-and-proof
;;  (x a b)
;;  (chain-proof
;;   (f-and a (forsome x b))
;;   (forsome x (f-and a b))
;;   (list (f-not (f-or (f-not a) (f-not (forsome x b))))
;;         (f-not (f-or (forsome x (f-not a)) (f-not (forsome x b))))
;;         (f-not (f-implies (forsome x b) (forsome x (f-not a))))
;;         (f-not (forall x (f-implies b (f-not a))))
;;         (forsome x (f-not (f-implies b (f-not a)))))
;;   (list
;;    (tautconseq-proof nil
;;                      (f-implies (f-and a (forsome x b))
;;                                 (f-not (f-or (f-not a) (f-not (forsome x b)))))
;;                      nil)
;;    (iff-split-proof1 (f-not (f-or (f-not a) (f-not (forsome x b))))
;;                      (f-not (f-or (forsome x (f-not a)) (f-not (forsome x b))))
;;                      (eqn-form-proof (f-not (f-or (forsome x (f-not a)) (f-not (forsome x b))))
;;                                      (f-not (f-or (f-not a) (f-not (forsome x b))))
;;                                      (list (f-iff (f-not a) (forsome x (f-not a))))
;;                                      (list (iff-commute-proof (forsome x (f-not a))
;;                                                               (f-not a)
;;                                                               (del-forsome-proof x (f-not a))))))
;;    (tautconseq-proof nil
;;                      (f-implies (f-not (f-or (forsome x (f-not a)) (f-not (forsome x b))))
;;                                 (f-not (f-implies (forsome x b) (forsome x (f-not a)))))
;;                      nil)
;;    (contra-pos-proof1 (forall x (f-implies b (f-not a)))
;;                       (f-implies (forsome x b) (forsome x (f-not a)))
;;                       (forall-over-implies-proof x b (f-not a)))
;;    (iff-split-proof1 (f-not (forall x (f-implies b (f-not a))))
;;                      (forsome x (f-not (f-implies b (f-not a))))
;;                      (forall-forsome-proof x (f-implies b (f-not a))))
;;    (iff-split-proof1
;;     (forsome x (f-not (f-implies b (f-not a))))
;;     (forsome x (f-and a b))
;;     (eqn-form-proof (forsome x (f-and a b))
;;                     (forsome x (f-not (f-implies b (f-not a))))
;;                     (list (f-iff (f-not (f-implies b (f-not a))) (f-and a b)))
;;                     (list (tautconseq-proof nil
;;                                             (f-iff (f-not (f-implies b (f-not a)))
;;                                                    (f-and a b))
;;                                             nil)))))))
;; ;;  if "x" not free in "a", then |- "(a ^ (forsome x b)) -> (forsome x (a ^ b))".
;; (prove-lemma
;;  forsome-distrib-and-proof-proves

;;  (implies (and (g-variable x)
;;                (g-formula a symbols)
;;                (g-formula b symbols)
;;                (not (member x (collect-free a 0))))
;;           (proves (forsome-distrib-and-proof x a b)
;;                   (f-implies (f-and a (forsome x b)) (forsome x (f-and a b)))
;;                   given
;;                   defns
;;                   symbols))
;;  ((use (eval-tautconseq-proof-proves (flist nil)
;;                                      (exp (f-implies (f-and a (forsome x b))
;;                                                      (f-not (f-or (f-not a)
;;                                                                   (f-not (forsome x b))))))
;;                                      (pflist nil))
;;        (eval-tautconseq-proof-proves (flist nil)
;;                                      (exp (f-implies (f-not (f-or (forsome x (f-not a))
;;                                                                   (f-not (forsome x b))))
;;                                                      (f-not (f-implies (forsome x b)
;;                                                                        (forsome x (f-not a))))))
;;                                      (pflist nil))
;;        (eval-tautconseq-proof-proves (flist nil)
;;                                      (exp (f-iff (f-not (f-implies b (f-not a))) (f-and a b)))
;;                                      (pflist nil)))
;;   (disable eval-tautconseq-proof-proves)))
;; (toggle g0681 forsome-distrib-and-proof t)
;; (toggle g0683 forsome-distrib-or-proof2 t)
;; (defun forsome-f-if-proof
;;       (var x y z)
;;       (chain-proof (f-if x (forsome var y) (forsome var z))
;;                    (forsome var (f-if x y z))
;;                    (list (f-or (forsome var (f-and x y)) (forsome var (f-and (f-not x) z))))
;;                    (list (tautconseq-proof (list (f-implies (f-and x (forsome var y))
;;                                                             (forsome var (f-and x y)))
;;                                                  (f-implies (f-and (f-not x) (forsome var z))
;;                                                             (forsome var (f-and (f-not x) z))))
;;                                            (f-implies (f-if x (forsome var y) (forsome var z))
;;                                                       (f-or (forsome var (f-and x y))
;;                                                             (forsome var (f-and (f-not x) z))))
;;                                            (list (forsome-distrib-and-proof var x y)
;;                                                  (forsome-distrib-and-proof var (f-not x) z)))
;;                          (forsome-distrib-or-proof2 var (f-and x y) (f-and (f-not x) z)))))
;; ;;  if "v" not free in "a", then
;; ;;  |-"(if a (forsome v b) (forsome v c)) -> (forsome v (if a b c))".
;; ;; this important rule justifies definition by cases using the "if" connective.
;; (defthm forsome-f-if-proof-proves

;;              (implies (and (g-variable var)
;;                            (g-formula x symbols)
;;                            (g-formula y symbols)
;;                            (g-formula z symbols)
;;                            (not (member var (collect-free x 0))))
;;                       (proves (forsome-f-if-proof var x y z)
;;                               (f-implies (f-if x (forsome var y) (forsome var z))
;;                                          (forsome var (f-if x y z)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((enable f-if)))
;; (toggle g0684 forsome-f-if-proof t)
;; (defun unique-f-if-proof
;;       (test left1 left2 right1 right2 exp pf1 pf2)
;;       (tautconseq-proof (list (f-implies (f-and left1 left2) exp)
;;                               (f-implies (f-and right1 right2) exp))
;;                         (f-implies (f-and (f-if test left1 right1) (f-if test left2 right2)) exp)
;;                         (list pf1 pf2)))
;; ;; if |-"(b1 ^ b2) -> p" and |-"(c1 ^ c2) -> p", then
;; ;;  |- "(((if a b1 c1) ^ (if a b2 c2)) -> p)".
;; ;; this lemma justifies the uniqueness part of the admissibility of a
;; ;; definition by cases using the "if" connective.
;; (defthm unique-f-if-proof-proves

;;              (implies (and (g-formula test symbols)
;;                            (proves pf1 (f-implies (f-and left1 left2) exp) given defns symbols)
;;                            (proves pf2 (f-implies (f-and right1 right2) exp) given defns symbols))
;;                       (proves (unique-f-if-proof test left1 left2 right1 right2 exp pf1 pf2)
;;                               (f-implies (f-and (f-if test left1 right1) (f-if test left2 right2))
;;                                          exp)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies (f-and left1 left2) exp)))
;;                    (proves-is-formula (pf pf2) (exp (f-implies (f-and right1 right2) exp))))
;;               ))
;; (toggle g0603 unique-f-if-proof t)
;; (defun forsome-f-if-case-proof
;;       (var x y z pf1 pf2)
;;       (tautconseq-proof (list (f-implies x (forsome var y))
;;                               (f-implies (f-not x) (forsome var z))
;;                               (f-implies (f-if x (forsome var y) (forsome var z))
;;                                          (forsome var (f-if x y z))))
;;                         (forsome var (f-if x y z))
;;                         (list pf1 pf2 (forsome-f-if-proof var x y z))))
;; ;; if |- "(a -> (forsome v b))" and |-"((not a) -> (forsome v c))",
;; ;; then |- "(forsome v (if a b c))".
;; (defthm forsome-f-if-case-proof-proves

;;              (implies (and (g-variable var)
;;                            (g-formula x symbols)
;;                            (g-formula y symbols)
;;                            (g-formula z symbols)
;;                            (not (member var (collect-free x 0)))
;;                            (proves pf1 (f-implies x (forsome var y)) given defns symbols)
;;                            (proves pf2 (f-implies (f-not x) (forsome var z)) given defns symbols))
;;                       (proves (forsome-f-if-case-proof var x y z pf1 pf2)
;;                               (forsome var (f-if x y z))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0687 forsome-f-if-case-proof t)
;; (defun exis-fun-intro-proof
;;       (var term)
;;       (detach-proof (f-equal term term)
;;                     (forsome var (f-equal var term))
;;                     (ident-axiom-proof term)
;;                     (subst-thm-a-proof (f-equal var term) (list var) (list term))))
;; (defthm parallel-subst-f-equal

;;              (equal (parallel-subst (f-equal a b) vars terms 0)
;;                     (f-equal (parallel-subst a vars terms 0) (parallel-subst b vars terms 0)))
;;              ((enable f-equal)))
;; (defthm f-equal-col-free

;;              (equal (collect-free (f-equal x y) 0) (collect-free (list x y) 1))
;;              ((enable f-equal)))
;; (defthm covering-f-equal

;;              (equal (covering (f-equal x y) var 0) (covering (list x y) var 1))
;;              ((enable f-equal)))
;; ;;  |- "(forsome v (v = t))", "v" not free in "t".
;; (defthm exis-fun-intro-proof-proves

;;              (implies (and (g-variable var)
;;                            (g-termp term 0 symbols)
;;                            (not (member var (collect-free term 0))))
;;                       (proves (exis-fun-intro-proof var term)
;;                               (forsome var (f-equal var term))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (atomp-covering (exp (f-equal var term))))))
;; (toggle g0690 exis-fun-intro-proof t)
;; (defthm subset-append-reduc

;;              (equal (subset (g-append x y) z)
;;                     (and (subset x z)
;;                          (subset y z))))
;; (defun z-succ-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 3 1) defns) (f-equal (z-succ 0) (z-union (z-sing 0) 0)))
;;            (subset (list (fn 2 2) (fn 1 2)) (rest-of (fn 3 1) symbols))))
;; (defun unique-fun-intro-proof
;;       (var1 var2 term)
;;       (tautconseq-proof (list (f-implies (f-equal var1 term)
;;                                          (f-implies (f-equal var2 term) (f-equal var1 var2))))
;;                         (f-implies (f-and (f-equal var1 term) (f-equal var2 term))
;;                                    (f-equal var1 var2))
;;                         (list (trans-equal-proof2 var1 term var2))))
;; ;;  |- "((v1 = t) ^ (v2 = t)) -> (v1 = v2)".
;; (defthm unique-fun-intro-proof-proves

;;              (implies (g-termp (list var1 var2 term) 1 symbols)
;;                       (proves (unique-fun-intro-proof var1 var2 term)
;;                               (f-implies (f-and (f-equal var1 term) (f-equal var2 term))
;;                                          (f-equal var1 var2))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0604 unique-fun-intro-proof t)
;; (toggle g0702 rest-of t)
;; (defun z-succ-defn-proof
;;       (term)
;;       (subst-rule-proof (f-equal (z-succ 0) (z-union (z-sing 0) 0))
;;                         0
;;                         term
;;                         (fun-defn-proof (fn 3 1)
;;                                         (list 0)
;;                                         1
;;                                         2
;;                                         (f-equal 1 (z-union (z-sing 0) 0))
;;                                         (exis-fun-intro-proof 1 (z-union (z-sing 0) 0))
;;                                         (unique-fun-intro-proof 1 2 (z-union (z-sing 0) 0)))))
;; ;; the definition of the successor operation: |- "(s t) = ({t} u t)".
;; (defthm z-succ-defn

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (g-termp term 0 symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols))
;;                       (proves (z-succ-defn-proof term)
;;                               (f-equal (z-succ term) (z-union (z-sing term) term))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0407 z-succ-defn-proof t)
;; (toggle g0677 z-succ-hyps t)
;; (defthm termp-z-succ

;;              (equal (g-termp (z-succ x) 0 symbols)
;;                     (and (member (fn 3 1) symbols)
;;                          (g-termp x 0 symbols))))
;; (defthm subst-z-succ

;;              (equal (g-subst (z-succ x) var term 0) (z-succ (g-subst x var term 0))))
;; (defthm parallel-subst-z-succ

;;              (equal (parallel-subst (z-succ x) vars terms 0)
;;                     (z-succ (parallel-subst x vars terms 0))))
;; (defthm covering-z-succ

;;              (equal (covering (z-succ x) var 0) (covering (list x) var 1)))
;; (defthm z-succ-col-free

;;              (equal (collect-free (z-succ x) 0) (collect-free (list x) 1)))
;; (defthm equal-axiom1-z-succ

;;              (implies (and (member (fn 3 1) symbols)
;;                            (g-termp (list x y) 1 symbols))
;;                       (proves (equal-axiom1-proof (fn 3 1) (list x) (list y))
;;                               (f-implies (f-equal x y) (f-equal (z-succ x) (z-succ y)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0408 z-succ t)
;; (defn
;;  ext-axiom-eq-detach-proof
;;  (terma termb termc pf)
;;  (detach-proof (f-equal terma termb)
;;                (f-iff (isin termc terma) (isin termc termb))
;;                pf
;;                (chain-proof (f-equal terma termb)
;;                             (f-iff (isin termc terma) (isin termc termb))
;;                             (list (forall (mk-bnd (list terma termb) 0)
;;                                           (f-iff (isin (mk-bnd (list terma termb) 0) terma)
;;                                                  (isin (mk-bnd (list terma termb) 0) termb))))
;;                             (list (iff-split-proof1 (f-equal terma termb)
;;                                                     (forall (mk-bnd (list terma termb) 0)
;;                                                             (f-iff (isin (mk-bnd (list terma
;;                                                                                        termb)
;;                                                                                  0)
;;                                                                          terma)
;;                                                                    (isin (mk-bnd (list terma
;;                                                                                        termb)
;;                                                                                  0)
;;                                                                          termb)))
;;                                                     (ext-axiom-proof (mk-bnd (list terma termb)
;;                                                                              0)
;;                                                                      terma
;;                                                                      termb))
;;                                   (subst-thm-b-proof (f-iff (isin (mk-bnd (list terma termb) 0)
;;                                                                   terma)
;;                                                             (isin (mk-bnd (list terma termb)
;;                                                                           0)
;;                                                                   termb))
;;                                                      (list (mk-bnd (list terma termb) 0))
;;                                                      (list termc))))))
;; ;;  if |-"(a = b)", then |-"(c in a) <-> (c in b)".
;; (defthm ext-axiom-eq-detach

;;              (implies (and (g-termp (list terma termb termc) 1 symbols)
;;                            (proves pf (f-equal terma termb) given defns symbols)
;;                            (member (p 1 2) symbols))
;;                       (proves (ext-axiom-eq-detach-proof terma termb termc pf)
;;                               (f-iff (isin termc terma) (isin termc termb))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0704 ext-axiom-eq-detach-proof t)
;; (defun in-z-succ-proof
;;       (x y)
;;       (chain-iff-proof (isin y (z-succ x))
;;                        (f-or (f-equal y x) (isin y x))
;;                        (list (isin y (z-union (z-sing x) x))
;;                              (f-or (isin y (z-sing x)) (isin y x)))
;;                        (list (ext-axiom-eq-detach-proof (z-succ x)
;;                                                         (z-union (z-sing x) x)
;;                                                         y
;;                                                         (z-succ-defn-proof x))
;;                              (union-axiom-proof y (z-sing x) x)
;;                              (eqn-form-proof (f-or (f-equal y x) (isin y x))
;;                                              (f-or (isin y (z-sing x)) (isin y x))
;;                                              (list (f-iff (isin y (z-sing x)) (f-equal y x)))
;;                                              (list (isin-sing-proof x y))))))
;; ;;  |-"(y in (s x)) <-> ((y = x) v (y in x))".
;; (defthm in-z-succ-proof-proves

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (g-termp (list x y) 1 symbols))
;;                       (proves (in-z-succ-proof x y)
;;                               (f-iff (isin y (z-succ x)) (f-or (f-equal y x) (isin y x)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0705 in-z-succ-proof t)
;; (defun x-in-z-succ-x-proof
;;       (x)
;;       (f-iff-mp-proof2 (isin x (z-succ x))
;;                        (f-or (f-equal x x) (isin x x))
;;                        (in-z-succ-proof x x)
;;                        (rt-expan-proof (f-equal x x) (isin x x) (ident-axiom-proof x))))
;; ;;  |-"(x in (s x))".
;; (defthm x-in-z-succ-x

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (g-termp x 0 symbols))
;;                       (proves (x-in-z-succ-x-proof x) (isin x (z-succ x)) given defns symbols)))
;; (toggle g0707 x-in-z-succ-x-proof t)
;; (defun z-succ-equal-step-proof
;;       (x y)
;;       (chain-proof (f-equal (z-succ x) (z-succ y))
;;                    (f-or (f-equal x y) (isin x y))
;;                    (list (isin x (z-succ y)))
;;                    (list (ext-axiom-eq-elim1-proof (z-succ x)
;;                                                    (z-succ y)
;;                                                    x
;;                                                    (x-in-z-succ-x-proof x))
;;                          (iff-split-proof1 (isin x (z-succ y))
;;                                            (f-or (f-equal x y) (isin x y))
;;                                            (in-z-succ-proof y x)))))
;; ;;  |- "((s x)=(s y)) -> ((x = y) v (x in y))".
;; (defthm z-succ-equal-step

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (g-termp (list x y) 1 symbols))
;;                       (proves (z-succ-equal-step-proof x y)
;;                               (f-implies (f-equal (z-succ x) (z-succ y))
;;                                          (f-or (f-equal x y) (isin x y)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0708 z-succ-equal-step-proof t)
;; (defun equal-z-succ-proof
;;       (x y)
;;       (tautconseq-proof (list (f-implies (f-equal (z-succ x) (z-succ y))
;;                                          (f-or (f-equal x y) (isin x y)))
;;                               (f-implies (f-equal (z-succ x) (z-succ y))
;;                                          (f-equal (z-succ y) (z-succ x)))
;;                               (f-implies (f-equal (z-succ y) (z-succ x))
;;                                          (f-or (f-equal y x) (isin y x)))
;;                               (f-implies (f-equal y x) (f-equal x y)))
;;                         (f-implies (f-equal (z-succ x) (z-succ y))
;;                                    (f-or (f-equal x y) (f-and (isin x y) (isin y x))))
;;                         (list (z-succ-equal-step-proof x y)
;;                               (symmetry-proof1 (z-succ x) (z-succ y))
;;                               (z-succ-equal-step-proof y x)
;;                               (symmetry-proof1 y x))))
;; ;;  |- "((s x)=(s y)) -> ((x = y) v ((x in y) ^ (y in x)))".
;; (defthm equal-z-succ-proof-proves

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (g-termp x 0 symbols)
;;                            (g-termp y 0 symbols))
;;                       (proves (equal-z-succ-proof x y)
;;                               (f-implies (f-equal (z-succ x) (z-succ y))
;;                                          (f-or (f-equal x y) (f-and (isin x y) (isin y x))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0709 equal-z-succ-proof t)
;; ;; the next series of defns and lemmas deal with the definition of "(i x)".
;; ;; "(i x)" holds of "x" iff "x" is transitive and linearly ordered by "in".
;; ;; "(trans x)" iff "(forall y (forall z ((y in x) -> ((z in y) -> (z in x)))))".
;; ;; "x" is linearly ordered by "in" (i.e., "(trich x)") iff
;; ;; "(forall y (forall z (((y in x) ^ (z in x)) -> ((y = z) v ((y in z) v (z in y))))))"
;; ;; z-trans generates the transitivity assertion.
;; (defun z-trans1 (x u v) (f-implies (f-and (isin u x) (isin v u)) (isin v x)))
;; (defun z-trans (x y z) (forall y (forall z (z-trans1 x y z))))
;; (defun z-trans-instance-proof
;;       (x y z y1 z1)
;;       (subst-thm-b-proof (z-trans1 x y z) (list y z) (list y1 z1)))
;; (defthm z-trans-instance-proof-proves

;;              (implies (and (g-termp (list x y1 z1) 1 symbols)
;;                            (var-set (list y z) 2)
;;                            (nil-intersect (list y z) (collect-free x 0))
;;                            (member (p 1 2) symbols)
;;                            (equal concl (f-implies (z-trans x y z) (z-trans1 x y1 z1))))
;;                       (proves (z-trans-instance-proof x y z y1 z1) concl given defns symbols)))
;; (toggle g0710 z-trans-instance-proof t)
;; (defthm formula-z-trans

;;              (equal (g-formula (z-trans x y z) symbols)
;;                     (and (member (p 1 2) symbols)
;;                          (g-termp (list x y z) 1 symbols))))
;; (defthm collect-free-z-trans

;;              (implies (and (var-list (list y z) 2)
;;                            (nil-intersect (list y z) (collect-free x 0)))
;;                       (equal (member var (collect-free (z-trans x y z) 0))
;;                              (member var (collect-free x 0)))))
;; (toggle g0715 z-trans t)
;; (defun in-z-trans-proof
;;       (x v1 v2 y z)
;;       (tautconseq-proof (list (f-implies (z-trans x v1 v2) (z-trans1 x y z))
;;                               (f-implies (z-trans y v1 v2) (z-trans1 y x z)))
;;                         (f-implies (f-and (f-and (z-trans x v1 v2) (z-trans y v1 v2))
;;                                           (f-and (isin x y) (isin y x)))
;;                                    (f-iff (isin z x) (isin z y)))
;;                         (list (z-trans-instance-proof x v1 v2 y z)
;;                               (z-trans-instance-proof y v1 v2 x z))))
;; ;;  |- "((trans x) ^ (trans y) ^ (x in y) ^ (y in x)) -> ((z in x) <-> (z in y))".
;; (defthm in-z-trans-proof-proves

;;              (implies (and (g-termp (list x y z) 1 symbols)
;;                            (var-set (list v1 v2) 2)
;;                            (nil-intersect (list v1 v2) (collect-free (list x y) 1))
;;                            (member (p 1 2) symbols))
;;                       (proves (in-z-trans-proof x v1 v2 y z)
;;                               (f-implies (f-and (f-and (z-trans x v1 v2) (z-trans y v1 v2))
;;                                                 (f-and (isin x y) (isin y x)))
;;                                          (f-iff (isin z x) (isin z y)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0718 in-z-trans-proof t)
;; (defun z-trans-equal-proof1
;;       (x y v1 v2)
;;       (chain-proof (f-and (f-and (z-trans x v1 v2) (z-trans y v1 v2))
;;                           (f-and (isin x y) (isin y x)))
;;                    (f-equal x y)
;;                    (list (forall v1 (f-iff (isin v1 x) (isin v1 y))))
;;                    (list (forall-intro-proof (f-and (f-and (z-trans x v1 v2) (z-trans y v1 v2))
;;                                                     (f-and (isin x y) (isin y x)))
;;                                              (f-iff (isin v1 x) (isin v1 y))
;;                                              v1
;;                                              (in-z-trans-proof x v1 v2 y v1))
;;                          (iff-split-proof2 (f-equal x y)
;;                                            (forall v1 (f-iff (isin v1 x) (isin v1 y)))
;;                                            (ext-axiom-proof v1 x y)))))
;; ;;  |- "((trans x) ^ (trans y) ^ (x in y) ^ (y in x)) -> (x = y)".
;; (defthm z-trans-equal-proof1-proves

;;              (implies (and (g-termp (list x y) 1 symbols)
;;                            (var-set (list v1 v2) 2)
;;                            (nil-intersect (list v1 v2) (collect-free (list x y) 1))
;;                            (member (p 1 2) symbols))
;;                       (proves (z-trans-equal-proof1 x y v1 v2)
;;                               (f-implies (f-and (f-and (z-trans x v1 v2) (z-trans y v1 v2))
;;                                                 (f-and (isin x y) (isin y x)))
;;                                          (f-equal x y))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0719 z-trans-equal-proof1 t)
;; (defun z-succ-equal-proof
;;       (x y v1 v2)
;;       (tautconseq-proof (list (f-implies (f-equal (z-succ x) (z-succ y))
;;                                          (f-or (f-equal x y) (f-and (isin x y) (isin y x))))
;;                               (f-implies (f-and (f-and (z-trans x v1 v2) (z-trans y v1 v2))
;;                                                 (f-and (isin x y) (isin y x)))
;;                                          (f-equal x y)))
;;                         (f-implies (z-trans x v1 v2)
;;                                    (f-implies (z-trans y v1 v2)
;;                                               (f-implies (f-equal (z-succ x) (z-succ y))
;;                                                          (f-equal x y))))
;;                         (list (equal-z-succ-proof x y) (z-trans-equal-proof1 x y v1 v2))))
;; ;;  |- "((trans x) -> ((trans y) -> (((s x)=(s y)) -> (x = y))))".
;; (defthm z-succ-equal-proof-proves

;;              (implies (and (g-termp (list x y) 1 symbols)
;;                            (var-set (list v1 v2) 2)
;;                            (nil-intersect (list v1 v2) (collect-free (list x y) 1))
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (z-succ-hyps defns symbols))
;;                       (proves (z-succ-equal-proof x y v1 v2)
;;                               (f-implies (z-trans x v1 v2)
;;                                          (f-implies (z-trans y v1 v2)
;;                                                     (f-implies (f-equal (z-succ x) (z-succ y))
;;                                                                (f-equal x y))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0720 z-succ-equal-proof t)
;; (toggle g0721 z-trans-equal-proof1-proves t)
;; (toggle g0722 in-z-trans-proof-proves t)
;; ;; numeral returns the set-theoretic ordinal corresponding to a lisp natural number.
;; ;; the numeral for x will be represented as "|x|".
;; (defun numeral (x) (if (zerop x) (phi) (z-succ (numeral (sub1 x)))))
;; (defthm termp-numeral

;;              (implies (and (member (fn 0 0) symbols)
;;                            (member (fn 3 1) symbols))
;;                       (g-termp (numeral x) 0 symbols))
;;              ((induct (numeral x))))
;; (defthm collect-free-numeral (equal (collect-free (numeral x) 0) nil))
;; (defun chain-or-proof
;;       (a b c d pf1 pf2 pf3)
;;       (tautconseq-proof (list (f-implies a (f-or b c)) (f-implies b d) (f-implies c d))
;;                         (f-implies a d)
;;                         (list pf1 pf2 pf3)))
;; ;;  if |- "(a -> (b v c))",  |- "(b -> d)", and |- "(c -> d)", then |- "(a -> d)".
;; (defthm chain-or-proof-proves

;;              (implies (and (proves pf1 (f-implies a (f-or b c)) given defns symbols)
;;                            (proves pf2 (f-implies b d) given defns symbols)
;;                            (proves pf3 (f-implies c d) given defns symbols))
;;                       (proves (chain-or-proof a b c d pf1 pf2 pf3)
;;                               (f-implies a d)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies a (f-or b c))))
;;                    (proves-is-formula (pf pf2) (exp (f-implies b d))))
;;               ))
;; (toggle g0605 chain-or-proof t)
;; (defn
;;  z-trans-numeral-proof
;;  (x y z)
;;  (if
;;   (zerop x)
;;   (tautconseq-proof (list (f-not (isin y (phi))))
;;                     (f-implies (f-and (isin y (phi)) (isin z y)) (isin z (phi)))
;;                     (list (null-axiom-proof y)))
;;   (chain-proof
;;    (f-and (isin y (numeral x)) (isin z y))
;;    (isin z (numeral x))
;;    (list (f-and (f-or (f-equal y (numeral (sub1 x))) (isin y (numeral (sub1 x)))) (isin z y))
;;          (isin z (numeral (sub1 x))))
;;    (list
;;     (tautconseq-proof (list (f-implies (isin y (z-succ (numeral (sub1 x))))
;;                                        (f-or (f-equal y (numeral (sub1 x)))
;;                                              (isin y (numeral (sub1 x))))))
;;                       (f-implies (f-and (isin y (z-succ (numeral (sub1 x)))) (isin z y))
;;                                  (f-and (f-or (f-equal y (numeral (sub1 x)))
;;                                               (isin y (numeral (sub1 x))))
;;                                         (isin z y)))
;;                       (list (iff-split-proof1 (isin y (z-succ (numeral (sub1 x))))
;;                                               (f-or (f-equal y (numeral (sub1 x)))
;;                                                     (isin y (numeral (sub1 x))))
;;                                               (in-z-succ-proof (numeral (sub1 x)) y))))
;;     (tautconseq-proof (list (f-implies (f-equal y (numeral (sub1 x)))
;;                                        (f-implies (isin z y) (isin z (numeral (sub1 x)))))
;;                             (f-implies (f-and (isin y (numeral (sub1 x))) (isin z y))
;;                                        (isin z (numeral (sub1 x)))))
;;                       (f-implies (f-and (f-or (f-equal y (numeral (sub1 x)))
;;                                               (isin y (numeral (sub1 x))))
;;                                         (isin z y))
;;                                  (isin z (numeral (sub1 x))))
;;                       (list (detach-proof (f-equal z z)
;;                                           (f-implies (f-equal y (numeral (sub1 x)))
;;                                                      (f-implies (isin z y)
;;                                                                 (isin z (numeral (sub1 x)))))
;;                                           (ident-axiom-proof z)
;;                                           (equal-axiom2-proof (p 1 2)
;;                                                               (list z y)
;;                                                               (list z (numeral (sub1 x)))))
;;                             (z-trans-numeral-proof (sub1 x) y z)))
;;     (tautconseq-proof (list (f-implies (f-or (f-equal z (numeral (sub1 x)))
;;                                              (isin z (numeral (sub1 x))))
;;                                        (isin z (z-succ (numeral (sub1 x))))))
;;                       (f-implies (isin z (numeral (sub1 x)))
;;                                  (isin z (z-succ (numeral (sub1 x)))))
;;                       (list (iff-split-proof2 (isin z (z-succ (numeral (sub1 x))))
;;                                               (f-or (f-equal z (numeral (sub1 x)))
;;                                                     (isin z (numeral (sub1 x))))
;;                                               (in-z-succ-proof (numeral (sub1 x)) z))))))))
;; ;;  |- "((y in |x|) ^ (z in y)) -> (z in |x|)".
;; (defthm z-trans-numeral-proof-proves

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (g-termp (list y z) 1 symbols))
;;                       (proves (z-trans-numeral-proof x y z)
;;                               (f-implies (f-and (isin y (numeral x)) (isin z y))
;;                                          (isin z (numeral x)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (numeral x)) (disable pairequals-reduc)))
;; (toggle g0723 z-trans-numeral-proof t)
;; (defthm form-equal-proof-proves1

;;              (implies (and (g-formula forma symbols)
;;                            (g-formula formb symbols)
;;                            (form-equal forma formb list)
;;                            (consp list)
;;                            (form-list list symbols)
;;                            (equal concl (f-implies (list-f-and list) (f-iff forma formb))))
;;                       (proves (form-equal-proof forma formb list) concl given defns symbols))
;;              ((use (form-equal-proof-proves))))
;; (toggle g0724 form-equal-proof-proves t)
;; (defthm termp-del-pairs

;;              (implies (g-termp x 1 symbols) (g-termp (del-pairs y vars x) 1 symbols)))
;; (defthm length-parallel-subst

;;              (equal (length (parallel-subst exp vars terms 1)) (length exp)))
;; (defthm termp-parallel-subst

;;              (implies (and (g-termp term flg symbols)
;;                            (g-termp terms 1 symbols))
;;                       (g-termp (parallel-subst term vars terms flg) flg symbols)))
;; (defthm formula-parallel-subst

;;              (implies (and (g-formula exp symbols)
;;                            (g-termp terms 1 symbols))
;;                       (g-formula (parallel-subst exp vars terms 0) symbols)))
;; (defthm form-equal-parallel-subst-again

;;              (implies (and (var-list vars (length vars))
;;                            (g-formula exp symbols)
;;                            (equal (collect-free terms 1) nil)
;;                            (equal list (list-f-equal vars terms)))
;;                       (form-equal exp (parallel-subst exp vars terms 0) list)))
;; (toggle g0729 form-equal-parallel-subst t)
;; (toggle g0730 form-equal t)
;; (defun in-z-succ-proof1
;;       (x y)
;;       (iff-split-proof1 (isin y (z-succ x)) (f-or (f-equal y x) (isin y x)) (in-z-succ-proof x y)))
;; (defun z-trich1
;;       (x y z)
;;       (f-implies (f-and (isin y x) (isin z x)) (f-or (f-equal y z) (f-or (isin y z) (isin z y)))))
;; (defun ext-case1-proof
;;       (terma termb termc x)
;;       (chain-proof (f-equal terma termb)
;;                    (f-iff (isin termc terma) (isin termc termb))
;;                    (list (forall x (f-iff (isin x terma) (isin x termb))))
;;                    (list (iff-split-proof1 (f-equal terma termb)
;;                                            (forall x (f-iff (isin x terma) (isin x termb)))
;;                                            (ext-axiom-proof x terma termb))
;;                          (subst-thm-b-proof (f-iff (isin x terma) (isin x termb))
;;                                             (list x)
;;                                             (list termc)))))
;; ;;  |- "(a=b) -> ((c in a) <-> (c in b))".
;; (defthm ext-case1

;;              (implies (and (g-variable x)
;;                            (not (member x (collect-free terma 0)))
;;                            (not (member x (collect-free termb 0)))
;;                            (g-formula (f-implies (f-equal terma termb)
;;                                                (f-iff (isin termc terma) (isin termc termb)))
;;                                     symbols))
;;                       (proves (ext-case1-proof terma termb termc x)
;;                               (f-implies (f-equal terma termb)
;;                                          (f-iff (isin termc terma) (isin termc termb)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0914 ext-case1-proof t)
;; (defun ext-case-proof
;;       (terma termb termc)
;;       (ext-case1-proof terma termb termc (mk-bnd (list terma termb) 0)))
;; (defthm ext-axiom-case

;;              (implies (g-formula (f-implies (f-equal terma termb)
;;                                           (f-iff (isin termc terma) (isin termc termb)))
;;                                symbols)
;;                       (proves (ext-case-proof terma termb termc)
;;                               (f-implies (f-equal terma termb)
;;                                          (f-iff (isin termc terma) (isin termc termb)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0915 ext-case-proof t)
;; (defun ext-subcase-proof2
;;       (x y z)
;;       (tautconseq-proof (list (f-implies (f-equal x y) (f-iff (isin z x) (isin z y))))
;;                         (f-implies (f-equal x y) (f-implies (isin z y) (isin z x)))
;;                         (list (ext-case-proof x y z))))
;; ;;  |-"(a=b) -> ((c in a) -> (c in b))".
;; (prove-lemma
;;  ext-subcase-proof2-proves

;;  (implies (and (member (p 1 2) symbols)
;;                (g-termp (list x y z) 1 symbols))
;;           (proves (ext-subcase-proof2 x y z)
;;                   (f-implies (f-equal x y) (f-implies (isin z y) (isin z x)))
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable eval-tautconseq-proof-proves)
;;   (use (eval-tautconseq-proof-proves (flist (list (f-implies (f-equal x y)
;;                                                              (f-iff (isin z x) (isin z y)))))
;;                                      (exp (f-implies (f-equal x y)
;;                                                      (f-implies (isin z y) (isin z x))))
;;                                      (pflist (list (ext-case-proof x y z)))))))
;; (toggle g0737 ext-subcase-proof2 t)
;; (defn
;;  z-trich-numeral-proof
;;  (x y z)
;;  (if
;;   (zerop x)
;;   (tautconseq-proof (list (f-not (isin y (phi))))
;;                     (z-trich1 (phi) y z)
;;                     (list (null-axiom-proof y)))
;;   (chain-or-proof
;;    (f-and (isin y (z-succ (numeral (sub1 x)))) (isin z (z-succ (numeral (sub1 x)))))
;;    (f-and (f-equal y (numeral (sub1 x))) (f-equal z (numeral (sub1 x))))
;;    (f-or (f-and (f-equal y (numeral (sub1 x))) (isin z (numeral (sub1 x))))
;;          (f-or (f-and (f-equal z (numeral (sub1 x))) (isin y (numeral (sub1 x))))
;;                (f-and (isin y (numeral (sub1 x))) (isin z (numeral (sub1 x))))))
;;    (f-or (f-equal y z) (f-or (isin y z) (isin z y)))
;;    (tautconseq-proof (list (f-implies (isin y (z-succ (numeral (sub1 x))))
;;                                       (f-or (f-equal y (numeral (sub1 x)))
;;                                             (isin y (numeral (sub1 x)))))
;;                            (f-implies (isin z (z-succ (numeral (sub1 x))))
;;                                       (f-or (f-equal z (numeral (sub1 x)))
;;                                             (isin z (numeral (sub1 x))))))
;;                      (f-implies (f-and (isin y (z-succ (numeral (sub1 x))))
;;                                        (isin z (z-succ (numeral (sub1 x)))))
;;                                 (f-or (f-and (f-equal y (numeral (sub1 x)))
;;                                              (f-equal z (numeral (sub1 x))))
;;                                       (f-or (f-and (f-equal y (numeral (sub1 x)))
;;                                                    (isin z (numeral (sub1 x))))
;;                                             (f-or (f-and (f-equal z (numeral (sub1 x)))
;;                                                          (isin y (numeral (sub1 x))))
;;                                                   (f-and (isin y (numeral (sub1 x)))
;;                                                          (isin z (numeral (sub1 x))))))))
;;                      (list (in-z-succ-proof1 (numeral (sub1 x)) y)
;;                            (in-z-succ-proof1 (numeral (sub1 x)) z)))
;;    (tautconseq-proof (list (f-implies (f-equal y (numeral (sub1 x)))
;;                                       (f-implies (f-equal z (numeral (sub1 x))) (f-equal y z))))
;;                      (f-implies (f-and (f-equal y (numeral (sub1 x)))
;;                                        (f-equal z (numeral (sub1 x))))
;;                                 (f-or (f-equal y z) (f-or (isin y z) (isin z y))))
;;                      (list (trans-equal-proof2 y (numeral (sub1 x)) z)))
;;    (tautconseq-proof (list (f-implies (f-equal y (numeral (sub1 x)))
;;                                       (f-implies (isin z (numeral (sub1 x))) (isin z y)))
;;                            (f-implies (f-equal z (numeral (sub1 x)))
;;                                       (f-implies (isin y (numeral (sub1 x))) (isin y z)))
;;                            (f-implies (f-and (isin y (numeral (sub1 x)))
;;                                              (isin z (numeral (sub1 x))))
;;                                       (f-or (f-equal y z) (f-or (isin y z) (isin z y)))))
;;                      (f-implies (f-or (f-and (f-equal y (numeral (sub1 x)))
;;                                              (isin z (numeral (sub1 x))))
;;                                       (f-or (f-and (f-equal z (numeral (sub1 x)))
;;                                                    (isin y (numeral (sub1 x))))
;;                                             (f-and (isin y (numeral (sub1 x)))
;;                                                    (isin z (numeral (sub1 x))))))
;;                                 (f-or (f-equal y z) (f-or (isin y z) (isin z y))))
;;                      (list (ext-subcase-proof2 y (numeral (sub1 x)) z)
;;                            (ext-subcase-proof2 z (numeral (sub1 x)) y)
;;                            (z-trich-numeral-proof (sub1 x) y z))))))
;; ;;  |- "((y in |x|) ^ (z in |x|)) -> ((y = z) ^ ((y in z) v (z in y)))".
;; (defthm z-trich-numeral-proof-proves

;;              (implies (and (g-termp (list y z) 1 symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (z-succ-hyps defns symbols))
;;                       (proves (z-trich-numeral-proof x y z)
;;                               (f-implies (f-and (isin y (numeral x)) (isin z (numeral x)))
;;                                          (f-or (f-equal y z) (f-or (isin y z) (isin z y))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0738 z-trich-numeral-proof t)
;; (defun ind-axiom-case-proof
;;       (form x pfbase pfind)
;;       (tautconseq-proof (list (g-subst form x (phi) 0)
;;                               (forall x
;;                                       (f-implies (f-and (z-int x) form)
;;                                                  (g-subst form x (z-succ x) 0)))
;;                               (ind-axiom form x)
;;                               (f-implies (forall x (f-implies (z-int x) form))
;;                                          (f-implies (z-int x) form)))
;;                         (f-implies (z-int x) form)
;;                         (list pfbase
;;                               (generalise-proof x
;;                                                 (f-implies (f-and (z-int x) form)
;;                                                            (g-subst form x (z-succ x) 0))
;;                                                 pfind)
;;                               (ind-axiom-proof form x)
;;                               (all-elim-proof x (f-implies (z-int x) form)))))
;; ;;  if |- "a[|0|]" and |- "((i x) ^ a[x]) -> a[(s x)]", then
;; ;;  |- "(i x) -> a[x]".
;; (defthm ind-axiom-case

;;              (implies (and (g-variable x)
;;                            (subset (list (fn 3 1) (fn 0 0)) symbols)
;;                            (g-formula (f-implies (z-int x) form) symbols)
;;                            (proves pfbase (g-subst form x (phi) 0) given defns symbols)
;;                            (proves pfind
;;                                    (f-implies (f-and (z-int x) form) (g-subst form x (z-succ x) 0))
;;                                    given
;;                                    defns
;;                                    symbols))
;;                       (proves (ind-axiom-case-proof form x pfbase pfind)
;;                               (f-implies (z-int x) form)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0422 ind-axiom-case-proof t)
;; (defthm atomp-z-int

;;              (equal (g-atomp (z-int x) symbols)
;;                     (and (member (p 2 1) symbols)
;;                          (g-termp x 0 symbols))))
;; (defthm formula-z-int

;;              (equal (g-formula (z-int x) symbols)
;;                     (and (member (p 2 1) symbols)
;;                          (g-termp x 0 symbols))))
;; (defun phi-in-int-proof
;;       (x)
;;       (ind-axiom-case-proof (f-or (f-equal (phi) x) (isin (phi) x))
;;                             x
;;                             (rt-expan-proof (f-equal (phi) (phi))
;;                                             (isin (phi) (phi))
;;                                             (ident-axiom-proof (phi)))
;;                             (tautconseq-proof (list (f-implies (f-or (f-equal (phi) x)
;;                                                                      (isin (phi) x))
;;                                                                (isin (phi) (z-succ x))))
;;                                               (f-implies (f-and (z-int x)
;;                                                                 (f-or (f-equal (phi) x)
;;                                                                       (isin (phi) x)))
;;                                                          (f-or (f-equal (phi) (z-succ x))
;;                                                                (isin (phi) (z-succ x))))
;;                                               (list (iff-split-proof2 (isin (phi) (z-succ x))
;;                                                                       (f-or (f-equal (phi) x)
;;                                                                             (isin (phi) x))
;;                                                                       (in-z-succ-proof x
;;                                                                                        (phi)))))))
;; ;;  |- "(i x) -> ((|0| = x) v (|0| in x))".  this is the only proof
;; ;; in this sequence of events in which the induction axiom schema of z2 is employed.
;; (defthm phi-in-int-proof-proves

;;              (implies (and (g-variable x)
;;                            (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (member (p 2 1) symbols)
;;                            (equal concl
;;                                   (f-implies (z-int x) (f-or (f-equal (phi) x) (isin (phi) x)))))
;;                       (proves (phi-in-int-proof x) concl given defns symbols))
;;              ((disable z-int)))
;; (toggle g0426 phi-in-int-proof t)
;; (defun ext-not-equal-proof
;;       (x y d pfx pfy)
;;       (tautconseq-proof (list (f-implies (f-equal x y) (isin d x)) (f-not (isin d x)))
;;                         (f-not (f-equal x y))
;;                         (list (ext-axiom-eq-elim2-proof x y d pfy) pfx)))
;; ;;  if |-"(not (d in x))" and |- "(d in y)", then |-"(not (x = y))".
;; (defthm ext-not-equal-proof-proves

;;              (implies (and (g-termp x 0 symbols)
;;                            (g-termp y 0 symbols)
;;                            (g-termp d 0 symbols)
;;                            (member (p 1 2) symbols)
;;                            (proves pfx (f-not (isin d x)) given defns symbols)
;;                            (proves pfy (isin d y) given defns symbols))
;;                       (proves (ext-not-equal-proof x y d pfx pfy)
;;                               (f-not (f-equal x y))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0427 ext-not-equal-proof t)
;; (toggle g0428 z-opair nil)
;; (defun phi-not-in-opair-proof
;;       (u v)
;;       (and-join-proof (f-not (f-equal (phi) (z-opair u v)))
;;                       (f-not (isin (phi) (z-opair u v)))
;;                       (ext-not-equal-proof (phi)
;;                                            (z-opair u v)
;;                                            (z-sing u)
;;                                            (null-axiom-proof (z-sing u))
;;                                            (isin-pair1-proof (z-sing u) (z-pair u v)))
;;                       (tautconseq-proof (list (f-implies (isin (phi) (z-opair u v))
;;                                                          (f-or (f-equal (phi) (z-sing u))
;;                                                                (f-equal (phi) (z-pair u v))))
;;                                               (f-not (f-equal (phi) (z-sing u)))
;;                                               (f-not (f-equal (phi) (z-pair u v))))
;;                                         (f-not (isin (phi) (z-opair u v)))
;;                                         (list (iff-split-proof1 (isin (phi) (z-opair u v))
;;                                                                 (f-or (f-equal (phi) (z-sing u))
;;                                                                       (f-equal (phi)
;;                                                                                (z-pair u v)))
;;                                                                 (pair-axiom-proof (phi)
;;                                                                                   (z-sing u)
;;                                                                                   (z-pair u v)))
;;                                               (ext-not-equal-proof (phi)
;;                                                                    (z-sing u)
;;                                                                    u
;;                                                                    (null-axiom-proof u)
;;                                                                    (isin-sing1-proof u))
;;                                               (ext-not-equal-proof (phi)
;;                                                                    (z-pair u v)
;;                                                                    u
;;                                                                    (null-axiom-proof u)
;;                                                                    (isin-pair1-proof u v))))))
;; ;;  |- "((not (|0| in <u, v>)) ^ (not (|0| in <u, v>)))".
;; (defthm phi-not-in-opair-proof-proves

;;              (implies (and (subset (list (fn 0 0) (p 1 2) (fn 1 2)) symbols)
;;                            (g-termp u 0 symbols)
;;                            (g-termp v 0 symbols)
;;                            (equal concl
;;                                   (f-and (f-not (f-equal (phi) (z-opair u v)))
;;                                          (f-not (isin (phi) (z-opair u v))))))
;;                       (proves (phi-not-in-opair-proof u v) concl given defns symbols)))
;; (toggle g0429 phi-not-in-opair-proof t)
;; (toggle g0430 z-opair t)
;; (defun not-int-opair-proof
;;       (u v x)
;;       (tautconseq-proof (list (f-implies (z-int (z-opair u v))
;;                                          (f-or (f-equal (phi) (z-opair u v))
;;                                                (isin (phi) (z-opair u v))))
;;                               (f-and (f-not (f-equal (phi) (z-opair u v)))
;;                                      (f-not (isin (phi) (z-opair u v)))))
;;                         (f-not (z-int (z-opair u v)))
;;                         (list (subst-rule-proof (f-implies (z-int x)
;;                                                            (f-or (f-equal (phi) x)
;;                                                                  (isin (phi) x)))
;;                                                 x
;;                                                 (z-opair u v)
;;                                                 (phi-in-int-proof x))
;;                               (phi-not-in-opair-proof u v))))
;; ;;  |- "(not (i <u v>))".
;; (defthm not-int-opair-proof-proves

;;              (implies (and (g-variable x)
;;                            (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (member (p 2 1) symbols)
;;                            (g-termp u 0 symbols)
;;                            (g-termp v 0 symbols))
;;                       (proves (not-int-opair-proof u v x)
;;                               (f-not (z-int (z-opair u v)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0868 not-int-opair-proof t)
;; (defun z-trich (x v1 v2) (forall v1 (forall v2 (z-trich1 x v1 v2))))
;; (defun z-int-defun (x y z) (f-and (z-trans x y z) (z-trich x y z)))
;; (toggle g0609 pred-defn-proof t)
;; (defthm subst-f-iff

;;              (equal (g-subst (f-iff x y) var term 0)
;;                     (f-iff (g-subst x var term 0) (g-subst y var term 0)))
;;              ((enable f-iff)))
;; (toggle g0872 z-trans nil)
;; (defthm subset-del

;;              (implies (g-variable x) (equal (subset (del x y) z) (subset y (cons x z)))))
;; (defun z-int-defn-proof
;;       (term)
;;       (subst-rule-proof (f-iff (z-int 0) (z-int-defun 0 1 2))
;;                         0
;;                         term
;;                         (pred-defn-proof (p 2 1) (list 0) (z-int-defun 0 1 2))))
;; (toggle g0613 not-member-varlist t)
;; (defun z-int-hyps
;;       (defns symbols)
;;       (and (member (p 1 2) (rest-of (p 2 1) symbols))
;;            (equal (assoc (p 2 1) defns) (z-int-defun 0 1 2))))
;; (defthm z-int-defn-proof-proves

;;              (implies (and (g-termp term 0 symbols)
;;                            (subset (list (p 1 2) (p 2 1)) symbols)
;;                            (z-int-hyps defns symbols)
;;                            (nil-intersect (list 1 2) (collect-free term 0)))
;;                       (proves (z-int-defn-proof term)
;;                               (f-iff (z-int term) (f-and (z-trans term 1 2) (z-trich term 1 2)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable not-free-covering)))
;; (toggle g0639 z-int-defn-proof t)
;; (defthm covering-numeral (equal (covering (numeral x) var 0) nil))
;; (defn
;;  z-int-numeral-proof
;;  (x)
;;  (f-iff-mp-proof2
;;   (z-int (numeral x))
;;   (f-and (z-trans (numeral x) 1 2) (z-trich (numeral x) 1 2))
;;   (z-int-defn-proof (numeral x))
;;   (and-join-proof (z-trans (numeral x) 1 2)
;;                   (z-trich (numeral x) 1 2)
;;                   (generalise-proof 1
;;                                     (forall 2 (z-trans1 (numeral x) 1 2))
;;                                     (generalise-proof 2
;;                                                       (z-trans1 (numeral x) 1 2)
;;                                                       (z-trans-numeral-proof x 1 2)))
;;                   (generalise-proof 1
;;                                     (forall 2 (z-trich1 (numeral x) 1 2))
;;                                     (generalise-proof 2
;;                                                       (z-trich1 (numeral x) 1 2)
;;                                                       (z-trich-numeral-proof x 1 2))))))
;; (toggle g0744 z-int-defun t)
;; (toggle g0614 z-int-hyps t)
;; ;;  |- "(i |x|)".  at this point we are overloading our notation.  though |x|
;; ;; appears in quotes, it denotes the numeral which is the result of
;; ;; evaluating |x| for the given x.  so the metatheorem is that "(i |x|)" is
;; ;; a z2 theorem for any x.
;; (defthm z-int-numeral-proof-proves

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 2 1) (p 1 2) (fn 0 0))
;;                                    symbols)
;;                            (z-int-hyps defns symbols))
;;                       (proves (z-int-numeral-proof x) (z-int (numeral x)) given defns symbols))
;;              ((disable numeral) (use (z-int-defn-proof-proves (term (numeral x))))))
;; (toggle g0906 z-int-numeral-proof t)
;; (defthm covering-z-int (equal (covering (z-int x) var 0) (covering (list x) var 1)))
;; (defthm collect-z-int (equal (collect-free (z-int x) 0) (collect-free (list x) 1)))
;; (defthm subst-z-int

;;              (equal (g-subst (z-int x) var term 0) (z-int (g-subst x var term 0))))
;; (defthm parallel-subst-z-int

;;              (equal (parallel-subst (z-int x) var term 0) (z-int (parallel-subst x var term 0))))
;; (toggle g0907 z-int t)
;; (defun z-car (x) (list (fn 4 1) x))
;; (defun z-cdr (x) (list (fn 5 1) x))
;; (toggle g0628 z-opair nil)
;; (defthm covering-z-opair

;;              (equal (covering (z-opair x y) var 0)
;;                     (covering (list (z-sing x) (z-pair x y)) var 1)))
;; (defthm subst-z-opair

;;              (equal (g-subst (z-opair x y) var term 0)
;;                     (z-opair (g-subst x var term 0) (g-subst y var term 0))))
;; (defthm parallel-subst-z-opair

;;              (equal (parallel-subst (z-opair x y) vars terms 0)
;;                     (z-opair (parallel-subst x vars terms 0) (parallel-subst y vars terms 0))))
;; (toggle g0608 z-opair t)
;; (defun z-car-unique-step1-proof
;;       (x y y1 z z1)
;;       (tautconseq-proof (list (f-implies (f-equal x (z-opair y z))
;;                                          (f-implies (f-equal x (z-opair y1 z1))
;;                                                     (f-equal (z-opair y z) (z-opair y1 z1))))
;;                               (f-implies (f-equal (z-opair y z) (z-opair y1 z1)) (f-equal y y1)))
;;                         (f-implies (f-equal x (z-opair y z))
;;                                    (f-implies (f-equal x (z-opair y1 z1)) (f-equal y y1)))
;;                         (list (trans-equal-proof1 (z-opair y z) x (z-opair y1 z1))
;;                               (z-car-unique-proof y z y1 z1))))
;; ;;  |- "(x = <y, z>) -> ((x = <y1, z1>) -> (y = y1))".
;; (defthm z-car-unique-step1-proof-proves

;;              (implies (and (g-termp (list x y y1 z z1) 1 symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (z-car-unique-step1-proof x y y1 z z1)
;;                               (f-implies (f-equal x (z-opair y z))
;;                                          (f-implies (f-equal x (z-opair y1 z1)) (f-equal y y1)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0630 z-car-unique-step1-proof t)
;; (defn
;;  z-car-unique-step2-proof
;;  (x y y1 z z1)
;;  (forsome-intro-proof
;;   z
;;   (f-equal x (z-opair y z))
;;   (f-implies (forsome z1 (f-equal x (z-opair y1 z1))) (f-equal y y1))
;;   (chain-proof
;;    (f-equal x (z-opair y z))
;;    (f-implies (forsome z1 (f-equal x (z-opair y1 z1))) (f-equal y y1))
;;    (list (forall z1 (f-implies (f-equal x (z-opair y1 z1)) (f-equal y y1)))
;;          (f-implies (forsome z1 (f-equal x (z-opair y1 z1))) (forsome z1 (f-equal y y1))))
;;    (list (forall-intro-proof (f-equal x (z-opair y z))
;;                              (f-implies (f-equal x (z-opair y1 z1)) (f-equal y y1))
;;                              z1
;;                              (z-car-unique-step1-proof x y y1 z z1))
;;          (forall-over-implies-proof z1 (f-equal x (z-opair y1 z1)) (f-equal y y1))
;;          (tautconseq-proof (list (f-implies (forsome z1 (f-equal y y1)) (f-equal y y1)))
;;                            (f-implies (f-implies (forsome z1 (f-equal x (z-opair y1 z1)))
;;                                                  (forsome z1 (f-equal y y1)))
;;                                       (f-implies (forsome z1 (f-equal x (z-opair y1 z1)))
;;                                                  (f-equal y y1)))
;;                            (list (forsome-intro-proof z1
;;                                                       (f-equal y y1)
;;                                                       (f-equal y y1)
;;                                                       (prop-axiom-proof (f-equal y y1)))))))))
;; (defthm z-car-unique-step2-proof-proves

;;              (implies (and (var-set (list y y1 z z1) 4)
;;                            (g-termp x 0 symbols)
;;                            (nil-intersect (list z z1) (collect-free x 0))
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (z-car-unique-step2-proof x y y1 z z1)
;;                               (f-implies (forsome z (f-equal x (z-opair y z)))
;;                                          (f-implies (forsome z1 (f-equal x (z-opair y1 z1)))
;;                                                     (f-equal y y1)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0637 z-car-unique-step2-proof t)
;; (defthm subst-subst

;;              (implies (and (not (member y (collect-free exp flg)))
;;                            (free-for exp x y flg)
;;                            (g-variable x)
;;                            (g-variable y))
;;                       (equal (g-subst (g-subst exp x y flg) y x flg) exp)))
;; (defthm not-free-subst

;;              (implies (not (member x (collect-free term 0)))
;;                       (not (member x (collect-free (g-subst exp x term flg) flg)))))
;; (defun rename-bndvar-proof
;;       (x y exp)
;;       (forsome-intro-proof x
;;                            (g-subst (g-subst exp x y 0) y x 0)
;;                            (forsome y (g-subst exp x y 0))
;;                            (subst-axiom-proof (g-subst exp x y 0) y x)))
;; (defthm rename-bndvar-proof-proves

;;              (implies (and (not (member y (collect-free exp 0)))
;;                            (free-for exp x y 0)
;;                            (g-formula exp symbols)
;;                            (var-set (list x y) 2)
;;                            (equal exp-inst (g-subst exp x y 0)))
;;                       (proves (rename-bndvar-proof x y exp)
;;                               (f-implies (forsome x exp) (forsome y exp-inst))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0640 rename-bndvar-proof t)
;; (defun z-car-uniqueness-case-proof
;;       (x y y1 z z1)
;;       (tautconseq-proof (list (f-implies (forsome z (f-equal x (z-opair y1 z)))
;;                                          (forsome z1 (f-equal x (z-opair y1 z1))))
;;                               (f-implies (forsome z (f-equal x (z-opair y z)))
;;                                          (f-implies (forsome z1 (f-equal x (z-opair y1 z1)))
;;                                                     (f-equal y y1))))
;;                         (f-implies (f-and (forsome z (f-equal x (z-opair y z)))
;;                                           (forsome z (f-equal x (z-opair y1 z))))
;;                                    (f-equal y y1))
;;                         (list (rename-bndvar-proof z z1 (f-equal x (z-opair y1 z)))
;;                               (z-car-unique-step2-proof x y y1 z z1))))
;; (defthm z-car-uniqueness-case-proof-proves

;;              (implies (and (var-set (list y y1 z z1) 4)
;;                            (nil-intersect (list z z1) (collect-free x 0))
;;                            (g-termp x 0 symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (z-car-uniqueness-case-proof x y y1 z z1)
;;                               (f-implies (f-and (forsome z (f-equal x (z-opair y z)))
;;                                                 (forsome z (f-equal x (z-opair y1 z))))
;;                                          (f-equal y y1))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0645 z-car-uniqueness-case-proof t)
;; ;; the definition of the z2 analogue of car.
;; (defun z-car-defn
;;       (x y y1 z)
;;       (f-if (forsome y1 (forsome z (f-equal x (z-opair y1 z))))
;;             (forsome z (f-equal x (z-opair y z)))
;;             (f-equal y (phi))))
;; ;; the existence part of the admissibility proof of "(z-car x)".
;; (defn
;;  z-car-exis-proof
;;  (x y z)
;;  (forsome-f-if-case-proof
;;   y
;;   (forsome y (forsome z (f-equal x (z-opair y z))))
;;   (forsome z (f-equal x (z-opair y z)))
;;   (f-equal y (phi))
;;   (prop-axiom-proof (forsome y (forsome z (f-equal x (z-opair y z)))))
;;   (tautconseq-proof (list (forsome y (f-equal y (phi))))
;;                     (f-implies (f-not (forsome y (forsome z (f-equal x (z-opair y z)))))
;;                                (forsome y (f-equal y (phi))))
;;                     (list (exis-fun-intro-proof y (phi))))))
;; (defthm z-car-exis-proof-proves

;;              (implies (and (var-set (list y z) 2)
;;                            (subset (list (fn 0 0) (fn 1 2)) symbols)
;;                            (g-termp x 0 symbols)
;;                            (equal concl (forsome y (z-car-defun x y y z))))
;;                       (proves (z-car-exis-proof x y z) concl given defns symbols)))
;; (toggle g0646 z-car-exis-proof t)
;; ;; the uniqueness part of the admissibility proof of "(z-car x)".
;; (defun z-car-uniqueness-proof
;;       (x y y1 z z1)
;;       (unique-f-if-proof (forsome y (forsome z (f-equal x (z-opair y z))))
;;                          (forsome z (f-equal x (z-opair y z)))
;;                          (forsome z (f-equal x (z-opair y1 z)))
;;                          (f-equal y (phi))
;;                          (f-equal y1 (phi))
;;                          (f-equal y y1)
;;                          (z-car-uniqueness-case-proof x y y1 z z1)
;;                          (unique-fun-intro-proof y y1 (phi))))
;; (defun z-car-defn-proof
;;       (term)
;;       (subst-rule-proof (z-car-defun 0 (z-car 0) 1 2)
;;                         0
;;                         term
;;                         (fun-defn-proof (fn 4 1)
;;                                         (list 0)
;;                                         1
;;                                         3
;;                                         (z-car-defun 0 1 1 2)
;;                                         (z-car-exis-proof 0 1 2)
;;                                         (z-car-uniqueness-proof 0 1 3 2 4))))
;; (toggle g0648 not-member-delete-equals t)
;; (defthm covering-forsome

;;              (implies (g-variable x)
;;                       (equal (covering (forsome x y) var 0)
;;                              (if (memb var (collect-free (forsome x y) 0))
;;                                  (cons x (covering y var 0))
;;                                  nil))))
;; (defun z-car-hyps
;;       (defns symbols)
;;       (and (subset (list (p 1 2) (fn 1 2) (fn 0 0)) (rest-of (fn 4 1) symbols))
;;            (equal (assoc (fn 4 1) defns) (z-car-defun 0 (z-car 0) 1 2))))
;; ;; the admissibility of "(z-car x)".
;; (defthm z-car-defn-proof-proves

;;              (implies (and (subset (list (fn 4 1) (p 1 2) (fn 1 2) (fn 0 0)) symbols)
;;                            (z-car-hyps defns symbols)
;;                            (g-termp term 0 symbols)
;;                            (equal (collect-free term 0) nil)
;;                            (equal concl (z-car-defun term (z-car term) 1 2)))
;;                       (proves (z-car-defn-proof term) concl given defns symbols))
;;              ((use (z-car-exis-proof-proves (x 0)
;;                                             (y 1)
;;                                             (z 2)
;;                                             (symbols (rest-of (fn 4 1) symbols))))
;;               ))
;; (toggle g0649 z-car-defn-proof t)
;; (toggle g0678 z-car-hyps t)
;; (defun z-cdr-unique-step1-proof
;;       (x y y1 z z1)
;;       (tautconseq-proof (list (f-implies (f-equal x (z-opair y z))
;;                                          (f-implies (f-equal x (z-opair y1 z1))
;;                                                     (f-equal (z-opair y z) (z-opair y1 z1))))
;;                               (f-implies (f-equal (z-opair y z) (z-opair y1 z1)) (f-equal z z1)))
;;                         (f-implies (f-equal x (z-opair y z))
;;                                    (f-implies (f-equal x (z-opair y1 z1)) (f-equal z z1)))
;;                         (list (trans-equal-proof1 (z-opair y z) x (z-opair y1 z1))
;;                               (z-cdr-unique-proof y z y1 z1))))
;; (defthm z-cdr-unique-step1-proof-proves

;;              (implies (and (g-termp (list x y y1 z z1) 1 symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (z-cdr-unique-step1-proof x y y1 z z1)
;;                               (f-implies (f-equal x (z-opair y z))
;;                                          (f-implies (f-equal x (z-opair y1 z1)) (f-equal z z1)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0647 z-cdr-unique-step1-proof t)
;; (defn
;;  z-cdr-unique-step2-proof
;;  (x y y1 z z1)
;;  (forsome-intro-proof
;;   y
;;   (f-equal x (z-opair y z))
;;   (f-implies (forsome y1 (f-equal x (z-opair y1 z1))) (f-equal z z1))
;;   (chain-proof
;;    (f-equal x (z-opair y z))
;;    (f-implies (forsome y1 (f-equal x (z-opair y1 z1))) (f-equal z z1))
;;    (list (forall y1 (f-implies (f-equal x (z-opair y1 z1)) (f-equal z z1)))
;;          (f-implies (forsome y1 (f-equal x (z-opair y1 z1))) (forsome y1 (f-equal z z1))))
;;    (list (forall-intro-proof (f-equal x (z-opair y z))
;;                              (f-implies (f-equal x (z-opair y1 z1)) (f-equal z z1))
;;                              y1
;;                              (z-cdr-unique-step1-proof x y y1 z z1))
;;          (forall-over-implies-proof y1 (f-equal x (z-opair y1 z1)) (f-equal z z1))
;;          (tautconseq-proof (list (f-implies (forsome y1 (f-equal z z1)) (f-equal z z1)))
;;                            (f-implies (f-implies (forsome y1 (f-equal x (z-opair y1 z1)))
;;                                                  (forsome y1 (f-equal z z1)))
;;                                       (f-implies (forsome y1 (f-equal x (z-opair y1 z1)))
;;                                                  (f-equal z z1)))
;;                            (list (forsome-intro-proof y1
;;                                                       (f-equal z z1)
;;                                                       (f-equal z z1)
;;                                                       (prop-axiom-proof (f-equal z z1)))))))))
;; (defthm z-cdr-unique-step2-proof-proves

;;              (implies (and (var-set (list y y1 z z1) 4)
;;                            (g-termp x 0 symbols)
;;                            (nil-intersect (list y y1) (collect-free x 0))
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (z-cdr-unique-step2-proof x y y1 z z1)
;;                               (f-implies (forsome y (f-equal x (z-opair y z)))
;;                                          (f-implies (forsome y1 (f-equal x (z-opair y1 z1)))
;;                                                     (f-equal z z1)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0650 z-cdr-unique-step2-proof t)
;; (defun z-cdr-uniqueness-case-proof
;;       (x y y1 z z1)
;;       (tautconseq-proof (list (f-implies (forsome y (f-equal x (z-opair y z1)))
;;                                          (forsome y1 (f-equal x (z-opair y1 z1))))
;;                               (f-implies (forsome y (f-equal x (z-opair y z)))
;;                                          (f-implies (forsome y1 (f-equal x (z-opair y1 z1)))
;;                                                     (f-equal z z1))))
;;                         (f-implies (f-and (forsome y (f-equal x (z-opair y z)))
;;                                           (forsome y (f-equal x (z-opair y z1))))
;;                                    (f-equal z z1))
;;                         (list (rename-bndvar-proof y y1 (f-equal x (z-opair y z1)))
;;                               (z-cdr-unique-step2-proof x y y1 z z1))))
;; (defthm z-cdr-uniqueness-case-proof-proves

;;              (implies (and (var-set (list y y1 z z1) 4)
;;                            (nil-intersect (list y y1) (collect-free x 0))
;;                            (g-termp x 0 symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols))
;;                       (proves (z-cdr-uniqueness-case-proof x y y1 z z1)
;;                               (f-implies (f-and (forsome y (f-equal x (z-opair y z)))
;;                                                 (forsome y (f-equal x (z-opair y z1))))
;;                                          (f-equal z z1))
;;                               given
;;                               defns
;;                               symbols)))
;; ;; the definition of the z2 analogue of cdr, "(z-cdr x)".
;; (defun z-cdr-defn
;;       (x z y1 z1)
;;       (f-if (forsome z1 (forsome y1 (f-equal x (z-opair y1 z1))))
;;             (forsome y1 (f-equal x (z-opair y1 z)))
;;             (f-equal z (phi))))
;; ;; the existence part of the admissibility of "(z-cdr x)".
;; (defn
;;  z-cdr-exis-proof
;;  (x y z)
;;  (forsome-f-if-case-proof
;;   z
;;   (forsome z (forsome y (f-equal x (z-opair y z))))
;;   (forsome y (f-equal x (z-opair y z)))
;;   (f-equal z (phi))
;;   (prop-axiom-proof (forsome z (forsome y (f-equal x (z-opair y z)))))
;;   (tautconseq-proof (list (forsome z (f-equal z (phi))))
;;                     (f-implies (f-not (forsome z (forsome y (f-equal x (z-opair y z)))))
;;                                (forsome z (f-equal z (phi))))
;;                     (list (exis-fun-intro-proof z (phi))))))
;; (defthm z-cdr-exis-proof-proves

;;              (implies (and (var-set (list y z) 2)
;;                            (subset (list (fn 0 0) (fn 1 2)) symbols)
;;                            (g-termp x 0 symbols))
;;                       (proves (z-cdr-exis-proof x y z)
;;                               (forsome z (z-cdr-defun x z y z))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0651 z-cdr-exis-proof t)
;; ;; the uniqueness part of the admissibility of "(z-cdr x)".
;; (defun z-cdr-uniqueness-proof
;;       (x y y1 z z1)
;;       (unique-f-if-proof (forsome z (forsome y (f-equal x (z-opair y z))))
;;                          (forsome y (f-equal x (z-opair y z)))
;;                          (forsome y (f-equal x (z-opair y z1)))
;;                          (f-equal z (phi))
;;                          (f-equal z1 (phi))
;;                          (f-equal z z1)
;;                          (z-cdr-uniqueness-case-proof x y y1 z z1)
;;                          (unique-fun-intro-proof z z1 (phi))))
;; (defun z-cdr-defn-proof
;;       (term)
;;       (subst-rule-proof (z-cdr-defun 0 (z-cdr 0) 1 2)
;;                         0
;;                         term
;;                         (fun-defn-proof (fn 5 1)
;;                                         (list 0)
;;                                         2
;;                                         4
;;                                         (z-cdr-defun 0 2 1 2)
;;                                         (z-cdr-exis-proof 0 1 2)
;;                                         (z-cdr-uniqueness-proof 0 1 3 2 4))))
;; (defun z-cdr-hyps
;;       (defns symbols)
;;       (and (subset (list (p 1 2) (fn 1 2) (fn 0 0)) (rest-of (fn 5 1) symbols))
;;            (equal (assoc (fn 5 1) defns) (z-cdr-defun 0 (z-cdr 0) 1 2))))
;; ;; the admissibility of "(z-cdr x)".
;; (defthm z-cdr-defn-proof-proves

;;              (implies (and (subset (list (fn 5 1) (p 1 2) (fn 1 2) (fn 0 0)) symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (g-termp term 0 symbols)
;;                            (equal (collect-free term 0) nil)
;;                            (equal concl (z-cdr-defun term (z-cdr term) 1 2)))
;;                       (proves (z-cdr-defn-proof term) concl given defns symbols))
;;              ((use (z-cdr-exis-proof-proves (x 0)
;;                                             (y 1)
;;                                             (z 2)
;;                                             (symbols (rest-of (fn 5 1) symbols))))
;;               ))
;; (toggle g0679 z-cdr-hyps t)
;; (toggle g0655 z-cdr-defn-proof t)
;; (defun list-num-nequal-proof
;;       (n u v)
;;       (tautconseq-proof (list (f-implies (f-equal (numeral n) (z-opair u v))
;;                                          (f-implies (z-int (numeral n)) (z-int (z-opair u v))))
;;                               (z-int (numeral n))
;;                               (f-not (z-int (z-opair u v))))
;;                         (f-not (f-equal (numeral n) (z-opair u v)))
;;                         (list (equal-axiom2-proof (p 2 1)
;;                                                   (list (numeral n))
;;                                                   (list (z-opair u v)))
;;                               (z-int-numeral-proof n)
;;                               (not-int-opair-proof u v 0))))
;; (toggle g0659 z-int nil)
;; (defthm equal-axiom2-z-int

;;              (implies (and (g-termp (list x y) 1 symbols)
;;                            (member (p 2 1) symbols))
;;                       (proves (equal-axiom2-proof (p 2 1) (list x) (list y))
;;                               (f-implies (f-equal x y) (f-implies (z-int x) (z-int y)))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0660 z-int t)
;; ;; an important metatheorem: |- "(not (|n| = <u v>))".
;; (defthm list-num-nequal-proof-proves

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (member (p 2 1) symbols)
;;                            (z-int-hyps defns symbols)
;;                            (g-termp (list u v) 1 symbols)
;;                            (equal concl (f-not (f-equal (numeral n) (z-opair u v)))))
;;                       (proves (list-num-nequal-proof n u v) concl given defns symbols)))
;; (toggle g0658 list-num-nequal-proof t)
;; ;; the goedel-encoding.  it takes lisp data-structures built from numbers using
;; ;; cons to sets in z2 which are formed from numerals using ordered pairing.
;; ;; we represent the encoding of x as <x>.
;; (defun ncode (x) (if (consp x) (z-opair (ncode (car x)) (ncode (cdr x))) (numeral x)))
;; (defthm termp-ncode

;;              (implies (and (member (fn 3 1) symbols)
;;                            (member (fn 1 2) symbols)
;;                            (member (fn 0 0) symbols))
;;                       (g-termp (ncode x) 0 symbols))
;;              ((induct (ncode x))))
;; (defthm collect-free-ncode (equal (collect-free (ncode x) 0) nil))
;; (defun ncode-equal
;;       (x y)
;;       (if (consp x)
;;           (if (consp y)
;;               (and (ncode-equal (car x) (car y))
;;                    (ncode-equal (cdr x) (cdr y)))
;;               nil)
;;           (if (consp y)
;;               nil
;;               (if (zerop x) (zerop y) (if (zerop y) nil (ncode-equal (sub1 x) (sub1 y)))))))
;; (toggle g0756 z-trans t)
;; (toggle g0757 z-trich t)
;; (defun ncode-nequal-step-proof
;;       (x1 y1 x y pf1 pf2)
;;       (detach-proof (f-not (f-equal x1 y1))
;;                     (f-not (f-equal x y))
;;                     pf1
;;                     (contra-pos-proof1 (f-equal x y) (f-equal x1 y1) pf2)))
;; (defun z-trans2 (x) (z-trans x 1 2))
;; (defun z-trich2 (x) (z-trich x 1 2))
;; (defn
;;  ncode-nequal-proof
;;  (x y)
;;  (if
;;   (consp x)
;;   (if (consp y)
;;       (if (not (ncode-equal (car x) (car y)))
;;           (ncode-nequal-step-proof (ncode (car x))
;;                                    (ncode (car y))
;;                                    (ncode x)
;;                                    (ncode y)
;;                                    (ncode-nequal-proof (car x) (car y))
;;                                    (z-car-unique-proof (ncode (car x))
;;                                                        (ncode (cdr x))
;;                                                        (ncode (car y))
;;                                                        (ncode (cdr y))))
;;           (ncode-nequal-step-proof (ncode (cdr x))
;;                                    (ncode (cdr y))
;;                                    (ncode x)
;;                                    (ncode y)
;;                                    (ncode-nequal-proof (cdr x) (cdr y))
;;                                    (z-cdr-unique-proof (ncode (car x))
;;                                                        (ncode (cdr x))
;;                                                        (ncode (car y))
;;                                                        (ncode (cdr y)))))
;;       (ncode-nequal-step-proof (ncode y)
;;                                (ncode x)
;;                                (ncode x)
;;                                (ncode y)
;;                                (list-num-nequal-proof y (ncode (car x)) (ncode (cdr x)))
;;                                (symmetry-proof1 (ncode x) (ncode y))))
;;   (if
;;    (consp y)
;;    (list-num-nequal-proof x (ncode (car y)) (ncode (cdr y)))
;;    (if
;;     (zerop x)
;;     (ext-not-equal-proof (ncode x)
;;                          (ncode y)
;;                          (ncode (sub1 y))
;;                          (null-axiom-proof (ncode (sub1 y)))
;;                          (x-in-z-succ-x-proof (ncode (sub1 y))))
;;     (if
;;      (zerop y)
;;      (ncode-nequal-step-proof (ncode y)
;;                               (ncode x)
;;                               (ncode x)
;;                               (ncode y)
;;                               (ext-not-equal-proof (ncode y)
;;                                                    (ncode x)
;;                                                    (ncode (sub1 x))
;;                                                    (null-axiom-proof (ncode (sub1 x)))
;;                                                    (x-in-z-succ-x-proof (ncode (sub1 x))))
;;                               (symmetry-proof1 (ncode x) (ncode y)))
;;      (tautconseq-proof
;;       (list (z-trans2 (ncode (sub1 x)))
;;             (z-trans2 (ncode (sub1 y)))
;;             (f-implies (z-trans2 (ncode (sub1 x)))
;;                        (f-implies (z-trans2 (ncode (sub1 y)))
;;                                   (f-implies (f-equal (ncode x) (ncode y))
;;                                              (f-equal (ncode (sub1 x)) (ncode (sub1 y))))))
;;             (f-not (f-equal (ncode (sub1 x)) (ncode (sub1 y)))))
;;       (f-not (f-equal (ncode x) (ncode y)))
;;       (list (tautconseq-proof (list (z-int (ncode (sub1 x)))
;;                                     (f-iff (z-int (ncode (sub1 x)))
;;                                            (f-and (z-trans2 (ncode (sub1 x)))
;;                                                   (z-trich2 (ncode (sub1 x))))))
;;                               (z-trans2 (ncode (sub1 x)))
;;                               (list (z-int-numeral-proof (sub1 x))
;;                                     (z-int-defn-proof (ncode (sub1 x)))))
;;             (tautconseq-proof (list (z-int (ncode (sub1 y)))
;;                                     (f-iff (z-int (ncode (sub1 y)))
;;                                            (f-and (z-trans2 (ncode (sub1 y)))
;;                                                   (z-trich2 (ncode (sub1 y))))))
;;                               (z-trans2 (ncode (sub1 y)))
;;                               (list (z-int-numeral-proof (sub1 y))
;;                                     (z-int-defn-proof (ncode (sub1 y)))))
;;             (z-succ-equal-proof (ncode (sub1 x)) (ncode (sub1 y)) 1 2)
;;             (ncode-nequal-proof (sub1 x) (sub1 y)))))))))
;; ;; a crucial metatheorem: if x is different from y, then |- "(not (<x>=<y>))".
;; (defthm ncode-nequal-proof-proves

;;              (implies (and (subset (list (fn 3 1) (p 2 1) (p 1 2) (fn 2 2) (fn 1 2) (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (not (ncode-equal x y)))
;;                       (proves (ncode-nequal-proof x y)
;;                               (f-not (f-equal (ncode x) (ncode y)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (ncode-nequal-proof x y))))
;; (toggle g0758 ncode-nequal-proof t)
;; (defthm ncode-nequal-proof-proves-again

;;              (implies (and (subset (list (fn 3 1) (p 2 1) (p 1 2) (fn 2 2) (fn 1 2) (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (not (ncode-equal x y))
;;                            (equal concl (f-not (f-equal (ncode x) (ncode y)))))
;;                       (proves (ncode-nequal-proof x y) concl given defns symbols))
;;              ((use (ncode-nequal-proof-proves))))
;; (toggle g0760 ncode-nequal-proof-proves t)
;; ;; what we would like to do next is to demonstrate the admissibility of
;; ;; z2 analogues of several lisp functions which are used to define the lisp
;; ;; interpreter.  these include the primitive lisp functions like consp, car, cdr,
;; ;; cons, zerop, acl2-numberp, add1, sub1, and equal.  the definitions of these z2
;; ;; functions involve the use of the logical-if connective.  for example, the
;; ;; definition of the analogue of car, "(z-car x)", is
;; ;;          "(if (forsome y (forsome z (x = <y, z>)))
;; ;;            then (forsome z (x = <(z-car x), z>))
;; ;;            else ((z-car x) = |0|))".
;; ;; the definition of the analogue of consp, "(z-consp x)", is
;; ;;          "(if (forsome y (forsome z (x = <y, z>)))
;; ;;            then ((z-car x) = |1|)
;; ;;            else ((z-car x) = |0|))".
;; ;; since we will be proving a number of metatheorem regarding the logical-if
;; ;; connective, it is convenient to have a representation for such expressions
;; ;; which is easily manipulated without having to expand the abbreviation "(if a b c)".
;; ;; the shell z-if is used to represent if-trees.
;; (add-shell z-if
;;            nil
;;            z-ifp
;;            ((z-test (none-of) zero) (z-left (none-of) zero) (z-right (none-of) zero)))
;; ;; term-z-if checks if every test position of the if-tree exp is a formula,
;; ;; and every leaf expression is a term in which var does not occur free.
;; ;; we will call such an if-tree a `term-if-tree'.  this is useful in representing
;; ;; a definition by cases where each case has the form "((f x) = exp)".
;; ;; the term-if-tree corresponding to the definition of "(z-consp x)" is
;; ;; (z-if "(forsome y (forsome z (x = <y, z>)))"  |1|  |0|).
;; (defun term-z-if
;;       (exp var symbols)
;;       (if (z-ifp exp)
;;           (and (g-formula (z-test exp) symbols)
;;                (not (member var (collect-free (z-test exp) 0)))
;;                (term-z-if (z-left exp) var symbols)
;;                (term-z-if (z-right exp) var symbols))
;;           (and (g-termp exp 0 symbols)
;;                (not (member var (collect-free exp 0))))))
;; ;; make-term-z-if makes an formula out of the term-if-tree by replacing each occurrence
;; ;; of z-if by the logical-if connective, and returning "(var = exp)" for each
;; ;; leaf term "exp".  thus make-term-z-if applied to the term-if-tree for "z-consp"
;; ;; with the variable "value" for var returns the definition for "z-consp".
;; (defun make-term-z-if
;;       (var exp)
;;       (if (z-ifp exp)
;;           (f-if (z-test exp) (make-term-z-if var (z-left exp)) (make-term-z-if var (z-right exp)))
;;           (f-equal var exp)))
;; (defn
;;  term-z-if-exis-proof
;;  (var exp)
;;  (if
;;   (z-ifp exp)
;;   (forsome-f-if-case-proof var
;;                            (z-test exp)
;;                            (make-term-z-if var (z-left exp))
;;                            (make-term-z-if var (z-right exp))
;;                            (tautconseq-proof (list (forsome var
;;                                                             (make-term-z-if var (z-left exp))))
;;                                              (f-implies (z-test exp)
;;                                                         (forsome var
;;                                                                  (make-term-z-if var
;;                                                                                  (z-left exp))))
;;                                              (list (term-z-if-exis-proof var (z-left exp))))
;;                            (tautconseq-proof (list (forsome var
;;                                                             (make-term-z-if var (z-right exp))))
;;                                              (f-implies (f-not (z-test exp))
;;                                                         (forsome var
;;                                                                  (make-term-z-if var
;;                                                                                  (z-right exp))))
;;                                              (list (term-z-if-exis-proof var (z-right exp)))))
;;   (exis-fun-intro-proof var exp)))
;; (defthm formula-make-term-z-if

;;              (implies (and (term-z-if exp var symbols)
;;                            (g-variable var))
;;                       (g-formula (make-term-z-if var exp) symbols)))
;; ;; many of the functions are defined as formulas constructed from
;; ;; term-if-trees generated by the z-if shell.  the lemma below is used to
;; ;; carry out the existence part of the admissibility of such definitions.
;; ;; the crucial part in the proof of this lemma is the observation that
;; ;; if "value" is not free in test, then from
;; ;;  "(if test (forsome value expl) (forsome value expr))",
;; ;; we can derive "(forsome value (if test expl expr))".
;; (defthm term-z-if-exis-proof-proves

;;              (implies (and (g-variable var)
;;                            (term-z-if exp var symbols))
;;                       (proves (term-z-if-exis-proof var exp)
;;                               (forsome var (make-term-z-if var exp))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0761 term-z-if-exis-proof t)
;; (defthm term-z-if-exis-proof-proves1

;;              (implies (and (g-variable var)
;;                            (term-z-if exp var symbols)
;;                            (equal concl (forsome var (make-term-z-if var exp))))
;;                       (proves (term-z-if-exis-proof var exp) concl given defns symbols))
;;              ((use (term-z-if-exis-proof-proves))))
;; (toggle g0762 term-z-if-exis-proof-proves t)
;; ;; we would now like to show for example that the definition of "z-consp"
;; ;; does in fact make it the z2 analogue of the lisp function consp.
;; ;; that is |- "((z-consp <x>) = <(bool-fix (consp x))>)",
;; ;; where bool-fix converts nil to 0, and t to 1.  again, we overload the notation
;; ;; by permitting lisp functions within quotes to denote their values.
;; ;; the predicate proves-z-if
;; ;; requires careful explanation.  its first argument pf-tree is a proof-tree
;; ;; that mimics the structure of the if-tree exp.  a proof-tree is of the
;; ;; form:  <<cond proof1 proof2> proof-tree-left proof-tree-right>.
;; ;; proves-z-if checks that when exp is of the form (z-if test left right),
;; ;; then if cond is t, proof1 is a proof of test, and proof-tree-left is
;; ;; the proof-tree corresponding to left; and if cond is f, then proof2 is
;; ;; a proof of the negation of test, and proof-tree-right is the proof-tree
;; ;; corresponding to right.  in the base case, proves-z-if checks that pf-tree
;; ;; is a proof of "(exp = val)".  once this has been checked, we can later evaluate
;; ;; the term-if-tree in terms of the values of the leaf nodes by constructing the
;; ;; appropriate proof-tree.
;; (defun proves-z-if
;;       (pf-tree exp var val given defns symbols)
;;       (if (z-ifp exp)
;;           (if (caar pf-tree)
;;               (and (proves (cadar pf-tree) (z-test exp) given defns symbols)
;;                    (proves-z-if (cadr pf-tree) (z-left exp) var val given defns symbols))
;;               (and (proves (caddar pf-tree) (f-not (z-test exp)) given defns symbols)
;;                    (proves-z-if (caddr pf-tree) (z-right exp) var val given defns symbols)))
;;           (proves pf-tree (f-equal exp val) given defns symbols)))
;; (defun z-if-eval-proof
;;       (pf-tree exp var val)
;;       (if (z-ifp exp)
;;           (if (caar pf-tree)
;;               (chain-proof (make-term-z-if var exp)
;;                            (f-equal var val)
;;                            (list (make-term-z-if var (z-left exp)))
;;                            (list (f-if-elim-proof1 (z-test exp)
;;                                                    (make-term-z-if var (z-left exp))
;;                                                    (make-term-z-if var (z-right exp))
;;                                                    (cadar pf-tree))
;;                                  (z-if-eval-proof (cadr pf-tree) (z-left exp) var val)))
;;               (chain-proof (make-term-z-if var exp)
;;                            (f-equal var val)
;;                            (list (make-term-z-if var (z-right exp)))
;;                            (list (f-if-elim-proof2 (z-test exp)
;;                                                    (make-term-z-if var (z-left exp))
;;                                                    (make-term-z-if var (z-right exp))
;;                                                    (caddar pf-tree))
;;                                  (z-if-eval-proof (caddr pf-tree) (z-right exp) var val))))
;;           (detach-proof (f-equal exp val)
;;                         (f-implies (f-equal var exp) (f-equal var val))
;;                         pf-tree
;;                         (detach-proof (f-equal var var)
;;                                       (f-implies (f-equal exp val)
;;                                                  (f-implies (f-equal var exp)
;;                                                             (f-equal var val)))
;;                                       (ident-axiom-proof var)
;;                                       (equal-axiom2-proof (p 0 2)
;;                                                           (list var exp)
;;                                                           (list var val))))))
;; (defthm formula-make-term-z-if-again

;;              (implies (and (term-z-if exp var symbols)
;;                            (g-termp var 0 symbols))
;;                       (g-formula (make-term-z-if var exp) symbols)))
;; ;; if each leaf term "exp" in exp has val
;; ;; as its value (this is checked by proves-z-if), then the if-expression
;; ;; which has "(var = exp)" for each leaf term "exp" in exp can be proved
;; ;; to imply "(var = val)".
;; (defthm z-if-eval-proof-proves

;;              (implies (and (term-z-if exp var symbols)
;;                            (g-termp (list var val) 1 symbols)
;;                            (proves-z-if pf-tree exp var val given defns symbols))
;;                       (proves (z-if-eval-proof pf-tree exp var val)
;;                               (f-implies (make-term-z-if var exp) (f-equal var val))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0765 z-if-eval-proof t)
;; (defun z-if-eval-proof1
;;       (pf-tree exp var val pf)
;;       (detach-proof (make-term-z-if var exp)
;;                     (f-equal var val)
;;                     pf
;;                     (z-if-eval-proof pf-tree exp var val)))
;; (defthm z-if-eval-proof-proves1

;;              (implies (and (term-z-if exp var symbols)
;;                            (g-termp (list var val) 1 symbols)
;;                            (proves-z-if pf-tree exp var val given defns symbols)
;;                            (proves pf (make-term-z-if var exp) given defns symbols))
;;                       (proves (z-if-eval-proof1 pf-tree exp var val pf)
;;                               (f-equal var val)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0766 z-if-eval-proof1 t)
;; (defun stack-and-implies (exp hyps) (if (consp hyps) (f-implies (list-f-and hyps) exp) exp))
;; (defun form-z-if-exis-step-proof
;;       (test left right var tests pf1 pf2)
;;       (tautconseq-proof (list (stack-and-implies (forsome var left) (cons test tests))
;;                               (stack-and-implies (forsome var right) (cons (f-not test) tests))
;;                               (f-implies (f-if test (forsome var left) (forsome var right))
;;                                          (forsome var (f-if test left right))))
;;                         (stack-and-implies (forsome var (f-if test left right)) tests)
;;                         (list pf1 pf2 (forsome-f-if-proof var test left right))))
;; ;; in the definitions which use term-if-trees, the existence and uniqueness of the
;; ;; object being defined follows from that of the leaf terms.  there are other
;; ;; definitions where the leaf nodes of the if-trees are formulas (a `form-if-tree'),
;; ;; and the existence/uniqueness of the defined object in each leaf node case requires
;; ;; the conjunction of the tests leading up to it.  the definition of "(z-car x)",
;; ;;                "(if (forsome y (forsome z (x = <y z>)))
;; ;;                  then (forsome z (x = <(z-car x), z>))
;; ;;                  else ((z-car x) = |0|))".
;; ;; is a good example of this.  the lemma below combines the
;; ;; existence proofs in each of the left/right cases to form the existence proof
;; ;; for the if-subtree rooted at the corresponding test node.
;; (defthm form-z-if-exis-step-proof-proves

;;              (implies (and (g-variable var)
;;                            (not (member var (collect-free test 0)))
;;                            (proves pf1
;;                                    (stack-and-implies (forsome var left) (cons test tests))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (proves pf2
;;                                    (stack-and-implies (forsome var right)
;;                                                       (cons (f-not test) tests))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl
;;                                   (stack-and-implies (forsome var (f-if test left right)) tests)))
;;                       (proves (form-z-if-exis-step-proof test left right var tests pf1 pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1)
;;                                       (exp (stack-and-implies (forsome var left)
;;                                                               (cons test tests))))
;;                    (proves-is-formula (pf pf2)
;;                                       (exp (stack-and-implies (forsome var right)
;;                                                               (cons (f-not test) tests)))))
;;               ))
;; (toggle g0769 form-z-if-exis-step-proof t)
;; ;; form-z-if checks if exp is a form-if-tree.
;; (defun form-z-if
;;       (exp symbols)
;;       (if (z-ifp exp)
;;           (and (g-formula (z-test exp) symbols)
;;                (form-z-if (z-left exp) symbols)
;;                (form-z-if (z-right exp) symbols))
;;           (g-formula exp symbols)))
;; ;; make-form-z-if returns the if-expression represented by the form-if-tree exp.
;; (defun make-form-z-if
;;       (exp)
;;       (if (z-ifp exp)
;;           (f-if (z-test exp) (make-form-z-if (z-left exp)) (make-form-z-if (z-right exp)))
;;           exp))
;; ;; proves-form-z-if-exis checks that for every leaf formula in the form-if-tree exp,
;; ;; pf-tree contains a corresponding proof that the conjunction of the tests leading
;; ;; to that leaf node "exp" implies "(forsome var exp)".
;; (defun proves-form-z-if-exis
;;       (pf-tree exp var tests given defns symbols)
;;       (if (z-ifp exp)
;;           (and (not (member var (collect-free (z-test exp) 0)))
;;                (proves-form-z-if-exis (car pf-tree)
;;                                       (z-left exp)
;;                                       var
;;                                       (cons (z-test exp) tests)
;;                                       given
;;                                       defns
;;                                       symbols)
;;                (proves-form-z-if-exis (cadr pf-tree)
;;                                       (z-right exp)
;;                                       var
;;                                       (cons (f-not (z-test exp)) tests)
;;                                       given
;;                                       defns
;;                                       symbols))
;;           (proves pf-tree (stack-and-implies (forsome var exp) tests) given defns symbols)))
;; (defun form-z-if-exis-proof
;;       (pf-tree exp var tests)
;;       (if (z-ifp exp)
;;           (form-z-if-exis-step-proof (z-test exp)
;;                                      (make-form-z-if (z-left exp))
;;                                      (make-form-z-if (z-right exp))
;;                                      var
;;                                      tests
;;                                      (form-z-if-exis-proof (car pf-tree)
;;                                                            (z-left exp)
;;                                                            var
;;                                                            (cons (z-test exp) tests))
;;                                      (form-z-if-exis-proof (cadr pf-tree)
;;                                                            (z-right exp)
;;                                                            var
;;                                                            (cons (f-not (z-test exp)) tests)))
;;           pf-tree))
;; (defthm formula-make-form

;;              (implies (form-z-if exp symbols) (g-formula (make-form-z-if exp) symbols)))
;; ;; the lemma below demonstrates that the existence proofs for the leaf nodes
;; ;; can be combined to give the existence proof for the if-expression represented
;; ;; by the form-if-tree exp.
;; (defthm form-z-if-exis-proof-proves

;;              (implies (and (form-z-if exp symbols)
;;                            (g-variable var)
;;                            (proves-form-z-if-exis pf-tree exp var tests given defns symbols))
;;                       (proves (form-z-if-exis-proof pf-tree exp var tests)
;;                               (stack-and-implies (forsome var (make-form-z-if exp)) tests)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0770 form-z-if-exis-proof t)
;; (defthm form-z-if-exis-proof-proves1

;;              (implies (and (form-z-if exp symbols)
;;                            (g-variable var)
;;                            (proves-form-z-if-exis pf-tree exp var tests given defns symbols)
;;                            (equal concl
;;                                   (stack-and-implies (forsome var (make-form-z-if exp)) tests)))
;;                       (proves (form-z-if-exis-proof pf-tree exp var tests)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (form-z-if-exis-proof-proves))))
;; (toggle g0784 form-z-if-exis-proof-proves t)
;; ;; next we show how definitions represented by form-if-trees are evaluated.
;; ;; proves-form-z-if-eval is the form-if-tree analogue of proves-z-if.
;; ;; the only difference is that in the base case, proves-form-z-if-eval
;; ;; checks if pf-tree is a proof of "(exp -> (lhs = val))".
;; (defun proves-form-z-if-eval
;;       (pf-tree exp lhs val given defns symbols)
;;       (if (z-ifp exp)
;;           (if (caar pf-tree)
;;               (and (proves (cadar pf-tree) (z-test exp) given defns symbols)
;;                    (proves-form-z-if-eval (cadr pf-tree)
;;                                           (z-left exp)
;;                                           lhs
;;                                           val
;;                                           given
;;                                           defns
;;                                           symbols))
;;               (and (proves (caddar pf-tree) (f-not (z-test exp)) given defns symbols)
;;                    (proves-form-z-if-eval (caddr pf-tree)
;;                                           (z-right exp)
;;                                           lhs
;;                                           val
;;                                           given
;;                                           defns
;;                                           symbols)))
;;           (proves pf-tree (f-implies exp (f-equal lhs val)) given defns symbols)))
;; (defun form-z-if-eval-proof
;;       (pf-tree exp lhs val)
;;       (if (z-ifp exp)
;;           (if (caar pf-tree)
;;               (chain-proof (make-form-z-if exp)
;;                            (f-equal lhs val)
;;                            (list (make-form-z-if (z-left exp)))
;;                            (list (f-if-elim-proof1 (z-test exp)
;;                                                    (make-form-z-if (z-left exp))
;;                                                    (make-form-z-if (z-right exp))
;;                                                    (cadar pf-tree))
;;                                  (form-z-if-eval-proof (cadr pf-tree) (z-left exp) lhs val)))
;;               (chain-proof (make-form-z-if exp)
;;                            (f-equal lhs val)
;;                            (list (make-form-z-if (z-right exp)))
;;                            (list (f-if-elim-proof2 (z-test exp)
;;                                                    (make-form-z-if (z-left exp))
;;                                                    (make-form-z-if (z-right exp))
;;                                                    (caddar pf-tree))
;;                                  (form-z-if-eval-proof (caddr pf-tree) (z-right exp) lhs val))))
;;           pf-tree))
;; (defthm form-z-if-eval-proof-proves

;;              (implies (and (form-z-if exp symbols)
;;                            (g-termp (list lhs val) 1 symbols)
;;                            (proves-form-z-if-eval pf-tree exp lhs val given defns symbols))
;;                       (proves (form-z-if-eval-proof pf-tree exp lhs val)
;;                               (f-implies (make-form-z-if exp) (f-equal lhs val))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0785 form-z-if-eval-proof t)
;; (defun form-z-if-eval-proof1
;;       (pf-tree exp lhs val pf)
;;       (detach-proof (make-form-z-if exp)
;;                     (f-equal lhs val)
;;                     pf
;;                     (form-z-if-eval-proof pf-tree exp lhs val)))
;; ;; now we can show that if we have a proof-tree satisfying proves-form-z-if-eval,
;; ;; then we can prove that the function can be evaluated as desired, e.g.,
;; ;; we can show that "((z-car <x>) = <(car x)>)".
;; (defthm form-z-if-eval-proof-proves1

;;              (implies (and (form-z-if exp symbols)
;;                            (g-termp (list lhs val) 1 symbols)
;;                            (proves-form-z-if-eval pf-tree exp lhs val given defns symbols)
;;                            (proves pf (make-form-z-if exp) given defns symbols))
;;                       (proves (form-z-if-eval-proof1 pf-tree exp lhs val pf)
;;                               (f-equal lhs val)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0786 form-z-if-eval-proof1 t)
;; (defthm atom-nil-intersect (implies (atom y) (nil-intersect x y)))
;; (defthm not-free-free-for

;;              (implies (atom (collect-free term 0)) (free-for exp var term flg)))
;; (defthm consp-append

;;              (equal (consp (g-append x y))
;;                     (or (consp x)
;;                         (consp y))))
;; (toggle g0666 free-for t)
;; (defthm not-free-for-list

;;              (implies (atom (collect-free termlist 1)) (free-for-list exp varlist termlist)))
;; (toggle g0671 free-for-list t)
;; (toggle g0680 consp-append t)
;; (defun consp-cond-proof1
;;       (x y)
;;       (detach-proof (f-equal (z-opair x y) (z-opair x y))
;;                     (forsome 1 (forsome 2 (f-equal (z-opair x y) (z-opair 1 2))))
;;                     (ident-axiom-proof (z-opair x y))
;;                     (subst-thm-a-proof (f-equal (z-opair x y) (z-opair 1 2))
;;                                        (list 1 2)
;;                                        (list x y))))
;; (defthm consp-cond-proof1-proves

;;              (implies (and (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 2 1) (p 1 2) (fn 0 0))
;;                                    symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (g-termp (list x y) 1 symbols)
;;                            (equal (collect-free x 0) nil)
;;                            (equal (collect-free y 0) nil))
;;                       (proves (consp-cond-proof1 x y)
;;                               (forsome 1 (forsome 2 (f-equal (z-opair x y) (z-opair 1 2))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0685 consp-cond-proof1 t)
;; (defn
;;  numeral-not-consp-proof
;;  (n x y u v)
;;  (f-iff-mp-proof2
;;   (f-not (forsome x (forsome y (f-equal (numeral n) (z-opair u v)))))
;;   (forall x (f-not (forsome y (f-equal (numeral n) (z-opair u v)))))
;;   (forsome-forall-proof x (forsome y (f-equal (numeral n) (z-opair u v))))
;;   (generalise-proof x
;;                     (f-not (forsome y (f-equal (numeral n) (z-opair u v))))
;;                     (f-iff-mp-proof2 (f-not (forsome y (f-equal (numeral n) (z-opair u v))))
;;                                      (forall y (f-not (f-equal (numeral n) (z-opair u v))))
;;                                      (forsome-forall-proof y
;;                                                            (f-equal (numeral n) (z-opair u v)))
;;                                      (generalise-proof y
;;                                                        (f-not (f-equal (numeral n)
;;                                                                        (z-opair u v)))
;;                                                        (list-num-nequal-proof n u v))))))
;; ;; no numeral is an ordered pair.
;; (defthm numeral-not-consp-proof-proves

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 2 1) (p 1 2) (fn 0 0))
;;                                    symbols)
;;                            (z-int-hyps defns symbols)
;;                            (var-list (list x y u v) 4)
;;                            (equal n-bar (numeral n)))
;;                       (proves (numeral-not-consp-proof n x y u v)
;;                               (f-not (forsome x (forsome y (f-equal n-bar (z-opair u v)))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0693 numeral-not-consp-proof t)
;; (defn
;;  z-car-ncode-proof
;;  (x)
;;  (form-z-if-eval-proof1
;;   (list (list (consp x)
;;               (consp-cond-proof1 (ncode (car x)) (ncode (cdr x)))
;;               (numeral-not-consp-proof x 1 2 1 2))
;;         (forsome-intro-proof 2
;;                              (f-equal (z-opair (ncode (car x)) (ncode (cdr x)))
;;                                       (z-opair (z-car (ncode x)) 2))
;;                              (f-equal (z-car (ncode x)) (ncode (car x)))
;;                              (chain-proof (f-equal (z-opair (ncode (car x)) (ncode (cdr x)))
;;                                                    (z-opair (z-car (ncode x)) 2))
;;                                           (f-equal (z-car (ncode x)) (ncode (car x)))
;;                                           (list (f-equal (ncode (car x)) (z-car (ncode x))))
;;                                           (list (z-car-unique-proof (ncode (car x))
;;                                                                     (ncode (cdr x))
;;                                                                     (z-car (ncode x))
;;                                                                     2)
;;                                                 (symmetry-proof1 (ncode (car x))
;;                                                                  (z-car (ncode x))))))
;;         (prop-axiom-proof (f-equal (z-car (ncode x)) (phi))))
;;   (z-if (forsome 1 (forsome 2 (f-equal (ncode x) (z-opair 1 2))))
;;         (forsome 2 (f-equal (ncode x) (z-opair (z-car (ncode x)) 2)))
;;         (f-equal (z-car (ncode x)) (phi)))
;;   (z-car (ncode x))
;;   (ncode (car x))
;;   (z-car-defn-proof (ncode x))))
;; ;; form-z-if-eval-proof-proves1 is used to prove that "(z-car x)" is
;; ;; the z2 analogue of car, in the lemma below.
;; (defthm z-car-ncode-proof-proves

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 2 1)
;;                                          (p 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (equal concl (f-equal (z-car (ncode x)) (ncode (car x)))))
;;                       (proves (z-car-ncode-proof x) concl given defns symbols)))
;; (toggle g0691 z-car-ncode-proof t)
;; (defun consp-cond-proof2
;;       (x y)
;;       (detach-proof (f-equal (z-opair x y) (z-opair x y))
;;                     (forsome 2 (forsome 1 (f-equal (z-opair x y) (z-opair 1 2))))
;;                     (ident-axiom-proof (z-opair x y))
;;                     (subst-thm-a-proof (f-equal (z-opair x y) (z-opair 1 2))
;;                                        (list 2 1)
;;                                        (list y x))))
;; (defthm consp-cond-proof2-proves

;;              (implies (and (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 2 1) (p 1 2) (fn 0 0))
;;                                    symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (g-termp (list x y) 1 symbols)
;;                            (equal (collect-free x 0) nil)
;;                            (equal (collect-free y 0) nil))
;;                       (proves (consp-cond-proof2 x y)
;;                               (forsome 2 (forsome 1 (f-equal (z-opair x y) (z-opair 1 2))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0692 consp-cond-proof2 t)
;; (defn
;;  z-cdr-ncode-proof
;;  (x)
;;  (form-z-if-eval-proof1
;;   (list (list (consp x)
;;               (consp-cond-proof2 (ncode (car x)) (ncode (cdr x)))
;;               (numeral-not-consp-proof x 2 1 1 2))
;;         (forsome-intro-proof 1
;;                              (f-equal (z-opair (ncode (car x)) (ncode (cdr x)))
;;                                       (z-opair 1 (z-cdr (ncode x))))
;;                              (f-equal (z-cdr (ncode x)) (ncode (cdr x)))
;;                              (chain-proof (f-equal (z-opair (ncode (car x)) (ncode (cdr x)))
;;                                                    (z-opair 1 (z-cdr (ncode x))))
;;                                           (f-equal (z-cdr (ncode x)) (ncode (cdr x)))
;;                                           (list (f-equal (ncode (cdr x)) (z-cdr (ncode x))))
;;                                           (list (z-cdr-unique-proof (ncode (car x))
;;                                                                     (ncode (cdr x))
;;                                                                     1
;;                                                                     (z-cdr (ncode x)))
;;                                                 (symmetry-proof1 (ncode (cdr x))
;;                                                                  (z-cdr (ncode x))))))
;;         (prop-axiom-proof (f-equal (z-cdr (ncode x)) (phi))))
;;   (z-if (forsome 2 (forsome 1 (f-equal (ncode x) (z-opair 1 2))))
;;         (forsome 1 (f-equal (ncode x) (z-opair 1 (z-cdr (ncode x)))))
;;         (f-equal (z-cdr (ncode x)) (phi)))
;;   (z-cdr (ncode x))
;;   (ncode (cdr x))
;;   (z-cdr-defn-proof (ncode x))))
;; ;; "(z-cdr x)" is the z2 analogue of cdr.
;; (defthm z-cdr-ncode-proof-proves

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 5 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 2 1)
;;                                          (p 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (equal concl (f-equal (z-cdr (ncode x)) (ncode (cdr x)))))
;;                       (proves (z-cdr-ncode-proof x) concl given defns symbols)))
;; (toggle g0694 z-cdr-ncode-proof t)
;; (defthm col-free-z-car (equal (collect-free (z-car x) 0) (collect-free (list x) 1)))
;; (defthm covering-z-car (equal (covering (z-car x) var 0) (covering (list x) var 1)))
;; (defthm subst-z-car

;;              (equal (g-subst (z-car x) var term 0) (z-car (g-subst x var term 0))))
;; (defthm parallel-subst-z-car

;;              (equal (parallel-subst (z-car x) vars terms 0)
;;                     (z-car (parallel-subst x vars terms 0))))
;; (defthm termp-z-car

;;              (equal (g-termp (z-car x) 0 symbols)
;;                     (and (member (fn 4 1) symbols)
;;                          (g-termp x 0 symbols))))
;; (toggle g0696 z-car t)
;; (defthm col-free-z-cdr (equal (collect-free (z-cdr x) 0) (collect-free (list x) 1)))
;; (defthm covering-z-cdr (equal (covering (z-cdr x) var 0) (covering (list x) var 1)))
;; (defthm subst-z-cdr

;;              (equal (g-subst (z-cdr x) var term 0) (z-cdr (g-subst x var term 0))))
;; (defthm parallel-subst-z-cdr

;;              (equal (parallel-subst (z-cdr x) vars terms 0)
;;                     (z-cdr (parallel-subst x vars terms 0))))
;; (defthm termp-z-cdr

;;              (equal (g-termp (z-cdr x) 0 symbols)
;;                     (and (member (fn 5 1) symbols)
;;                          (g-termp x 0 symbols))))
;; (toggle g0697 z-cdr t)
;; (defun term-z-if-unique-proof
;;       (x y exp)
;;       (if (z-ifp exp)
;;           (unique-f-if-proof (z-test exp)
;;                              (make-term-z-if x (z-left exp))
;;                              (make-term-z-if y (z-left exp))
;;                              (make-term-z-if x (z-right exp))
;;                              (make-term-z-if y (z-right exp))
;;                              (f-equal x y)
;;                              (term-z-if-unique-proof x y (z-left exp))
;;                              (term-z-if-unique-proof x y (z-right exp)))
;;           (unique-fun-intro-proof x y exp)))
;; ;; the uniqueness part of the admissibility proofs for definitions constructed
;; ;; by term-if-trees follows from the uniqueness proofs of the leaf nodes.
;; ;; the lemma below proves that any definition constructed by a term-if-tree
;; ;; automatically has the uniqueness property, since terms represent unique values.
;; (defthm term-z-if-unique-proof-proves

;;              (implies (and (term-z-if exp x symbols)
;;                            (term-z-if exp y symbols)
;;                            (var-list (list x y) 2))
;;                       (proves (term-z-if-unique-proof x y exp)
;;                               (f-implies (f-and (make-term-z-if x exp) (make-term-z-if y exp))
;;                                          (f-equal x y))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0695 term-z-if-unique-proof t)
;; (defthm term-z-if-unique-proof-proves1

;;              (implies (and (term-z-if exp x symbols)
;;                            (term-z-if exp y symbols)
;;                            (var-list (list x y) 2)
;;                            (equal concl
;;                                   (f-implies (f-and (make-term-z-if x exp)
;;                                                     (make-term-z-if y exp))
;;                                              (f-equal x y))))
;;                       (proves (term-z-if-unique-proof x y exp) concl given defns symbols))
;;              ((use (term-z-if-unique-proof-proves))))
;; (defun z-consp-exis-proof
;;       (x y z)
;;       (term-z-if-exis-proof y
;;                             (z-if (forsome y (forsome z (f-equal x (z-opair y z))))
;;                                   (z-succ (phi))
;;                                   (phi))))
;; (defun z-consp-unique-proof
;;       (x y y1 z)
;;       (term-z-if-unique-proof y
;;                               y1
;;                               (z-if (forsome y (forsome z (f-equal x (z-opair y z))))
;;                                     (z-succ (phi))
;;                                     (phi))))
;; ;; the definition for "(z-consp x)".
;; (defun z-consp-defn
;;       (x y y1 z1)
;;       (f-if (forsome y1 (forsome z1 (f-equal x (z-opair y1 z1))))
;;             (f-equal y (z-succ (phi)))
;;             (f-equal y (phi))))
;; (defun bool-fix (x) (if x 1 0))
;; ;; the expression representing "(z-consp x)".
;; (defun z-consp (x) (list (fn 6 1) x))
;; ;; the admissibility proof for "(z-consp x)".
;; (defun z-consp-defn-proof
;;       (term)
;;       (subst-rule-proof (z-consp-defun 0 (z-consp 0) 1 2)
;;                         0
;;                         term
;;                         (fun-defn-proof (fn 6 1)
;;                                         (list 0)
;;                                         1
;;                                         3
;;                                         (z-consp-defun 0 1 1 2)
;;                                         (z-consp-exis-proof 0 1 2)
;;                                         (z-consp-unique-proof 0 1 3 2))))
;; ;; defns must contain the definition of "z-consp" associated with the
;; ;; function symbol for "z-consp" and the functions used to define
;; ;; "z-consp" must follow "z-consp" in symbols.
;; (defun z-consp-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 6 1) defns) (z-consp-defun 0 (z-consp 0) 1 2))
;;            (subset (list (fn 3 1) (fn 1 2) (fn 0 0)) (rest-of (fn 6 1) symbols))))
;; (toggle g0699 free-for nil)
;; ;; the definition for "z-consp" is proved to be admissible in the lemma below.
;; (defthm z-consp-defn-proof-proves

;;              (implies (and (subset (list (fn 6 1) (fn 3 1) (fn 1 2) (fn 0 0)) symbols)
;;                            (z-consp-hyps defns symbols)
;;                            (g-termp term 0 symbols)
;;                            (equal (collect-free term 0) nil)
;;                            (equal concl (z-consp-defun term (z-consp term) 1 2)))
;;                       (proves (z-consp-defn-proof term) concl given defns symbols)))
;; (toggle g0703 z-consp-defn-proof t)
;; (toggle g0706 z-consp-hyps t)
;; (defun z-consp-ncode-proof
;;       (x)
;;       (z-if-eval-proof1 (list (list (consp x)
;;                                     (consp-cond-proof1 (ncode (car x)) (ncode (cdr x)))
;;                                     (numeral-not-consp-proof x 1 2 1 2))
;;                               (ident-axiom-proof (z-succ (phi)))
;;                               (ident-axiom-proof (phi)))
;;                         (z-if (forsome 1 (forsome 2 (f-equal (ncode x) (z-opair 1 2))))
;;                               (z-succ (phi))
;;                               (phi))
;;                         (z-consp (ncode x))
;;                         (ncode (bool-fix (consp x)))
;;                         (z-consp-defn-proof (ncode x))))
;; ;; |- "((z-consp <x>) = <(bool-fix (consp x))>)".
;; (defthm z-consp-ncode-proof-proves

;;              (implies (and (subset (list (fn 6 1)
;;                                          (fn 3 1)
;;                                          (p 2 1)
;;                                          (p 1 2)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-consp-hyps defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-consp (ncode x)) (ncode (bool-fix (consp x))))))
;;                       (proves (z-consp-ncode-proof x) concl given defns symbols))
;;              ((disable free-for)))
;; (toggle g0711 z-consp-ncode-proof t)
;; ;; a similar sequence of events for "(z-add1 x)", the z2 analogue of add1.
;; (defun z-add1-exis-proof
;;       (x y z)
;;       (term-z-if-exis-proof y
;;                             (z-if (forsome y (forsome z (f-equal x (z-opair y z))))
;;                                   (z-succ (phi))
;;                                   (z-succ x))))
;; (defun z-add1-unique-proof
;;       (x y y1 z)
;;       (term-z-if-unique-proof y
;;                               y1
;;                               (z-if (forsome y (forsome z (f-equal x (z-opair y z))))
;;                                     (z-succ (phi))
;;                                     (z-succ x))))
;; (defun z-add1-defn
;;       (x y y1 z1)
;;       (f-if (forsome y1 (forsome z1 (f-equal x (z-opair y1 z1))))
;;             (f-equal y (z-succ (phi)))
;;             (f-equal y (z-succ x))))
;; (defun z-add1 (x) (list (fn 7 1) x))
;; (defun z-add1-defn-proof
;;       (term)
;;       (subst-rule-proof (z-add1-defun 0 (z-add1 0) 1 2)
;;                         0
;;                         term
;;                         (fun-defn-proof (fn 7 1)
;;                                         (list 0)
;;                                         1
;;                                         3
;;                                         (z-add1-defun 0 1 1 2)
;;                                         (z-add1-exis-proof 0 1 2)
;;                                         (z-add1-unique-proof 0 1 3 2))))
;; (defun z-add1-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 7 1) defns) (z-add1-defun 0 (z-add1 0) 1 2))
;;            (subset (list (fn 3 1) (fn 1 2) (fn 0 0)) (rest-of (fn 7 1) symbols))))
;; (defthm z-add1-defn-proof-proves

;;              (implies (and (subset (list (fn 7 1) (fn 3 1) (fn 1 2) (fn 0 0)) symbols)
;;                            (z-add1-hyps defns symbols)
;;                            (g-termp term 0 symbols)
;;                            (equal (collect-free term 0) nil)
;;                            (equal concl (z-add1-defun term (z-add1 term) 1 2)))
;;                       (proves (z-add1-defn-proof term) concl given defns symbols)))
;; (toggle g0712 z-add1-defn-proof t)
;; (toggle g0713 z-add1-hyps t)
;; (defun z-add1-ncode-proof
;;       (x)
;;       (z-if-eval-proof1 (list (list (consp x)
;;                                     (consp-cond-proof1 (ncode (car x)) (ncode (cdr x)))
;;                                     (numeral-not-consp-proof x 1 2 1 2))
;;                               (ident-axiom-proof (z-succ (phi)))
;;                               (ident-axiom-proof (z-succ (ncode x))))
;;                         (z-if (forsome 1 (forsome 2 (f-equal (ncode x) (z-opair 1 2))))
;;                               (z-succ (phi))
;;                               (z-succ (ncode x)))
;;                         (z-add1 (ncode x))
;;                         (ncode (add1 x))
;;                         (z-add1-defn-proof (ncode x))))
;; (defthm z-add1-ncode-proof-proves

;;              (implies (and (subset (list (fn 7 1)
;;                                          (fn 3 1)
;;                                          (p 2 1)
;;                                          (p 1 2)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-add1-hyps defns symbols)
;;                            (equal concl (f-equal (z-add1 (ncode x)) (ncode (add1 x)))))
;;                       (proves (z-add1-ncode-proof x) concl given defns symbols))
;;              ((disable free-for)))
;; (toggle g0714 z-add1-ncode-proof t)
;; ;; the sequence of events introducing "(z-acl2-numberp x)", the z2 analogue of acl2-numberp.
;; (defun z-acl2-numberp-defun (x y) (f-if (z-int x) (f-equal y (z-succ (phi))) (f-equal y (phi))))
;; (defun z-acl2-numberp-exis-proof (x y) (term-z-if-exis-proof y (z-if (z-int x) (z-succ (phi)) (phi))))
;; (defun z-acl2-numberp-unique-proof
;;       (x y y1)
;;       (term-z-if-unique-proof y y1 (z-if (z-int x) (z-succ (phi)) (phi))))
;; (defun z-acl2-numberp (x) (list (fn 8 1) x))
;; (defun z-acl2-numberp-defn-proof
;;       (term)
;;       (subst-rule-proof (z-acl2-numberp-defun 0 (z-acl2-numberp 0))
;;                         0
;;                         term
;;                         (fun-defn-proof (fn 8 1)
;;                                         (list 0)
;;                                         1
;;                                         2
;;                                         (z-acl2-numberp-defun 0 1)
;;                                         (z-acl2-numberp-exis-proof 0 1)
;;                                         (z-acl2-numberp-unique-proof 0 1 2))))
;; (defun z-acl2-numberp-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 8 1) defns) (z-acl2-numberp-defun 0 (z-acl2-numberp 0)))
;;            (subset (list (fn 3 1) (p 2 1) (fn 0 0)) (rest-of (fn 8 1) symbols))))
;; (toggle g0716 z-int nil)
;; (defthm collect-free-z-int

;;              (equal (collect-free (z-int x) 0) (collect-free (list x) 1)))
;; (toggle g0717 z-int t)
;; (defthm z-acl2-numberp-defn-proof-proves

;;              (implies (and (subset (list (fn 8 1) (fn 3 1) (p 2 1) (fn 0 0)) symbols)
;;                            (z-acl2-numberp-hyps defns symbols)
;;                            (g-termp term 0 symbols)
;;                            (equal (collect-free term 0) nil)
;;                            (equal concl (z-acl2-numberp-defun term (z-acl2-numberp term))))
;;                       (proves (z-acl2-numberp-defn-proof term) concl given defns symbols)))
;; (toggle g0725 z-acl2-numberp-defn-proof t)
;; (toggle g0726 z-acl2-numberp-hyps t)
;; (defun z-acl2-numberp-ncode-proof
;;       (x)
;;       (z-if-eval-proof1 (list (list (not (consp x))
;;                                     (z-int-numeral-proof x)
;;                                     (not-int-opair-proof (ncode (car x)) (ncode (cdr x)) 0))
;;                               (ident-axiom-proof (z-succ (phi)))
;;                               (ident-axiom-proof (phi)))
;;                         (z-if (z-int (ncode x)) (z-succ (phi)) (phi))
;;                         (z-acl2-numberp (ncode x))
;;                         (ncode (bool-fix (not (consp x))))
;;                         (z-acl2-numberp-defn-proof (ncode x))))
;; (defthm z-int-numeral-proof-proves-again

;;              (implies (and (z-succ-hyps defns symbols)
;;                            (subset (list (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0)) symbols)
;;                            (member (p 2 1) symbols)
;;                            (z-int-hyps defns symbols)
;;                            (equal x-bar (numeral x)))
;;                       (proves (z-int-numeral-proof x) (z-int x-bar) given defns symbols))
;;              ((use (z-int-numeral-proof-proves))))
;; (toggle g0727 z-int-numeral-proof-proves t)
;; (defthm z-acl2-numberp-ncode-proof-proves

;;              (implies (and (subset (list (fn 8 1)
;;                                          (fn 3 1)
;;                                          (p 2 1)
;;                                          (p 1 2)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-acl2-numberp-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-acl2-numberp (ncode x))
;;                                            (ncode (bool-fix (not (consp x)))))))
;;                       (proves (z-acl2-numberp-ncode-proof x) concl given defns symbols)))
;; (toggle g0728 z-acl2-numberp-ncode-proof t)
;; ;; sequence of events introducing "(z-zerop x)", the z2 analogue of zerop.
;; (defun z-zerop-exis-proof
;;       (x y)
;;       (term-z-if-exis-proof y
;;                             (z-if (z-int x)
;;                                   (z-if (f-equal x (phi)) (z-succ (phi)) (phi))
;;                                   (z-succ (phi)))))
;; (defun z-zerop-unique-proof
;;       (x y y1)
;;       (term-z-if-unique-proof y
;;                               y1
;;                               (z-if (z-int x)
;;                                     (z-if (f-equal x (phi)) (z-succ (phi)) (phi))
;;                                     (z-succ (phi)))))
;; (defun z-zerop-defn
;;       (x y)
;;       (f-if (z-int x)
;;             (f-if (f-equal x (phi)) (f-equal y (z-succ (phi))) (f-equal y (phi)))
;;             (f-equal y (z-succ (phi)))))
;; (defun z-zerop (x) (list (fn 9 1) x))
;; (defun z-zerop-defn-proof
;;       (term)
;;       (subst-rule-proof (z-zerop-defun 0 (z-zerop 0))
;;                         0
;;                         term
;;                         (fun-defn-proof (fn 9 1)
;;                                         (list 0)
;;                                         1
;;                                         2
;;                                         (z-zerop-defun 0 1)
;;                                         (z-zerop-exis-proof 0 1)
;;                                         (z-zerop-unique-proof 0 1 2))))
;; (defun z-zerop-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 9 1) defns) (z-zerop-defun 0 (z-zerop 0)))
;;            (subset (list (fn 3 1) (p 2 1) (fn 0 0)) (rest-of (fn 9 1) symbols))))
;; (defthm z-zerop-defn-proof-proves

;;              (implies (and (subset (list (fn 9 1) (fn 3 1) (p 2 1) (fn 0 0)) symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (g-termp term 0 symbols)
;;                            (equal (collect-free term 0) nil)
;;                            (equal concl (z-zerop-defun term (z-zerop term))))
;;                       (proves (z-zerop-defn-proof term) concl given defns symbols)))
;; (toggle g0763 z-zerop-defn-proof t)
;; (toggle g0764 z-zerop-hyps t)
;; (defun z-zerop-ncode-proof
;;       (x)
;;       (z-if-eval-proof1 (list (list (not (consp x))
;;                                     (z-int-numeral-proof x)
;;                                     (not-int-opair-proof (ncode (car x)) (ncode (cdr x)) 0))
;;                               (list (list (zerop x)
;;                                           (ident-axiom-proof (phi))
;;                                           (ncode-nequal-proof x 0))
;;                                     (ident-axiom-proof (z-succ (phi)))
;;                                     (ident-axiom-proof (phi)))
;;                               (ident-axiom-proof (z-succ (phi))))
;;                         (z-if (z-int (ncode x))
;;                               (z-if (f-equal (ncode x) (phi)) (z-succ (phi)) (phi))
;;                               (z-succ (phi)))
;;                         (z-zerop (ncode x))
;;                         (ncode (bool-fix (zerop x)))
;;                         (z-zerop-defn-proof (ncode x))))
;; (defthm z-zerop-ncode-proof-proves

;;              (implies (and (subset (list (fn 9 1)
;;                                          (fn 3 1)
;;                                          (p 2 1)
;;                                          (p 1 2)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-zerop (ncode x)) (ncode (bool-fix (zerop x))))))
;;                       (proves (z-zerop-ncode-proof x) concl given defns symbols)))
;; (toggle g0767 z-zerop-ncode-proof t)
;; (defun form-z-if-unique-proves
;;       (x y exp pftree given defns symbols)
;;       (if (z-ifp exp)
;;           (and (not (member x (collect-free (z-test exp) 0)))
;;                (not (member y (collect-free (z-test exp) 0)))
;;                (form-z-if-unique-proves x y (z-left exp) (car pftree) given defns symbols)
;;                (form-z-if-unique-proves x y (z-right exp) (cdr pftree) given defns symbols))
;;           (proves pftree
;;                   (f-implies (f-and exp (g-subst exp x y 0)) (f-equal x y))
;;                   given
;;                   defns
;;                   symbols)))
;; (defun form-z-if-unique-proof
;;       (x y exp pftree)
;;       (if (z-ifp exp)
;;           (unique-f-if-proof (z-test exp)
;;                              (make-form-z-if (z-left exp))
;;                              (g-subst (make-form-z-if (z-left exp)) x y 0)
;;                              (make-form-z-if (z-right exp))
;;                              (g-subst (make-form-z-if (z-right exp)) x y 0)
;;                              (f-equal x y)
;;                              (form-z-if-unique-proof x y (z-left exp) (car pftree))
;;                              (form-z-if-unique-proof x y (z-right exp) (cdr pftree)))
;;           pftree))
;; (defthm form-z-if-unique-proof-proves

;;              (implies (and (form-z-if exp symbols)
;;                            (var-list (list x y) 2)
;;                            (form-z-if-unique-proves x y exp pftree given defns symbols))
;;                       (proves (form-z-if-unique-proof x y exp pftree)
;;                               (f-implies (f-and (make-form-z-if exp)
;;                                                 (g-subst (make-form-z-if exp) x y 0))
;;                                          (f-equal x y))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0700 form-z-if-eval-proof t)
;; (defthm form-z-if-unique-proof-proves1

;;              (implies (and (form-z-if exp symbols)
;;                            (var-list (list x y) 2)
;;                            (form-z-if-unique-proves x y exp pftree given defns symbols)
;;                            (equal concl
;;                                   (f-implies (f-and (make-form-z-if exp)
;;                                                     (g-subst (make-form-z-if exp) x y 0))
;;                                              (f-equal x y))))
;;                       (proves (form-z-if-unique-proof x y exp pftree) concl given defns symbols)))
;; (toggle g0701 form-z-if-unique-proof-proves t)
;; (defun trans-not-equal-proof
;;       (x y z pf1 pf2)
;;       (tautconseq-proof (list (f-implies (f-equal y x) (f-implies (f-equal y z) (f-equal x z)))
;;                               (f-not (f-equal x z))
;;                               (f-equal y z))
;;                         (f-not (f-equal y x))
;;                         (list (trans-equal-proof1 x y z) pf1 pf2)))
;; (defthm trans-not-equal-proof-proves

;;              (implies (and (proves pf1 (f-not (f-equal x z)) given defns symbols)
;;                            (proves pf2 (f-equal y z) given defns symbols))
;;                       (proves (trans-not-equal-proof x y z pf1 pf2)
;;                               (f-not (f-equal y x))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-not (f-equal x z))))
;;                    (proves-is-formula (pf pf2) (exp (f-equal y z))))
;;               ))
;; (toggle g0840 trans-not-equal-proof t)
;; (defun flip-equals-proof
;;       (x y pf)
;;       (detach-proof (f-equal x y) (f-equal y x) pf (symmetry-proof1 x y)))
;; (defthm flip-equals-proof-proves

;;              (implies (proves pf (f-equal x y) given defns symbols)
;;                       (proves (flip-equals-proof x y pf) (f-equal y x) given defns symbols))
;;              ((use (proves-is-formula (exp (f-equal x y))))))
;; (toggle g0841 flip-equals-proof t)
;; (defun rename-forall-proof
;;       (x y exp)
;;       (forall-intro-proof (forall x exp)
;;                           (g-subst exp x y 0)
;;                           y
;;                           (subst-thm-b-proof exp (list x) (list y))))
;; (toggle g0731 free-for-list nil)
;; (defthm parallel-subst-subst-case

;;              (equal (parallel-subst exp (list x) (list term) flg) (g-subst exp x term flg)))
;; (defthm rename-forall-proof-proves

;;              (implies (and (not (member y (collect-free exp 0)))
;;                            (g-formula exp symbols)
;;                            (free-for exp x y 0)
;;                            (var-set (list x y) 2)
;;                            (equal exp-inst (g-subst exp x y 0)))
;;                       (proves (rename-forall-proof x y exp)
;;                               (f-implies (forall x exp) (forall y exp-inst))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0732 free-for-list t)
;; (toggle g0733 parallel-subst-subst-case t)
;; (toggle g0734 form-z-if-unique-proof t)
;; ;; sequence of events introducing "(z-sub1 x)", the z2 analogue of sub1.
;; (defun z-sub1 (x) (list (fn 10 1) x))
;; (defun z-sub1-defn
;;       (x y z)
;;       (f-if (z-int x)
;;             (f-if (forsome z (f-and (z-int z) (f-equal (z-succ z) x)))
;;                   (f-and (z-int y) (f-equal (z-succ y) x))
;;                   (f-equal y (phi)))
;;             (f-equal y (phi))))
;; (defun z-sub1-expr
;;       (x y z)
;;       (z-if (z-int x)
;;             (z-if (forsome z (f-and (z-int z) (f-equal (z-succ z) x)))
;;                   (f-and (z-int y) (f-equal (z-succ y) x))
;;                   (f-equal y (phi)))
;;             (f-equal y (phi))))
;; (defn
;;  z-sub1-exis-proof
;;  (x y)
;;  (form-z-if-exis-proof
;;   (list (list (tautconseq-proof nil
;;                                 (f-implies (f-and (forsome y
;;                                                            (f-and (z-int y)
;;                                                                   (f-equal (z-succ y) x)))
;;                                                   (z-int x))
;;                                            (forsome y (f-and (z-int y) (f-equal (z-succ y) x))))
;;                                 nil)
;;               (tautconseq-proof (list (forsome y (f-equal y (phi))))
;;                                 (f-implies (f-and (f-not (forsome y
;;                                                                   (f-and (z-int y)
;;                                                                          (f-equal (z-succ y)
;;                                                                                   x))))
;;                                                   (z-int x))
;;                                            (forsome y (f-equal y (phi))))
;;                                 (list (exis-fun-intro-proof y (phi)))))
;;         (tautconseq-proof (list (forsome y (f-equal y (phi))))
;;                           (f-implies (f-not (z-int x)) (forsome y (f-equal y (phi))))
;;                           (list (exis-fun-intro-proof y (phi)))))
;;   (z-sub1-expr x y y)
;;   y
;;   nil))
;; (defun z-int-z-succ-equal-proof
;;       (x y)
;;       (tautconseq-proof (list (f-implies (z-int x) (f-and (z-trans2 x) (z-trich2 x)))
;;                               (f-implies (z-int y) (f-and (z-trans2 y) (z-trich2 y)))
;;                               (f-implies (z-trans2 x)
;;                                          (f-implies (z-trans2 y)
;;                                                     (f-implies (f-equal (z-succ x) (z-succ y))
;;                                                                (f-equal x y)))))
;;                         (f-implies (z-int x)
;;                                    (f-implies (z-int y)
;;                                               (f-implies (f-equal (z-succ x) (z-succ y))
;;                                                          (f-equal x y))))
;;                         (list (iff-split-proof1 (z-int x)
;;                                                 (f-and (z-trans2 x) (z-trich2 x))
;;                                                 (z-int-defn-proof x))
;;                               (iff-split-proof1 (z-int y)
;;                                                 (f-and (z-trans2 y) (z-trich2 y))
;;                                                 (z-int-defn-proof y))
;;                               (z-succ-equal-proof x y 1 2))))
;; (defthm z-int-z-succ-equal-proof-proves

;;              (implies (and (g-termp x 0 symbols)
;;                            (g-termp y 0 symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (subset (list (p 2 1) (p 1 2) (fn 3 1) (fn 2 2) (fn 1 2) (fn 0 0))
;;                                    symbols)
;;                            (nil-intersect (list 1 2) (collect-free (list x y) 1)))
;;                       (proves (z-int-z-succ-equal-proof x y)
;;                               (f-implies (z-int x)
;;                                          (f-implies (z-int y)
;;                                                     (f-implies (f-equal (z-succ x) (z-succ y))
;;                                                                (f-equal x y))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0739 z-int-z-succ-equal-proof t)
;; (defn
;;  z-sub1-unique-proof
;;  (x y y1)
;;  (form-z-if-unique-proof
;;   y
;;   y1
;;   (z-sub1-expr x y y)
;;   (cons (cons (tautconseq-proof (list (f-implies (f-equal (z-succ y) x)
;;                                                  (f-implies (f-equal (z-succ y1) x)
;;                                                             (f-equal (z-succ y) (z-succ y1))))
;;                                       (f-implies (z-int y)
;;                                                  (f-implies (z-int y1)
;;                                                             (f-implies (f-equal (z-succ y)
;;                                                                                 (z-succ y1))
;;                                                                        (f-equal y y1)))))
;;                                 (f-implies (f-and (f-and (z-int y) (f-equal (z-succ y) x))
;;                                                   (f-and (z-int y1) (f-equal (z-succ y1) x)))
;;                                            (f-equal y y1))
;;                                 (list (trans-equal-proof2 (z-succ y) x (z-succ y1))
;;                                       (z-int-z-succ-equal-proof y y1)))
;;               (unique-fun-intro-proof y y1 (phi)))
;;         (unique-fun-intro-proof y y1 (phi)))))
;; (defun z-sub1-defn-proof
;;       (term)
;;       (subst-rule-proof (z-sub1-defun 0 (z-sub1 0) 3)
;;                         0
;;                         term
;;                         (fun-defn-proof (fn 10 1)
;;                                         (list 0)
;;                                         3
;;                                         4
;;                                         (z-sub1-defun 0 3 3)
;;                                         (z-sub1-exis-proof 0 3)
;;                                         (z-sub1-unique-proof 0 3 4))))
;; (defun z-sub1-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 10 1) defns) (z-sub1-defun 0 (z-sub1 0) 3))
;;            (z-int-hyps defns (rest-of (fn 10 1) symbols))
;;            (z-succ-hyps defns (rest-of (fn 10 1) symbols))
;;            (subset (list (fn 3 1) (p 2 1) (p 1 2) (fn 2 2) (fn 1 2) (fn 0 0))
;;                    (rest-of (fn 10 1) symbols))))
;; (defthm z-sub1-defn-proof-proves

;;              (implies (and (subset (list (fn 10 1) (fn 3 1) (p 2 1) (fn 0 0)) symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (g-termp term 0 symbols)
;;                            (nil-intersect (list 3 4) (collect-free term 0))
;;                            (equal concl (z-sub1-defun term (z-sub1 term) 3)))
;;                       (proves (z-sub1-defn-proof term) concl given defns symbols)))
;; (toggle g0787 z-sub1-defn-proof t)
;; (toggle g0788 z-sub1-hyps t)
;; (defun enable-nzerop-proof
;;       (x y)
;;       (detach-proof (f-and (z-int (ncode (sub1 x)))
;;                            (f-equal (z-succ (ncode (sub1 x))) (z-succ (ncode (sub1 x)))))
;;                     (forsome y (f-and (z-int y) (f-equal (z-succ y) (z-succ (ncode (sub1 x))))))
;;                     (and-join-proof (z-int (ncode (sub1 x)))
;;                                     (f-equal (z-succ (ncode (sub1 x))) (z-succ (ncode (sub1 x))))
;;                                     (z-int-numeral-proof (sub1 x))
;;                                     (ident-axiom-proof (z-succ (ncode (sub1 x)))))
;;                     (subst-thm-a-proof (f-and (z-int y)
;;                                               (f-equal (z-succ y) (z-succ (ncode (sub1 x)))))
;;                                        (list y)
;;                                        (list (ncode (sub1 x))))))
;; (defthm enable-nzerop-proof-proves

;;              (implies (and (not (zerop x))
;;                            (subset (list (fn 3 1) (p 2 1) (p 1 2) (fn 2 2) (fn 1 2) (fn 0 0))
;;                                    symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (g-variable y)
;;                            (equal concl
;;                                   (forsome y (f-and (z-int y) (f-equal (z-succ y) (ncode x))))))
;;                       (proves (enable-nzerop-proof x y) concl given defns symbols)))
;; (toggle g0790 enable-nzerop-proof t)
;; (defn
;;  disable-nzerop-proof
;;  (x y)
;;  (f-iff-mp-proof2
;;   (f-not (forsome y (f-and (z-int y) (f-equal (z-succ y) (ncode x)))))
;;   (forall y (f-not (f-and (z-int y) (f-equal (z-succ y) (ncode x)))))
;;   (forsome-forall-proof y (f-and (z-int y) (f-equal (z-succ y) (ncode x))))
;;   (generalise-proof y
;;                     (f-not (f-and (z-int y) (f-equal (z-succ y) (ncode x))))
;;                     (tautconseq-proof (list (f-implies (f-equal (z-succ y) (phi))
;;                                                        (f-equal (phi) (z-succ y)))
;;                                             (f-not (f-equal (phi) (z-succ y))))
;;                                       (f-not (f-and (z-int y) (f-equal (z-succ y) (phi))))
;;                                       (list (symmetry-proof1 (z-succ y) (phi))
;;                                             (ext-not-equal-proof (phi)
;;                                                                  (z-succ y)
;;                                                                  y
;;                                                                  (null-axiom-proof y)
;;                                                                  (x-in-z-succ-x-proof y)))))))
;; (defthm disable-nzerop-proof-proves

;;              (implies (and (not (consp x))
;;                            (zerop x)
;;                            (subset (list (fn 3 1) (p 2 1) (p 1 2) (fn 2 2) (fn 1 2) (fn 0 0))
;;                                    symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (g-variable y)
;;                            (equal concl
;;                                   (f-not (forsome y
;;                                                   (f-and (z-int y)
;;                                                          (f-equal (z-succ y) (ncode x)))))))
;;                       (proves (disable-nzerop-proof x y) concl given defns symbols)))
;; (toggle g0791 disable-nzerop-proof t)
;; (defn
;;  nzerop-z-sub1-ncode-proof
;;  (x)
;;  (tautconseq-proof (list (z-int (ncode (sub1 x)))
;;                          (f-implies (z-int (z-sub1 (ncode x)))
;;                                     (f-implies (z-int (ncode (sub1 x)))
;;                                                (f-implies (f-equal (z-succ (z-sub1 (ncode x)))
;;                                                                    (z-succ (ncode (sub1 x))))
;;                                                           (f-equal (z-sub1 (ncode x))
;;                                                                    (ncode (sub1 x)))))))
;;                    (f-implies (f-and (z-int (z-sub1 (ncode x)))
;;                                      (f-equal (z-succ (z-sub1 (ncode x)))
;;                                               (z-succ (ncode (sub1 x)))))
;;                               (f-equal (z-sub1 (ncode x)) (ncode (sub1 x))))
;;                    (list (z-int-numeral-proof (sub1 x))
;;                          (z-int-z-succ-equal-proof (z-sub1 (ncode x)) (ncode (sub1 x))))))
;; (defn
;;  z-sub1-ncode-proof
;;  (x)
;;  (form-z-if-eval-proof1 (list (list (atom x)
;;                                     (z-int-numeral-proof x)
;;                                     (not-int-opair-proof (ncode (car x)) (ncode (cdr x)) 0))
;;                               (list (list (not (zerop x))
;;                                           (enable-nzerop-proof x 3)
;;                                           (disable-nzerop-proof x 3))
;;                                     (nzerop-z-sub1-ncode-proof x)
;;                                     (tautconseq-proof nil
;;                                                       (f-implies (f-equal (z-sub1 (ncode x))
;;                                                                           (phi))
;;                                                                  (f-equal (z-sub1 (ncode x))
;;                                                                           (phi)))
;;                                                       nil))
;;                               (tautconseq-proof nil
;;                                                 (f-implies (f-equal (z-sub1 (ncode x)) (phi))
;;                                                            (f-equal (z-sub1 (ncode x)) (phi)))
;;                                                 nil))
;;                         (z-sub1-expr (ncode x) (z-sub1 (ncode x)) 3)
;;                         (z-sub1 (ncode x))
;;                         (ncode (sub1 x))
;;                         (z-sub1-defn-proof (ncode x))))
;; (defthm z-sub1-ncode-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 3 1)
;;                                          (p 2 1)
;;                                          (p 1 2)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (equal concl (f-equal (z-sub1 (ncode x)) (ncode (sub1 x)))))
;;                       (proves (z-sub1-ncode-proof x) concl given defns symbols)))
;; (toggle g0793 z-sub1-ncode-proof t)
;; ;; sequence of events introducing "(z-equal x y)", the z2 analogue of equal.
;; (defun z-equal (x y) (list (fn 11 2) x y))
;; (defun z-equal-defun (x y z) (f-if (f-equal x y) (f-equal z (z-succ (phi))) (f-equal z (phi))))
;; (defun z-equal-defn-proof
;;       (x y)
;;       (instance-proof (z-equal-defun 0 1 (z-equal 0 1))
;;                       (list 0 1)
;;                       (list x y)
;;                       (fun-defn-proof (fn 11 2)
;;                                       (list 0 1)
;;                                       2
;;                                       3
;;                                       (z-equal-defun 0 1 2)
;;                                       (term-z-if-exis-proof 2
;;                                                             (z-if (f-equal 0 1)
;;                                                                   (z-succ (phi))
;;                                                                   (phi)))
;;                                       (term-z-if-unique-proof 2
;;                                                               3
;;                                                               (z-if (f-equal 0 1)
;;                                                                     (z-succ (phi))
;;                                                                     (phi))))))
;; (defun z-equal-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 11 2) defns) (z-equal-defun 0 1 (z-equal 0 1)))
;;            (subset (list (fn 3 1) (fn 0 0)) (rest-of (fn 11 2) symbols))))
;; (toggle g0740 free-for-list nil)
;; (defthm z-equal-defn-proof-proves

;;              (implies (and (subset (list (fn 11 2) (fn 3 1) (fn 0 0)) symbols)
;;                            (z-equal-hyps defns symbols)
;;                            (g-termp (list x y) 1 symbols)
;;                            (equal concl (z-equal-defun x y (z-equal x y))))
;;                       (proves (z-equal-defn-proof x y) concl given defns symbols)))
;; (toggle g0794 z-equal-defn-proof t)
;; (toggle g0795 z-equal-hyps t)
;; (defthm ncode-equal-ncode-equal

;;              (implies (ncode-equal x y) (equal (ncode y) (ncode x))))
;; (defun z-equal-ncode-proof
;;       (x y)
;;       (z-if-eval-proof1 (list (list (ncode-equal x y)
;;                                     (ident-axiom-proof (ncode x))
;;                                     (ncode-nequal-proof x y))
;;                               (ident-axiom-proof (z-succ (phi)))
;;                               (ident-axiom-proof (phi)))
;;                         (z-if (f-equal (ncode x) (ncode y)) (z-succ (phi)) (phi))
;;                         (z-equal (ncode x) (ncode y))
;;                         (ncode (bool-fix (ncode-equal x y)))
;;                         (z-equal-defn-proof (ncode x) (ncode y))))
;; (defthm z-equal-ncode-proof-proves

;;              (implies (and (subset (list (fn 11 2)
;;                                          (p 2 1)
;;                                          (p 1 2)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-equal-hyps defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-equal (ncode x) (ncode y))
;;                                            (ncode (bool-fix (ncode-equal x y))))))
;;                       (proves (z-equal-ncode-proof x y) concl given defns symbols)))
;; (toggle g0796 z-equal-ncode-proof t)
;; ;; sequence of events introducing "(z-cons x y)", the z2 analogue of cons.
;; (defun z-cons (x y) (list (fn 12 2) x y))
;; (defun z-cons-defun (x y z) (f-equal z (z-opair x y)))
;; (defun z-cons-defn-proof
;;       (x y)
;;       (instance-proof (z-cons-defun 0 1 (z-cons 0 1))
;;                       (list 0 1)
;;                       (list x y)
;;                       (fun-defn-proof (fn 12 2)
;;                                       (list 0 1)
;;                                       2
;;                                       3
;;                                       (z-cons-defun 0 1 2)
;;                                       (exis-fun-intro-proof 2 (z-opair 0 1))
;;                                       (unique-fun-intro-proof 2 3 (z-opair 0 1)))))
;; (defun z-cons-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 12 2) defns) (z-cons-defun 0 1 (z-cons 0 1)))
;;            (member (fn 1 2) (rest-of (fn 12 2) symbols))))
;; (defthm z-cons-defn-proof-proves

;;              (implies (and (subset (list (fn 12 2) (fn 1 2)) symbols)
;;                            (z-cons-hyps defns symbols)
;;                            (g-termp (list x y) 1 symbols)
;;                            (equal (collect-free x 0) nil)
;;                            (equal (collect-free y 0) nil)
;;                            (equal concl (z-cons-defun x y (z-cons x y))))
;;                       (proves (z-cons-defn-proof x y) concl given defns symbols)))
;; (toggle g0800 z-cons-defn-proof t)
;; (toggle g0801 z-cons-hyps t)
;; (toggle g0741 z-cons-defn-proof t)
;; (toggle g0742 z-cons-hyps t)
;; (defthm nzerop-ncode-equal

;;              (implies (or (not (zerop x))
;;                           (not (zerop y)))
;;                       (equal (ncode-equal x y) (equal x y))))
;; (defun list-and-join-proof
;;       (explist pflist)
;;       (if (consp explist)
;;           (if (consp (cdr explist))
;;               (and-join-proof (car explist)
;;                               (list-f-and (cdr explist))
;;                               (car pflist)
;;                               (list-and-join-proof (cdr explist) (cdr pflist)))
;;               (car pflist))
;;           pflist))
;; (defthm list-and-join-proof-proves

;;              (implies (and (consp explist)
;;                            (proves-list pflist explist given defns symbols))
;;                       (proves (list-and-join-proof explist pflist)
;;                               (list-f-and explist)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0804 list-and-join-proof t)
;; (defun compose-proof
;;       (fn val args vals pflist pf)
;;       (list-detach-proof (list-f-equal (list (cons fn args) (cons fn vals) (cons fn args))
;;                                        (list (cons fn args) val (cons fn vals)))
;;                          (f-equal (cons fn args) val)
;;                          (list (ident-axiom-proof (cons fn args))
;;                                pf
;;                                (list-detach-proof (list-f-equal args vals)
;;                                                   (f-equal (cons fn args) (cons fn vals))
;;                                                   pflist
;;                                                   (equal-axiom1-proof fn args vals)))
;;                          (equal-axiom2-proof (p 0 2)
;;                                              (list (cons fn args) (cons fn vals))
;;                                              (list (cons fn args) val))))
;; ;; so far we have seen how to introduce functions defined by cases.  another
;; ;; important way of defining functions is by composition, i.e., "(f x1 ... xn)"
;; ;; can be defined as "(g (h1 x1...xn) ... (hn x1...xn))".  (it is worth noting
;; ;; that it is exactly because we make heavy use of function composition that
;; ;; we introduced function symbols corresponding to the lisp primitives.
;; ;; when we were working with the predicates representing the definitions,
;; ;; composition was extremely tedious to simulate.)  we can of course
;; ;; combine definition by cases and by composition.  the remaining important
;; ;; mode of definition is recursion, and we will see how this is carried out, later.
;; ;; the lemma below asserts that if |- "(arg1=val1)", . . ., |- "(argn=valn)",
;; ;; and |- "((f val1 ... valn) = val)", then |- "((f arg1 ... argn) = val)".
;; (defthm compose-proof-proves

;;              (implies (and (g-function fn)
;;                            (symb fn symbols)
;;                            (g-termp args 1 symbols)
;;                            (g-termp vals 1 symbols)
;;                            (g-termp val 0 symbols)
;;                            (equal (length args) (degree fn))
;;                            (equal (length vals) (degree fn))
;;                            (proves-list pflist (list-f-equal args vals) given defns symbols)
;;                            (proves pf (f-equal (cons fn vals) val) given defns symbols)
;;                            (equal concl (f-equal (cons fn args) val)))
;;                       (proves (compose-proof fn val args vals pflist pf)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable symb-reduc)))
;; (toggle g0805 compose-proof t)
;; ;; perhaps the most commonly used composition is the iterated use of car/cdr.
;; ;; the function car-cdr recurses down list and if (car list) is 1, it applies
;; ;; car to the result of (car-cdr x (cdr list)).  otherwise, it returns
;; ;; (cdr (car-cdr x (cdr list))).
;; (defun car-cdr
;;       (x list)
;;       (if (consp list)
;;           (if (equal (car list) 1) (car (car-cdr x (cdr list))) (cdr (car-cdr x (cdr list))))
;;           x))
;; ;; z-car-cdr composes "z-car" and "z-cdr" in a manner similar to car-cdr.
;; (defun z-car-cdr
;;       (x list)
;;       (if (consp list)
;;           (if (equal (car list) 1)
;;               (z-car (z-car-cdr x (cdr list)))
;;               (z-cdr (z-car-cdr x (cdr list))))
;;           x))
;; (defthm termp-z-car-cdr

;;              (implies (and (subset (list (fn 5 1) (fn 4 1)) symbols)
;;                            (g-termp x 0 symbols))
;;                       (g-termp (z-car-cdr x list) 0 symbols)))
;; (defun z-car-cdr-proof
;;       (x list)
;;       (if (consp list)
;;           (if (equal (car list) 1)
;;               (compose-proof (fn 4 1)
;;                              (ncode (car-cdr x list))
;;                              (list (z-car-cdr (ncode x) (cdr list)))
;;                              (list (ncode (car-cdr x (cdr list))))
;;                              (list (z-car-cdr-proof x (cdr list)))
;;                              (z-car-ncode-proof (car-cdr x (cdr list))))
;;               (compose-proof (fn 5 1)
;;                              (ncode (car-cdr x list))
;;                              (list (z-car-cdr (ncode x) (cdr list)))
;;                              (list (ncode (car-cdr x (cdr list))))
;;                              (list (z-car-cdr-proof x (cdr list)))
;;                              (z-cdr-ncode-proof (car-cdr x (cdr list)))))
;;           (ident-axiom-proof (ncode x))))
;; (toggle g0806 z-car nil)
;; (toggle g0807 z-cdr nil)
;; ;; z-car-cdr is the z2 analogue of car-cdr.
;; (defthm z-car-cdr-proof-proves

;;              (implies (and (subset (list (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (p 2 1)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-car-cdr (ncode x) list) (ncode (car-cdr x list)))))
;;                       (proves (z-car-cdr-proof x list) concl given defns symbols)))
;; (toggle g0808 z-car-cdr-proof t)
;; (defun compose-car-proof
;;       (fn val arg pfval)
;;       (compose-proof fn
;;                      val
;;                      (list (z-car (ncode arg)))
;;                      (list (ncode (car arg)))
;;                      (list (z-car-ncode-proof arg))
;;                      pfval))
;; (defthm compose-car-proof-proves

;;              (implies (and (g-function fn)
;;                            (symb fn symbols)
;;                            (equal (degree fn) 1)
;;                            (g-termp val 0 symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (subset (list (fn 4 1) (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (fn 0 0))
;;                                    symbols)
;;                            (member (p 2 1) symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (proves pfval
;;                                    (f-equal (list fn (ncode (car arg))) val)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl (f-equal (list fn (z-car (ncode arg))) val)))
;;                       (proves (compose-car-proof fn val arg pfval) concl given defns symbols))
;;              ((disable symb-reduc)))
;; (toggle g0821 compose-car-proof t)
;; (defun compose-car-cadr-proof
;;       (fn val arg pfval)
;;       (compose-proof fn
;;                      val
;;                      (list (z-car (ncode arg)) (z-car (z-cdr (ncode arg))))
;;                      (list (ncode (car arg)) (ncode (cadr arg)))
;;                      (list (z-car-ncode-proof arg) (z-car-cdr-proof arg (list 1 2)))
;;                      pfval))
;; (defthm compose-car-cadr-proof-proves

;;              (implies (and (g-function fn)
;;                            (symb fn symbols)
;;                            (equal (degree fn) 2)
;;                            (g-termp val 0 symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (subset (list (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (member (p 2 1) symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (proves pfval
;;                                    (f-equal (list fn (ncode (car arg)) (ncode (cadr arg))) val)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl
;;                                   (f-equal (list fn
;;                                                  (z-car (ncode arg))
;;                                                  (z-car (z-cdr (ncode arg))))
;;                                            val)))
;;                       (proves (compose-car-cadr-proof fn val arg pfval) concl given defns symbols))
;;              ((disable symb-reduc)))
;; (toggle g0822 compose-car-cadr-proof t)
;; ;; next we would like to define the z2 analogue of apply-subr, the part
;; ;; of the lisp interpreter that evaluates the lisp primitives.  this is
;; ;; done in three parts to make the proof manageable.  in the first part
;; ;; we represent apply-subr1 which evaluates consp, cons, car, and cdr.
;; ;; these operations are represented by the symbols 6, 7, 8, and 9, respectively,
;; ;; to the lisp interpreter.  apply-subr1 is represented by "(z-apply-subr1 nil args)".
;; (defun z-apply-subr1 (fn args) (list (fn 13 2) fn args))
;; (defun z-apply-subr1-defn
;;       (fn args y)
;;       (f-if (f-equal fn (ncode 6))
;;             (f-equal y (z-consp (z-car args)))
;;             (f-if (f-equal fn (ncode 7))
;;                   (f-equal y (z-cons (z-car args) (z-car (z-cdr args))))
;;                   (f-if (f-equal fn (ncode 8))
;;                         (f-equal y (z-car (z-car args)))
;;                         (f-equal y (z-cdr (z-car args)))))))
;; (defun z-apply-subr1-exis-proof
;;       (fn args y)
;;       (term-z-if-exis-proof y
;;                             (z-if (f-equal fn (ncode 6))
;;                                   (z-consp (z-car args))
;;                                   (z-if (f-equal fn (ncode 7))
;;                                         (z-cons (z-car args) (z-car (z-cdr args)))
;;                                         (z-if (f-equal fn (ncode 8))
;;                                               (z-car (z-car args))
;;                                               (z-cdr (z-car args)))))))
;; (defun z-apply-subr1-unique-proof
;;       (y y1 fn args)
;;       (term-z-if-unique-proof y
;;                               y1
;;                               (z-if (f-equal fn (ncode 6))
;;                                     (z-consp (z-car args))
;;                                     (z-if (f-equal fn (ncode 7))
;;                                           (z-cons (z-car args) (z-car (z-cdr args)))
;;                                           (z-if (f-equal fn (ncode 8))
;;                                                 (z-car (z-car args))
;;                                                 (z-cdr (z-car args)))))))
;; (defun z-apply-subr1-defn-proof
;;       (fn args)
;;       (instance-proof (z-apply-subr1-defun 0 1 (z-apply-subr1 0 1))
;;                       (list 0 1)
;;                       (list fn args)
;;                       (fun-defn-proof (fn 13 2)
;;                                       (list 0 1)
;;                                       2
;;                                       3
;;                                       (z-apply-subr1-defun 0 1 2)
;;                                       (z-apply-subr1-exis-proof 0 1 2)
;;                                       (z-apply-subr1-unique-proof 2 3 0 1))))
;; (defun z-apply-subr1-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 13 2) defns) (z-apply-subr1-defun 0 1 (z-apply-subr1 0 1)))
;;            (subset (list (fn 0 0)
;;                          (fn 3 1)
;;                          (fn 4 1)
;;                          (fn 5 1)
;;                          (fn 6 1)
;;                          (fn 7 1)
;;                          (fn 8 1)
;;                          (fn 9 1)
;;                          (fn 10 1)
;;                          (fn 11 2)
;;                          (fn 12 2))
;;                    (rest-of (fn 13 2) symbols))))
;; (defthm z-apply-subr1-defn-proof-proves

;;              (implies (and (subset (list (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2))
;;                                    symbols)
;;                            (z-apply-subr1-hyps defns symbols)
;;                            (g-termp (list x y) 1 symbols)
;;                            (equal concl (z-apply-subr1-defun x y (z-apply-subr1 x y))))
;;                       (proves (z-apply-subr1-defn-proof x y) concl given defns symbols)))
;; (toggle g0810 z-apply-subr1-defn-proof t)
;; (toggle g0811 z-apply-subr1-hyps t)
;; ;; apply-subr2 evaluates the lisp primitives zerop, add1, sub1, and those
;; ;; evaluated by apply-subr1.  it is represented by "(z-apply-subr2 nil args)".
;; (defun z-apply-subr2 (fn args) (list (fn 14 2) fn args))
;; (defun z-apply-subr2-defn
;;       (fn args y)
;;       (f-if (f-equal fn (ncode 3))
;;             (f-equal y (z-zerop (z-car args)))
;;             (f-if (f-equal fn (ncode 4))
;;                   (f-equal y (z-add1 (z-car args)))
;;                   (f-if (f-equal fn (ncode 5))
;;                         (f-equal y (z-sub1 (z-car args)))
;;                         (f-equal y (z-apply-subr1 fn args))))))
;; (defun z-apply-subr2-exis-proof
;;       (fn args y)
;;       (term-z-if-exis-proof y
;;                             (z-if (f-equal fn (ncode 3))
;;                                   (z-zerop (z-car args))
;;                                   (z-if (f-equal fn (ncode 4))
;;                                         (z-add1 (z-car args))
;;                                         (z-if (f-equal fn (ncode 5))
;;                                               (z-sub1 (z-car args))
;;                                               (z-apply-subr1 fn args))))))
;; (defun z-apply-subr2-unique-proof
;;       (fn args y y1)
;;       (term-z-if-unique-proof y
;;                               y1
;;                               (z-if (f-equal fn (ncode 3))
;;                                     (z-zerop (z-car args))
;;                                     (z-if (f-equal fn (ncode 4))
;;                                           (z-add1 (z-car args))
;;                                           (z-if (f-equal fn (ncode 5))
;;                                                 (z-sub1 (z-car args))
;;                                                 (z-apply-subr1 fn args))))))
;; (defun z-apply-subr2-defn-proof
;;       (fn args)
;;       (instance-proof (z-apply-subr2-defun 0 1 (z-apply-subr2 0 1))
;;                       (list 0 1)
;;                       (list fn args)
;;                       (fun-defn-proof (fn 14 2)
;;                                       (list 0 1)
;;                                       2
;;                                       3
;;                                       (z-apply-subr2-defun 0 1 2)
;;                                       (z-apply-subr2-exis-proof 0 1 2)
;;                                       (z-apply-subr2-unique-proof 0 1 2 3))))
;; (defun z-apply-subr2-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 14 2) defns) (z-apply-subr2-defun 0 1 (z-apply-subr2 0 1)))
;;            (subset (list (fn 0 0)
;;                          (fn 3 1)
;;                          (fn 4 1)
;;                          (fn 5 1)
;;                          (fn 6 1)
;;                          (fn 7 1)
;;                          (fn 8 1)
;;                          (fn 9 1)
;;                          (fn 10 1)
;;                          (fn 11 2)
;;                          (fn 12 2)
;;                          (fn 13 2))
;;                    (rest-of (fn 14 2) symbols))))
;; (defthm z-apply-subr2-defn-proof-proves

;;              (implies (and (subset (list (fn 14 2)
;;                                          (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2))
;;                                    symbols)
;;                            (z-apply-subr2-hyps defns symbols)
;;                            (g-termp (list x y) 1 symbols)
;;                            (equal concl (z-apply-subr2-defun x y (z-apply-subr2 x y))))
;;                       (proves (z-apply-subr2-defn-proof x y) concl given defns symbols)))
;; (toggle g0812 z-apply-subr2-defn-proof t)
;; (toggle g0813 z-apply-subr2-hyps t)
;; ;; finally, apply-subr evaluates the lisp primitives equal, acl2-numberp,
;; ;; and those evaluated by apply-subr2.  it is represented by
;; ;; "(z-apply-subr nil args)".
;; (defun z-apply-subr (fn args) (list (fn 15 2) fn args))
;; (defun z-apply-subr-defn
;;       (fn args y)
;;       (f-if (f-equal fn (ncode 1))
;;             (f-equal y (z-equal (z-car args) (z-car (z-cdr args))))
;;             (f-if (f-equal fn (ncode 2))
;;                   (f-equal y (z-acl2-numberp (z-car args)))
;;                   (f-equal y (z-apply-subr2 fn args)))))
;; (defun z-apply-subr-exis-proof
;;       (fn args y)
;;       (term-z-if-exis-proof y
;;                             (z-if (f-equal fn (ncode 1))
;;                                   (z-equal (z-car args) (z-car (z-cdr args)))
;;                                   (z-if (f-equal fn (ncode 2))
;;                                         (z-acl2-numberp (z-car args))
;;                                         (z-apply-subr2 fn args)))))
;; (defun z-apply-subr-unique-proof
;;       (fn args y y1)
;;       (term-z-if-unique-proof y
;;                               y1
;;                               (z-if (f-equal fn (ncode 1))
;;                                     (z-equal (z-car args) (z-car (z-cdr args)))
;;                                     (z-if (f-equal fn (ncode 2))
;;                                           (z-acl2-numberp (z-car args))
;;                                           (z-apply-subr2 fn args)))))
;; (defun z-apply-subr-defn-proof
;;       (fn args)
;;       (instance-proof (z-apply-subr-defun 0 1 (z-apply-subr 0 1))
;;                       (list 0 1)
;;                       (list fn args)
;;                       (fun-defn-proof (fn 15 2)
;;                                       (list 0 1)
;;                                       2
;;                                       3
;;                                       (z-apply-subr-defun 0 1 2)
;;                                       (z-apply-subr-exis-proof 0 1 2)
;;                                       (z-apply-subr-unique-proof 0 1 2 3))))
;; (defun z-apply-subr-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 15 2) defns) (z-apply-subr-defun 0 1 (z-apply-subr 0 1)))
;;            (subset (list (fn 0 0)
;;                          (fn 3 1)
;;                          (fn 4 1)
;;                          (fn 5 1)
;;                          (fn 6 1)
;;                          (fn 7 1)
;;                          (fn 8 1)
;;                          (fn 9 1)
;;                          (fn 10 1)
;;                          (fn 11 2)
;;                          (fn 12 2)
;;                          (fn 13 2)
;;                          (fn 14 2))
;;                    (rest-of (fn 15 2) symbols))))
;; (defthm z-apply-subr-defn-proof-proves

;;              (implies (and (subset (list (fn 15 2)
;;                                          (fn 14 2)
;;                                          (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2))
;;                                    symbols)
;;                            (z-apply-subr-hyps defns symbols)
;;                            (g-termp (list x y) 1 symbols)
;;                            (equal concl (z-apply-subr-defun x y (z-apply-subr x y))))
;;                       (proves (z-apply-subr-defn-proof x y) concl given defns symbols)))
;; (toggle g0814 z-apply-subr-defn-proof t)
;; (toggle g0815 z-apply-subr-hyps t)
;; (defun apply-subr1
;;       (fn args)
;;       (if (equal fn 6)
;;           (bool-fix (consp (car args)))
;;           (if (equal fn 7)
;;               (cons (car args) (cadr args))
;;               (if (equal fn 8) (car (car args)) (cdr (car args))))))
;; (defn
;;  z-apply-subr1-ncode-proof
;;  (fn args)
;;  (z-if-eval-proof1 (list (list (equal fn 6)
;;                                (ident-axiom-proof (ncode 6))
;;                                (ncode-nequal-proof fn 6))
;;                          (compose-car-proof (fn 6 1)
;;                                             (ncode (bool-fix (consp (car args))))
;;                                             args
;;                                             (z-consp-ncode-proof (car args)))
;;                          (list (list (equal fn 7)
;;                                      (ident-axiom-proof (ncode 7))
;;                                      (ncode-nequal-proof fn 7))
;;                                (compose-car-cadr-proof (fn 12 2)
;;                                                        (ncode (cons (car args) (cadr args)))
;;                                                        args
;;                                                        (z-cons-defn-proof (ncode (car args))
;;                                                                           (ncode (cadr args))))
;;                                (list (list (equal fn 8)
;;                                            (ident-axiom-proof (ncode 8))
;;                                            (ncode-nequal-proof fn 8))
;;                                      (compose-car-proof (fn 4 1)
;;                                                         (ncode (car (car args)))
;;                                                         args
;;                                                         (z-car-ncode-proof (car args)))
;;                                      (compose-car-proof (fn 5 1)
;;                                                         (ncode (cdr (car args)))
;;                                                         args
;;                                                         (z-cdr-ncode-proof (car args))))))
;;                    (z-if (f-equal (ncode fn) (ncode 6))
;;                          (z-consp (z-car (ncode args)))
;;                          (z-if (f-equal (ncode fn) (ncode 7))
;;                                (z-cons (z-car (ncode args)) (z-car (z-cdr (ncode args))))
;;                                (z-if (f-equal (ncode fn) (ncode 8))
;;                                      (z-car (z-car (ncode args)))
;;                                      (z-cdr (z-car (ncode args))))))
;;                    (z-apply-subr1 (ncode fn) (ncode args))
;;                    (ncode (apply-subr1 fn args))
;;                    (z-apply-subr1-defn-proof (ncode fn) (ncode args))))
;; (defthm z-apply-subr1-ncode-proof-proves-step

;;              (implies (and (subset (list (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (p 2 1)
;;                                          (p 1 2))
;;                                    symbols)
;;                            (z-apply-subr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-apply-subr1-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-cons-hyps defns symbols)
;;                            (z-consp-hyps defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-apply-subr1 (ncode fn) (ncode args))
;;                                            (ncode (apply-subr1 fn args)))))
;;                       (proves (z-apply-subr1-ncode-proof fn args) concl given defns symbols)))
;; (toggle g0820 z-apply-subr1-ncode-proof t)
;; (toggle g0825 apply-subr1 t)
;; (toggle g0826 sub1 t)
;; (defun apply-subr2
;;       (fn args)
;;       (if (equal fn 3)
;;           (bool-fix (zerop (car args)))
;;           (if (equal fn 4)
;;               (add1 (car args))
;;               (if (equal fn 5) (sub1 (car args)) (apply-subr1 fn args)))))
;; (defun z-apply-subr2-ncode-proof
;;       (fn args)
;;       (z-if-eval-proof1 (list (list (equal fn 3)
;;                                     (ident-axiom-proof (ncode 3))
;;                                     (ncode-nequal-proof fn 3))
;;                               (compose-car-proof (fn 9 1)
;;                                                  (ncode (bool-fix (zerop (car args))))
;;                                                  args
;;                                                  (z-zerop-ncode-proof (car args)))
;;                               (list (list (equal fn 4)
;;                                           (ident-axiom-proof (ncode 4))
;;                                           (ncode-nequal-proof fn 4))
;;                                     (compose-car-proof (fn 7 1)
;;                                                        (ncode (add1 (car args)))
;;                                                        args
;;                                                        (z-add1-ncode-proof (car args)))
;;                                     (list (list (equal fn 5)
;;                                                 (ident-axiom-proof (ncode 5))
;;                                                 (ncode-nequal-proof fn 5))
;;                                           (compose-car-proof (fn 10 1)
;;                                                              (ncode (sub1 (car args)))
;;                                                              args
;;                                                              (z-sub1-ncode-proof (car args)))
;;                                           (z-apply-subr1-ncode-proof fn args))))
;;                         (z-if (f-equal (ncode fn) (ncode 3))
;;                               (z-zerop (z-car (ncode args)))
;;                               (z-if (f-equal (ncode fn) (ncode 4))
;;                                     (z-add1 (z-car (ncode args)))
;;                                     (z-if (f-equal (ncode fn) (ncode 5))
;;                                           (z-sub1 (z-car (ncode args)))
;;                                           (z-apply-subr1 (ncode fn) (ncode args)))))
;;                         (z-apply-subr2 (ncode fn) (ncode args))
;;                         (ncode (apply-subr2 fn args))
;;                         (z-apply-subr2-defn-proof (ncode fn) (ncode args))))
;; (defthm z-apply-subr2-ncode-proof-proves-step

;;              (implies (and (subset (list (fn 14 2)
;;                                          (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (p 2 1)
;;                                          (p 1 2))
;;                                    symbols)
;;                            (z-apply-subr-hyps defns symbols)
;;                            (z-apply-subr2-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-apply-subr1-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-cons-hyps defns symbols)
;;                            (z-consp-hyps defns symbols)
;;                            (z-add1-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-apply-subr2 (ncode fn) (ncode args))
;;                                            (ncode (apply-subr2 fn args)))))
;;                       (proves (z-apply-subr2-ncode-proof fn args) concl given defns symbols)))
;; (toggle g0827 z-apply-subr2-ncode-proof t)
;; (toggle g0828 apply-subr2 t)
;; (defun apply-subr
;;       (fn args)
;;       (if (equal fn 1)
;;           (bool-fix (ncode-equal (car args) (cadr args)))
;;           (if (equal fn 2) (bool-fix (not (consp (car args)))) (apply-subr2 fn args))))
;; (defn
;;  z-apply-subr-ncode-proof
;;  (fn args)
;;  (z-if-eval-proof1 (list (list (equal fn 1)
;;                                (ident-axiom-proof (ncode 1))
;;                                (ncode-nequal-proof fn 1))
;;                          (compose-car-cadr-proof (fn 11 2)
;;                                                  (ncode (bool-fix (ncode-equal (car args)
;;                                                                                (cadr args))))
;;                                                  args
;;                                                  (z-equal-ncode-proof (car args) (cadr args)))
;;                          (list (list (equal fn 2)
;;                                      (ident-axiom-proof (ncode 2))
;;                                      (ncode-nequal-proof fn 2))
;;                                (compose-car-proof (fn 8 1)
;;                                                   (ncode (bool-fix (not (consp (car args)))))
;;                                                   args
;;                                                   (z-acl2-numberp-ncode-proof (car args)))
;;                                (z-apply-subr2-ncode-proof fn args)))
;;                    (z-if (f-equal (ncode fn) (ncode 1))
;;                          (z-equal (z-car (ncode args)) (z-car (z-cdr (ncode args))))
;;                          (z-if (f-equal (ncode fn) (ncode 2))
;;                                (z-acl2-numberp (z-car (ncode args)))
;;                                (z-apply-subr2 (ncode fn) (ncode args))))
;;                    (z-apply-subr (ncode fn) (ncode args))
;;                    (ncode (apply-subr fn args))
;;                    (z-apply-subr-defn-proof (ncode fn) (ncode args))))
;; (defun z-apply-subr-all-hyps
;;       (given defns symbols)
;;       (and (z-apply-subr-hyps defns symbols)
;;            (z-apply-subr2-hyps defns symbols)
;;            (z-int-hyps defns symbols)
;;            (z-apply-subr1-hyps defns symbols)
;;            (z-succ-hyps defns symbols)
;;            (z-car-hyps defns symbols)
;;            (z-cdr-hyps defns symbols)
;;            (z-cons-hyps defns symbols)
;;            (z-consp-hyps defns symbols)
;;            (z-add1-hyps defns symbols)
;;            (z-sub1-hyps defns symbols)
;;            (z-zerop-hyps defns symbols)
;;            (z-equal-hyps defns symbols)
;;            (z-acl2-numberp-hyps defns symbols)))
;; (defthm z-apply-subr-ncode-proof-proves

;;              (implies (and (subset (list (fn 15 2)
;;                                          (fn 14 2)
;;                                          (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (p 2 1)
;;                                          (p 1 2))
;;                                    symbols)
;;                            (z-apply-subr-all-hyps given defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-apply-subr (ncode fn) (ncode args))
;;                                            (ncode (apply-subr fn args)))))
;;                       (proves (z-apply-subr-ncode-proof fn args) concl given defns symbols)))
;; (toggle g0829 z-apply-subr-ncode-proof t)
;; (toggle g0830 apply-subr t)
;; ;; thus far we have shown how we can derive z2 analogues of the lisp primitives
;; ;; and the function apply-subr.  these functions will be used in demonstrating
;; ;; the representability of the lisp interpreter.  a major obstacle that has
;; ;; to be overcome is the representability (in z2) of recursively defined lisp functions.
;; ;; these will be represented by specifying the partial graph (the set of value/argument
;; ;; ordered pairs used in the computation of the value of the function at
;; ;; a specific argument).  this partial graph will first be constructed as a
;; ;; list of pairs for the computation of the lisp function and then translated
;; ;; into the corresponding set.  the specification of the partial graph in z2 will be
;; ;; shown to hold of this translation.  it will also be shown that any set
;; ;; satisfying the specification.
;; ;; the function graph-trans below translates a list into the corresponding set
;; ;; so that the list (x1 . (x2 . ... (xn . nil))) is converted to the set
;; ;;  "{<x1>, <x2>, ..., <xn>}".  the translation of list x will be represented as [x].
;; (defun graph-trans
;;       (x)
;;       (if (consp x) (z-union (z-sing (ncode (car x))) (graph-trans (cdr x))) (phi)))
;; (defun in-graph-proof
;;       (x graph)
;;       (if (consp graph)
;;           (if (equal x (car graph))
;;               (f-iff-mp-proof2 (isin (ncode x)
;;                                      (z-union (z-sing (ncode x)) (graph-trans (cdr graph))))
;;                                (f-or (isin (ncode x) (z-sing (ncode x)))
;;                                      (isin (ncode x) (graph-trans (cdr graph))))
;;                                (union-axiom-proof (ncode x)
;;                                                   (z-sing (ncode x))
;;                                                   (graph-trans (cdr graph)))
;;                                (rt-expan-proof (isin (ncode x) (z-sing (ncode x)))
;;                                                (isin (ncode x) (graph-trans (cdr graph)))
;;                                                (isin-sing1-proof (ncode x))))
;;               (f-iff-mp-proof2 (isin (ncode x)
;;                                      (z-union (z-sing (ncode (car graph)))
;;                                               (graph-trans (cdr graph))))
;;                                (f-or (isin (ncode x) (z-sing (ncode (car graph))))
;;                                      (isin (ncode x) (graph-trans (cdr graph))))
;;                                (union-axiom-proof (ncode x)
;;                                                   (z-sing (ncode (car graph)))
;;                                                   (graph-trans (cdr graph)))
;;                                (expan-proof (isin (ncode x) (z-sing (ncode (car graph))))
;;                                             (isin (ncode x) (graph-trans (cdr graph)))
;;                                             (in-graph-proof x (cdr graph)))))
;;           nil))
;; (defthm termp-graph-trans

;;              (implies (and (member (fn 0 0) symbols)
;;                            (member (fn 3 1) symbols)
;;                            (member (fn 1 2) symbols)
;;                            (member (fn 2 2) symbols))
;;                       (g-termp (graph-trans x) 0 symbols))
;;              ((induct (graph-trans x))))
;; ;; if x is in graph, then |- "(<x> in [graph])".
;; (defthm in-graph-proof-proves

;;              (implies (and (member (fn 0 0) symbols)
;;                            (member (fn 3 1) symbols)
;;                            (member (fn 1 2) symbols)
;;                            (member (fn 2 2) symbols)
;;                            (member (p 1 2) symbols)
;;                            (member x graph)
;;                            (equal x-bar (ncode x))
;;                            (equal trace (graph-trans graph)))
;;                       (proves (in-graph-proof x graph) (isin x-bar trace) given defns symbols)))
;; (toggle g0831 in-graph-proof t)
;; (defun opair-equal-proof
;;       (x y u v)
;;       (tautconseq-proof (list (f-implies (f-equal x u)
;;                                          (f-implies (f-equal y v)
;;                                                     (f-equal (z-pair x y) (z-pair u v))))
;;                               (f-implies (f-equal x u)
;;                                          (f-implies (f-equal x u)
;;                                                     (f-equal (z-sing x) (z-sing u))))
;;                               (f-implies (f-equal (z-sing x) (z-sing u))
;;                                          (f-implies (f-equal (z-pair x y) (z-pair u v))
;;                                                     (f-equal (z-opair x y) (z-opair u v)))))
;;                         (f-implies (f-equal x u)
;;                                    (f-implies (f-equal y v)
;;                                               (f-equal (z-opair x y) (z-opair u v))))
;;                         (list (equal-axiom1-proof (fn 1 2) (list x y) (list u v))
;;                               (equal-axiom1-proof (fn 1 2) (list x x) (list u u))
;;                               (equal-axiom1-proof (fn 1 2)
;;                                                   (list (z-sing x) (z-pair x y))
;;                                                   (list (z-sing u) (z-pair u v))))))
;; (toggle g0832 z-opair nil)
;; (toggle g0833 z-sing nil)
;; (defthm opair-equal-proof-proves

;;              (implies (and (member (fn 1 2) symbols)
;;                            (g-termp x 0 symbols)
;;                            (g-termp y 0 symbols)
;;                            (g-termp u 0 symbols)
;;                            (g-termp v 0 symbols))
;;                       (proves (opair-equal-proof x y u v)
;;                               (f-implies (f-equal x u)
;;                                          (f-implies (f-equal y v)
;;                                                     (f-equal (z-opair x y) (z-opair u v))))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable list-implies-reduc)))
;; (toggle g0834 z-sing t)
;; (toggle g0835 z-opair t)
;; (toggle g0836 opair-equal-proof t)
;; (defun in-graph-trans-proof
;;       (x y z)
;;       (tautconseq-proof (list (f-iff (isin x (graph-trans (cons y z)))
;;                                      (f-or (isin x (z-sing (ncode y))) (isin x (graph-trans z))))
;;                               (f-iff (isin x (z-sing (ncode y))) (f-equal x (ncode y))))
;;                         (f-iff (isin x (graph-trans (cons y z)))
;;                                (f-or (f-equal x (ncode y)) (isin x (graph-trans z))))
;;                         (list (union-axiom-proof x (z-sing (ncode y)) (graph-trans z))
;;                               (isin-sing-proof (ncode y) x))))
;; (defun isin-graph-trans-proof
;;       (x y)
;;       (f-iff-mp-proof2 (isin (ncode x) (graph-trans (cons x y)))
;;                        (f-or (f-equal (ncode x) (ncode x)) (isin (ncode x) (graph-trans y)))
;;                        (in-graph-trans-proof (ncode x) x y)
;;                        (rt-expan-proof (f-equal (ncode x) (ncode x))
;;                                        (isin (ncode x) (graph-trans y))
;;                                        (ident-axiom-proof (ncode x)))))
;; (defun graph-trans-merge-proof
;;       (x y exp1 exp2 pf1 pf2)
;;       (tautconseq-proof (list (f-iff (isin exp1 (graph-trans (cons x y)))
;;                                      (f-or (f-equal exp1 (ncode x)) (isin exp1 (graph-trans y))))
;;                               (f-implies (f-equal exp1 (ncode x)) exp2)
;;                               (f-implies (isin exp1 (graph-trans y)) exp2))
;;                         (f-implies (isin exp1 (graph-trans (cons x y))) exp2)
;;                         (list (in-graph-trans-proof exp1 x y) pf1 pf2)))
;; ;;  |- "((x in [(cons y z)]) <-> ((x = <y>) v (x in [z])))".
;; (prove-lemma
;;  in-graph-trans-proof-proves

;;  (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                (g-termp x 0 symbols)
;;                (equal y-bar (ncode y))
;;                (equal z-bar (graph-trans z)))
;;           (proves (in-graph-trans-proof x y z)
;;                   (f-iff (isin x (graph-trans (cons y z)))
;;                          (f-or (f-equal x y-bar) (isin x z-bar)))
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable eval-tautconseq-proof-proves)
;;   (use (eval-tautconseq-proof-proves (flist (list (f-iff (isin x (graph-trans (cons y z)))
;;                                                          (f-or (isin x (z-sing (ncode y)))
;;                                                                (isin x (graph-trans z))))
;;                                                   (f-iff (isin x (z-sing (ncode y)))
;;                                                          (f-equal x (ncode y)))))
;;                                      (exp (f-iff (isin x (graph-trans (cons y z)))
;;                                                  (f-or (f-equal x (ncode y))
;;                                                        (isin x (graph-trans z)))))
;;                                      (pflist (list (union-axiom-proof x
;;                                                                       (z-sing (ncode y))
;;                                                                       (graph-trans z))
;;                                                    (isin-sing-proof (ncode y) x)))))))
;; (toggle g0488 in-graph-trans-proof t)
;; ;;  |- "(<x> in [(cons x y)])".
;; (defthm isin-graph-trans-proof-proves

;;              (implies (and (equal x-bar (ncode x))
;;                            (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols))
;;                       (proves (isin-graph-trans-proof x y)
;;                               (isin x-bar (graph-trans (cons x y)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable graph-trans)))
;; ;;  if |- "((a = <x>) -> b)", and |- "((a in [y]) -> b)", then |- "((a in [cons x y]) -> b)".
;; ;; this lemma is really important because we prove that every member of the
;; ;; partial graph satisfies the specification, by induction on the list from which
;; ;; the graph is constructed.  this lemma permits the case-split required to carry
;; ;; out such an induction.  this will be clarified later.
;; (prove-lemma
;;  graph-trans-merge

;;  (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                (g-termp exp1 0 symbols)
;;                (g-formula exp2 symbols)
;;                (proves pf1 (f-implies (f-equal exp1 (ncode x)) exp2) given defns symbols)
;;                (proves pf2 (f-implies (isin exp1 (graph-trans y)) exp2) given defns symbols))
;;           (proves (graph-trans-merge-proof x y exp1 exp2 pf1 pf2)
;;                   (f-implies (isin exp1 (graph-trans (cons x y))) exp2)
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable eval-tautconseq-proof-proves graph-trans)
;;   (use (eval-tautconseq-proof-proves (flist (list (f-iff (isin exp1 (graph-trans (cons x y)))
;;                                                          (f-or (f-equal exp1 (ncode x))
;;                                                                (isin exp1 (graph-trans y))))
;;                                                   (f-implies (f-equal exp1 (ncode x)) exp2)
;;                                                   (f-implies (isin exp1 (graph-trans y)) exp2)))
;;                                      (exp (f-implies (isin exp1 (graph-trans (cons x y))) exp2))
;;                                      (pflist (list (in-graph-trans-proof exp1 x y) pf1 pf2))))))
;; (toggle g0490 isin-graph-trans-proof t)
;; (toggle g0491 graph-trans-merge-proof t)
;; (defthm atom-graph-trans (implies (atom x) (equal (graph-trans x) (phi))))
;; (defthm collect-free-graph-trans (equal (collect-free (graph-trans x) 0) nil))
;; (toggle g0459 graph-trans t)
;; (defun in-graph-step-proof
;;       (exp x y pf)
;;       (f-iff-mp-proof2 (isin exp (graph-trans (cons x y)))
;;                        (f-or (f-equal exp (ncode x)) (isin exp (graph-trans y)))
;;                        (in-graph-trans-proof exp x y)
;;                        (expan-proof (f-equal exp (ncode x)) (isin exp (graph-trans y)) pf)))
;; ;;  if |- "(exp in [y])", then |- "(exp in [(cons x y)])".
;; (defthm in-graph-step-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (g-termp exp 0 symbols)
;;                            (proves pf (isin exp (graph-trans y)) given defns symbols)
;;                            (equal trace (graph-trans (cons x y))))
;;                       (proves (in-graph-step-proof exp x y pf)
;;                               (isin exp trace)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0837 in-graph-step-proof t)
;; ;; z-list converts a list of the form (x1. (... (xn . nil))) to <<x1>, ..., <xn>>.
;; (defun z-list
;;       (exp)
;;       (if (consp exp) (if (consp (cdr exp)) (z-opair (car exp) (z-list (cdr exp))) (car exp)) nil))
;; (defthm termp-z-list

;;              (implies (and (member (fn 1 2) symbols)
;;                            (consp list)
;;                            (g-termp list 1 symbols))
;;                       (g-termp (z-list list) 0 symbols)))
;; (defn
;;  z-list-equal-proof
;;  (list1 list2 pf)
;;  (if
;;   (and (consp list1)
;;        (consp list2))
;;   (if
;;    (and (consp (cdr list1))
;;         (consp (cdr list2)))
;;    (and-join-proof (f-equal (car list1) (car list2))
;;                    (list-f-and (list-f-equal (cdr list1) (cdr list2)))
;;                    (detach-proof (f-equal (z-list list1) (z-list list2))
;;                                  (f-equal (car list1) (car list2))
;;                                  pf
;;                                  (z-car-unique-proof (car list1)
;;                                                      (z-list (cdr list1))
;;                                                      (car list2)
;;                                                      (z-list (cdr list2))))
;;                    (z-list-equal-proof (cdr list1)
;;                                        (cdr list2)
;;                                        (detach-proof (f-equal (z-list list1) (z-list list2))
;;                                                      (f-equal (z-list (cdr list1))
;;                                                               (z-list (cdr list2)))
;;                                                      pf
;;                                                      (z-cdr-unique-proof (car list1)
;;                                                                          (z-list (cdr list1))
;;                                                                          (car list2)
;;                                                                          (z-list (cdr list2))))))
;;    pf)
;;   nil))
;; (defun len-equal
;;       (x y)
;;       (if (and (consp x)
;;                (consp y))
;;           (len-equal (cdr x) (cdr y))
;;           (and (atom x)
;;                (atom y))))
;; (defthm z-list-equal-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 1 2)) symbols)
;;                            (g-termp list1 1 symbols)
;;                            (g-termp list2 1 symbols)
;;                            (consp list1)
;;                            (consp list2)
;;                            (len-equal list1 list2)
;;                            (proves pf (f-equal (z-list list1) (z-list list2)) given defns symbols))
;;                       (proves (z-list-equal-proof list1 list2 pf)
;;                               (list-f-and (list-f-equal list1 list2))
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (z-list-equal-proof list1 list2 pf))))
;; (toggle g0838 z-list-equal-proof t)
;; ;; proves-form-z-if-ok is similar to proves-z-if except that in the base case,
;; ;; it merely checks if pftree is a proof of exp.
;; (defun proves-form-z-if-ok
;;       (pftree exp given defns symbols)
;;       (if (z-ifp exp)
;;           (if (caar pftree)
;;               (and (proves (cadar pftree) (z-test exp) given defns symbols)
;;                    (proves-form-z-if-ok (cadr pftree) (z-left exp) given defns symbols))
;;               (and (proves (caddar pftree) (f-not (z-test exp)) given defns symbols)
;;                    (proves-form-z-if-ok (caddr pftree) (z-right exp) given defns symbols)))
;;           (proves pftree exp given defns symbols)))
;; (defun form-z-if-ok-proof
;;       (pftree exp)
;;       (if (z-ifp exp)
;;           (if (caar pftree)
;;               (f-if-intro-proof1 (z-test exp)
;;                                  (make-form-z-if (z-left exp))
;;                                  (make-form-z-if (z-right exp))
;;                                  (cadar pftree)
;;                                  (form-z-if-ok-proof (cadr pftree) (z-left exp)))
;;               (f-if-intro-proof2 (z-test exp)
;;                                  (make-form-z-if (z-left exp))
;;                                  (make-form-z-if (z-right exp))
;;                                  (caddar pftree)
;;                                  (form-z-if-ok-proof (caddr pftree) (z-right exp))))
;;           pftree))
;; ;; from a proof-tree containing proofs of each of the test nodes of an form-if-tree
;; ;; and the leaf node that they lead upto, we can construct a proof of the entire
;; ;; if-expression represented by the form-if-tree.
;; (defthm form-z-if-ok-proof-proves

;;              (implies (and (form-z-if exp symbols)
;;                            (proves-form-z-if-ok pftree exp given defns symbols)
;;                            (equal concl (make-form-z-if exp)))
;;                       (proves (form-z-if-ok-proof pftree exp) concl given defns symbols)))
;; (toggle g0839 form-z-if-ok-proof t)
;; (defun equal-z-list-proof
;;       (x y pflist)
;;       (if (and (consp x)
;;                (consp y))
;;           (if (and (consp (cdr x))
;;                    (consp (cdr y)))
;;               (list-detach-proof (list (f-equal (car x) (car y))
;;                                        (f-equal (z-list (cdr x)) (z-list (cdr y))))
;;                                  (f-equal (z-list x) (z-list y))
;;                                  (list (car pflist)
;;                                        (equal-z-list-proof (cdr x) (cdr y) (cdr pflist)))
;;                                  (opair-equal-proof (car x)
;;                                                     (z-list (cdr x))
;;                                                     (car y)
;;                                                     (z-list (cdr y))))
;;               (car pflist))
;;           nil))
;; (defthm equal-z-list-proof-proves

;;              (implies (and (member (fn 1 2) symbols)
;;                            (g-termp x 1 symbols)
;;                            (g-termp y 1 symbols)
;;                            (consp x)
;;                            (consp y)
;;                            (len-equal x y)
;;                            (proves-list pflist (list-f-equal x y) given defns symbols))
;;                       (proves (equal-z-list-proof x y pflist)
;;                               (f-equal (z-list x) (z-list y))
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (equal-z-list-proof x y pflist))))
;; (toggle g0842 equal-z-list-proof t)
;; (defthm equal-z-list-proof-proves1

;;              (implies (and (member (fn 1 2) symbols)
;;                            (g-termp x 1 symbols)
;;                            (g-termp y 1 symbols)
;;                            (consp x)
;;                            (consp y)
;;                            (len-equal x y)
;;                            (proves-list pflist (list-f-equal x y) given defns symbols)
;;                            (equal concl (f-equal (z-list x) (z-list y))))
;;                       (proves (equal-z-list-proof x y pflist) concl given defns symbols)))
;; (toggle g0843 equal-z-list-proof-proves t)
;; (defthm atom-ncode (implies (atom x) (equal (ncode x) (numeral x))))
;; (defun flip-not-equals-proof
;;       (x y pf)
;;       (detach-proof (f-not (f-equal x y))
;;                     (f-not (f-equal y x))
;;                     pf
;;                     (contra-pos-proof1 (f-equal y x) (f-equal x y) (symmetry-proof1 y x))))
;; (defthm term-list-var-list

;;              (implies (var-list vars (length vars)) (term-list vars symbols)))
;; (defun form-equal-case-proof
;;       (vars terms exp pf)
;;       (tautconseq-proof (list (parallel-subst exp vars terms 0)
;;                               (f-implies (list-f-and (list-f-equal vars terms))
;;                                          (f-iff exp (parallel-subst exp vars terms 0))))
;;                         (f-implies (list-f-and (list-f-equal vars terms)) exp)
;;                         (list pf
;;                               (form-equal-proof exp
;;                                                 (parallel-subst exp vars terms 0)
;;                                                 (list-f-equal vars terms)))))
;; (defthm term-list-termp (implies (term-list terms symbols) (g-termp terms 1 symbols)))
;; ;; if |- "[a1/x1, ..., an/xn]a", then |- "(((x1=a1) ^ ... ^ (xn=an)) -> a)".
;; (prove-lemma
;;  form-equal-case-proof-proves

;;  (implies (and (g-formula exp symbols)
;;                (proves pf (parallel-subst exp vars terms 0) given defns symbols)
;;                (var-list vars (length vars))
;;                (term-list terms symbols)
;;                (consp (list-f-equal vars terms))
;;                (equal (collect-free terms 1) nil)
;;                (equal concl (f-implies (list-f-and (list-f-equal vars terms)) exp)))
;;           (proves (form-equal-case-proof vars terms exp pf) concl given defns symbols))
;;  ((use (eval-tautconseq-proof-proves (flist (list (parallel-subst exp vars terms 0)
;;                                                   (f-implies (list-f-and (list-f-equal vars
;;                                                                                        terms))
;;                                                              (f-iff exp
;;                                                                     (parallel-subst exp
;;                                                                                     vars
;;                                                                                     terms
;;                                                                                     0)))))
;;                                      (exp (f-implies (list-f-and (list-f-equal vars terms)) exp))
;;                                      (pflist (list pf
;;                                                    (form-equal-proof exp
;;                                                                      (parallel-subst exp
;;                                                                                      vars
;;                                                                                      terms
;;                                                                                      0)
;;                                                                      (list-f-equal vars
;;                                                                                    terms))))))
;;   (disable list-f-and eval-tautconseq-proof-proves)))
;; (toggle g0931 form-equal-case-proof t)
;; (defun z-list-equal-imp-proof
;;       (x y)
;;       (if (and (consp x)
;;                (consp y))
;;           (if (and (consp (cdr x))
;;                    (consp (cdr y)))
;;               (tautconseq-proof (list (f-implies (f-equal (z-list x) (z-list y))
;;                                                  (f-equal (car x) (car y)))
;;                                       (f-implies (f-equal (z-list x) (z-list y))
;;                                                  (list-f-and (list-f-equal (cdr x) (cdr y)))))
;;                                 (f-implies (f-equal (z-list x) (z-list y))
;;                                            (list-f-and (list-f-equal x y)))
;;                                 (list (z-car-unique-proof (car x)
;;                                                           (z-list (cdr x))
;;                                                           (car y)
;;                                                           (z-list (cdr y)))
;;                                       (chain-proof (f-equal (z-list x) (z-list y))
;;                                                    (list-f-and (list-f-equal (cdr x) (cdr y)))
;;                                                    (list (f-equal (z-list (cdr x))
;;                                                                   (z-list (cdr y))))
;;                                                    (list (z-cdr-unique-proof (car x)
;;                                                                              (z-list (cdr x))
;;                                                                              (car y)
;;                                                                              (z-list (cdr y)))
;;                                                          (z-list-equal-imp-proof (cdr x)
;;                                                                                  (cdr y))))))
;;               (tautconseq-proof nil
;;                                 (f-implies (f-equal (car x) (car y)) (f-equal (car x) (car y)))
;;                                 nil))
;;           nil))
;; (defthm termp-car-cdr

;;              (implies (and (consp x)
;;                            (g-termp x 1 symbols))
;;                       (and (g-termp (car x) 0 symbols)
;;                            (g-termp (cdr x) 1 symbols))))
;; (defthm z-list-equal-imp-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 1 2)) symbols)
;;                            (g-termp list1 1 symbols)
;;                            (g-termp list2 1 symbols)
;;                            (consp list1)
;;                            (consp list2)
;;                            (len-equal list1 list2))
;;                       (proves (z-list-equal-imp-proof list1 list2)
;;                               (f-implies (f-equal (z-list list1) (z-list list2))
;;                                          (list-f-and (list-f-equal list1 list2)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (z-list-equal-imp-proof list1 list2))))
;; (toggle g0845 z-list-equal-imp-proof t)
;; (defthm z-list-equal-imp-proof-proves1

;;              (implies (and (subset (list (p 1 2) (fn 1 2)) symbols)
;;                            (g-termp list1 1 symbols)
;;                            (g-termp list2 1 symbols)
;;                            (consp list1)
;;                            (consp list2)
;;                            (len-equal list1 list2)
;;                            (equal concl
;;                                   (f-implies (f-equal (z-list list1) (z-list list2))
;;                                              (list-f-and (list-f-equal list1 list2)))))
;;                       (proves (z-list-equal-imp-proof list1 list2) concl given defns symbols)))
;; (toggle g0846 z-list-equal-imp-proof-proves t)
;; (defun equal-isin-proof
;;       (x y z pf1 pf2)
;;       (list-detach-proof (list (f-equal x y) (f-equal z z) (isin x z))
;;                          (isin y z)
;;                          (list pf1 (ident-axiom-proof z) pf2)
;;                          (equal-axiom2-proof (p 1 2) (list x z) (list y z))))
;; ;; if |- "(x = y)", and |- "(x in z)", then |- "(y in z)".
;; (defthm equal-isin-proof-proves

;;              (implies (and (proves pf1 (f-equal x y) given defns symbols)
;;                            (proves pf2 (isin x z) given defns symbols))
;;                       (proves (equal-isin-proof x y z pf1 pf2) (isin y z) given defns symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-equal x y)))
;;                    (proves-is-formula (pf pf2) (exp (isin x z))))
;;               ))
;; ;; as it turns out, in order to represent the lisp interpreter in z2, we only need
;; ;; represent two recursive functions, the function get below, and the lisp interpreter
;; ;; ev itself.  the lisp interpreter is a lisp function which evaluates quoted
;; ;; lisp objects which represent pure-lisp expressions.  these e-expressions are
;; ;; either e-variables (represented by numbers) or e-function symbols (also represented
;; ;; by numbers) applied to a list of e-expressions.  the interpreter takes as
;; ;; its arguments: the e-expression to be evaluated, the bindings of values to the
;; ;; e-variables, and the bindings of definitions to the defined e-function symbols.
;; ;; since e-variables are numbers, their bindings are stored in a list so that the
;; ;; binding of the variable n is the n+1th element in the list.  get does exactly
;; ;; this by returning the x+1th element in the list y.
;; (defun get (x y) (if (zerop x) (car y) (get (sub1 x) (cdr y))))
;; ;; we said earlier that the partial graph corresponding to a computation is first
;; ;; constructed as a list of value/argument pairs which is then translated into the
;; ;; corresponding set.  get-graph constructs this list of value/argument pairs
;; ;; corresponding to the computation of (get x y).
;; (defun get-graph
;;       (x y)
;;       (if (zerop x)
;;           (list (cons (get x y) (cons x y)))
;;           (cons (cons (get x y) (cons x y)) (get-graph (sub1 x) (cdr y)))))
;; (defthm member-get-graph (member (cons (get x y) (cons x y)) (get-graph x y)))
;; (defthm in-graph-cdr-get-graph

;;              (implies (not (zerop x))
;;                       (member (cons (get x y) (cons (sub1 x) (cdr y))) (get-graph x y))))
;; (defn
;;  a-get-defn-part-ok-proof1
;;  (x y)
;;  (form-z-if-ok-proof
;;   (list (list (zerop x)
;;               (z-zerop-ncode-proof x)
;;               (trans-not-equal-proof (ncode 1)
;;                                      (z-zerop (ncode x))
;;                                      (ncode 0)
;;                                      (ncode-nequal-proof 1 0)
;;                                      (z-zerop-ncode-proof x)))
;;         (flip-equals-proof (z-car (ncode y)) (ncode (get x y)) (z-car-ncode-proof y))
;;         (equal-isin-proof (z-list (list (ncode (get x y)) (ncode (sub1 x)) (ncode (cdr y))))
;;                           (z-list (list (ncode (get x y)) (z-sub1 (ncode x)) (z-cdr (ncode y))))
;;                           (graph-trans (get-graph x y))
;;                           (equal-z-list-proof (list (ncode (get x y))
;;                                                     (ncode (sub1 x))
;;                                                     (ncode (cdr y)))
;;                                               (list (ncode (get x y))
;;                                                     (z-sub1 (ncode x))
;;                                                     (z-cdr (ncode y)))
;;                                               (list (ident-axiom-proof (ncode (get x y)))
;;                                                     (flip-equals-proof (z-sub1 (ncode x))
;;                                                                        (ncode (sub1 x))
;;                                                                        (z-sub1-ncode-proof x))
;;                                                     (flip-equals-proof (z-cdr (ncode y))
;;                                                                        (ncode (cdr y))
;;                                                                        (z-cdr-ncode-proof y))))
;;                           (in-graph-proof (cons (get x y) (cons (sub1 x) (cdr y)))
;;                                           (get-graph x y))))
;;   (z-if (f-equal (z-zerop (ncode x)) (ncode 1))
;;         (f-equal (ncode (get x y)) (z-car (ncode y)))
;;         (isin (z-opair (ncode (get x y)) (z-opair (z-sub1 (ncode x)) (z-cdr (ncode y))))
;;               (graph-trans (get-graph x y))))))
;; ;; at this point we present the z2 formula which represents the lisp function get.
;; ;; the formula representing the assertion (get x y) = val asserts the existence
;; ;; of a partial graph "trace" to which the tuple <<val>, <x>, <y>> belongs, such
;; ;; that all of its members satisfy the z2 analogue of the definition of get.
;; ;; more formally,
;; ;;      "(forsome trace ((<val, x, y> in trace)
;; ;;                       ^
;; ;;                       (forall v1, x1, y1
;; ;;                         ((<v1, x1, y1> in trace)
;; ;;                          ->
;; ;;                          (if ((z-zerop x1) = <1>)
;; ;;                           then (v1 = (z-car y1))
;; ;;                           else (<v1, (z-sub1 x1), (z-cdr y1)> in trace))))))".
;; ;;
;; ;; notice how in the second part where we specify that each 3-tuple "<v1,x1,y1>"
;; ;; in "trace" satisfies the z2 analogue of the definition of get, the analogue of
;; ;; the recursive call (get (sub1 x)(cdr y)) is the membership check
;; ;; "(<v1, (z-sub1 x1), (z-cdr y1)> in trace)".  a-get-defn-part below constructs
;; ;; the definition (second) part of the above formula.
;; (defun a-get-defn-part
;;       (x y val trace)
;;       (f-if (f-equal (z-zerop x) (ncode 1))
;;             (f-equal val (z-car y))
;;             (isin (z-list (list val (z-sub1 x) (z-cdr y))) trace)))
;; ;; next we wish to show that the partial graph given by (get-graph x y)
;; ;; satisfies the formula above.  by this we show that the representing formula
;; ;; is `ok'.  this is done in many steps.  one part
;; ;; of this is to show that each element of this partial graph satisfies the
;; ;; a-get-defn-part.  this will be done by induction.  the first part is
;; ;; to show that "<<(get x y)>, <x>, <y>>" satisfies the definition part
;; ;; with (graph-trans (get-graph x y)) for "trace".  this is carried out below.
;; (defthm a-get-defn-part-ok-proof1-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (equal concl
;;                                   (a-get-defn-part (ncode x)
;;                                                    (ncode y)
;;                                                    (ncode (get x y))
;;                                                    (graph-trans (get-graph x y)))))
;;                       (proves (a-get-defn-part-ok-proof1 x y) concl given defns symbols)))
;; (toggle g0847 a-get-defn-part-ok-proof1 t)
;; (defun in-graph-cdr-proof
;;       (x y graph)
;;       (tautconseq-proof (list (f-implies (f-or (f-equal x (ncode y))
;;                                                (isin x (graph-trans graph)))
;;                                          (isin x (graph-trans (cons y graph)))))
;;                         (f-implies (isin x (graph-trans graph))
;;                                    (isin x (graph-trans (cons y graph))))
;;                         (list (iff-split-proof2 (isin x (graph-trans (cons y graph)))
;;                                                 (f-or (f-equal x (ncode y))
;;                                                       (isin x (graph-trans graph)))
;;                                                 (in-graph-trans-proof x y graph)))))
;; ;;  |- "((x in [graph]) -> (x in [(cons y graph)]))".
;; (defthm in-graph-cdr-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 3 1) (fn 2 2) (fn 1 2) (fn 0 0)) symbols)
;;                            (g-termp x 0 symbols))
;;                       (proves (in-graph-cdr-proof x y graph)
;;                               (f-implies (isin x (graph-trans graph))
;;                                          (isin x (graph-trans (cons y graph))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0850 in-graph-cdr-proof t)
;; (defun a-get-defn-part-step-proof
;;       (y u v v1 pf)
;;       (tautconseq-proof (list (f-implies v v1)) (f-implies (f-if y u v) (f-if y u v1)) (list pf)))
;; ;; if |- "(c -> c1)", then |- "((if a then b else c) -> (if a then b else c1))".
;; (defthm a-get-defn-part-step-proof-proves

;;              (implies (and (g-formula (f-if y u v) symbols)
;;                            (g-formula v1 symbols)
;;                            (proves pf (f-implies v v1) given defns symbols))
;;                       (proves (a-get-defn-part-step-proof y u v v1 pf)
;;                               (f-implies (f-if y u v) (f-if y u v1))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0851 a-get-defn-part-step-proof t)
;; (defun inst-formals-proof
;;       (formals actuals exp pf)
;;       (chain-proof (f-equal (z-list formals) (z-list actuals))
;;                    exp
;;                    (list (list-f-and (list-f-equal formals actuals)))
;;                    (list (z-list-equal-imp-proof formals actuals)
;;                          (form-equal-case-proof formals actuals exp pf))))
;; (defn
;;  a-get-defn-ok-proof
;;  (x1 y1 val1 x y)
;;  (if
;;   (zerop x)
;;   (graph-trans-merge-proof
;;    (cons (get x y) (cons x y))
;;    nil
;;    (z-list (list val1 x1 y1))
;;    (a-get-defn-part x1 y1 val1 (graph-trans (get-graph x y)))
;;    (inst-formals-proof (list val1 x1 y1)
;;                        (list (ncode (get x y)) (ncode x) (ncode y))
;;                        (a-get-defn-part x1 y1 val1 (graph-trans (get-graph x y)))
;;                        (a-get-defn-part-ok-proof1 x y))
;;    (tautconseq-proof (list (f-not (isin (z-list (list val1 x1 y1)) (phi))))
;;                      (f-implies (isin (z-list (list val1 x1 y1)) (phi))
;;                                 (a-get-defn-part x1 y1 val1 (graph-trans (get-graph x y))))
;;                      (list (null-axiom-proof (z-list (list val1 x1 y1))))))
;;   (graph-trans-merge-proof
;;    (cons (get x y) (cons x y))
;;    (get-graph (sub1 x) (cdr y))
;;    (z-list (list val1 x1 y1))
;;    (a-get-defn-part x1 y1 val1 (graph-trans (get-graph x y)))
;;    (inst-formals-proof (list val1 x1 y1)
;;                        (list (ncode (get x y)) (ncode x) (ncode y))
;;                        (a-get-defn-part x1 y1 val1 (graph-trans (get-graph x y)))
;;                        (a-get-defn-part-ok-proof1 x y))
;;    (chain-proof
;;     (isin (z-list (list val1 x1 y1)) (graph-trans (get-graph (sub1 x) (cdr y))))
;;     (a-get-defn-part x1 y1 val1 (graph-trans (get-graph x y)))
;;     (list (a-get-defn-part x1 y1 val1 (graph-trans (get-graph (sub1 x) (cdr y)))))
;;     (list (a-get-defn-ok-proof x1 y1 val1 (sub1 x) (cdr y))
;;           (a-get-defn-part-step-proof (f-equal (z-zerop x1) (ncode 1))
;;                                       (f-equal val1 (z-car y1))
;;                                       (isin (z-list (list val1 (z-sub1 x1) (z-cdr y1)))
;;                                             (graph-trans (get-graph (sub1 x) (cdr y))))
;;                                       (isin (z-list (list val1 (z-sub1 x1) (z-cdr y1)))
;;                                             (graph-trans (get-graph x y)))
;;                                       (in-graph-cdr-proof (z-list (list val1
;;                                                                         (z-sub1 x1)
;;                                                                         (z-cdr y1)))
;;                                                           (cons (get x y) (cons x y))
;;                                                           (get-graph (sub1 x) (cdr y)))))))))
;; ;; in the lemma below, we carry out the induction to prove that every element of
;; ;; the partial graph satisfies the analogue of the definition of get, i.e.,
;; ;;  |- "((<v1,x1,y1> in [(get-graph x y)]) -> (a-get-defn-part x1 y1 v1 [(get-graph x y)]))".
;; (defthm a-get-defn-ok-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (var-set (list val1 x1 y1) 3))
;;                       (proves (a-get-defn-ok-proof x1 y1 val1 x y)
;;                               (f-implies (isin (z-list (list val1 x1 y1))
;;                                                (graph-trans (get-graph x y)))
;;                                          (a-get-defn-part x1
;;                                                           y1
;;                                                           val1
;;                                                           (graph-trans (get-graph x y))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0852 a-get-defn-ok-proof t)
;; (defun list-gen-proof
;;       (vars exp pf)
;;       (if (consp vars)
;;           (generalise-proof (car vars)
;;                             (list-all-quantify (cdr vars) exp)
;;                             (list-gen-proof (cdr vars) exp pf))
;;           pf))
;; (defthm list-gen-proof-proves

;;              (implies (and (var-list vars (length vars))
;;                            (proves pf exp given defns symbols))
;;                       (proves (list-gen-proof vars exp pf)
;;                               (list-all-quantify vars exp)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula))))
;; (toggle g0853 list-gen-proof t)
;; (toggle g0854 a-get-defn-part t)
;; ;; a-get combines the first and second parts of the specification of "trace".
;; (defun a-get
;;       (x y val x1 y1 val1 trace)
;;       (f-and (isin (z-opair val (z-opair x y)) trace)
;;              (list-all-quantify (list x1 y1 val1)
;;                                 (f-implies (isin (z-list (list val1 x1 y1)) trace)
;;                                            (a-get-defn-part x1 y1 val1 trace)))))
;; (defn
;;  a-get-ok-proof1
;;  (x y x1 y1 val1)
;;  (and-join-proof (isin (ncode (cons (get x y) (cons x y))) (graph-trans (get-graph x y)))
;;                  (list-all-quantify (list x1 y1 val1)
;;                                     (f-implies (isin (z-list (list val1 x1 y1))
;;                                                      (graph-trans (get-graph x y)))
;;                                                (a-get-defn-part x1
;;                                                                 y1
;;                                                                 val1
;;                                                                 (graph-trans (get-graph x y)))))
;;                  (in-graph-proof (cons (get x y) (cons x y)) (get-graph x y))
;;                  (list-gen-proof (list x1 y1 val1)
;;                                  (f-implies (isin (z-list (list val1 x1 y1))
;;                                                   (graph-trans (get-graph x y)))
;;                                             (a-get-defn-part x1
;;                                                              y1
;;                                                              val1
;;                                                              (graph-trans (get-graph x y))))
;;                                  (a-get-defn-ok-proof x1 y1 val1 x y))))
;; ;; finally we show that
;; ;; |- "[<x>/x, <y>/y, <(get x y)>/val, [(get-graph x y)]/trace]a-get".
;; ;; this completes the first part of the representability proof for get.
;; ;; the second part involves showing that any "trace" satisfying the
;; ;; specification a-get must encode only evaluations of get.  by this we
;; ;; show that the representing formula is `good'.
;; (defthm a-get-ok-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (var-set (list val1 x1 y1) 3)
;;                            (equal x-bar (ncode x))
;;                            (equal y-bar (ncode y))
;;                            (equal val-bar (ncode (get x y)))
;;                            (equal trace (graph-trans (get-graph x y))))
;;                       (proves (a-get-ok-proof1 x y x1 y1 val1)
;;                               (a-get x-bar y-bar val-bar x1 y1 val1 trace)
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list list-all-quantify)))
;; (toggle g0856 a-get-ok-proof1 t)
;; (toggle g0857 a-get-defn-part nil)
;; (defun equal-isin-imp-proof
;;       (x y z pf)
;;       (list-detach-proof (list (f-equal x y) (f-equal z z))
;;                          (f-implies (isin x z) (isin y z))
;;                          (list pf (ident-axiom-proof z))
;;                          (equal-axiom2-proof (p 1 2) (list x z) (list y z))))
;; (defthm form-z-if-eval-proof-proves-again

;;              (implies (and (form-z-if exp symbols)
;;                            (g-termp (list lhs val) 1 symbols)
;;                            (proves-form-z-if-eval pf-tree exp lhs val given defns symbols)
;;                            (equal form (make-form-z-if exp)))
;;                       (proves (form-z-if-eval-proof pf-tree exp lhs val)
;;                               (f-implies form (f-equal lhs val))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (form-z-if-eval-proof-proves))))
;; (toggle g0858 form-z-if-eval-proof-proves t)
;; ;; proves-rec-form-z-if-eval is similar to proves-z-if, except that
;; ;; in the base case it checks if pf-tree is a proof of "(exp -> concl)".
;; (defun proves-rec-form-z-if-eval
;;       (pf-tree exp concl given defns symbols)
;;       (if (z-ifp exp)
;;           (if (caar pf-tree)
;;               (and (proves (cadar pf-tree) (z-test exp) given defns symbols)
;;                    (proves-rec-form-z-if-eval (cadr pf-tree)
;;                                               (z-left exp)
;;                                               concl
;;                                               given
;;                                               defns
;;                                               symbols))
;;               (and (proves (caddar pf-tree) (f-not (z-test exp)) given defns symbols)
;;                    (proves-rec-form-z-if-eval (caddr pf-tree)
;;                                               (z-right exp)
;;                                               concl
;;                                               given
;;                                               defns
;;                                               symbols)))
;;           (proves pf-tree (f-implies exp concl) given defns symbols)))
;; (defun rec-form-z-if-eval-proof
;;       (pf-tree exp concl)
;;       (if (z-ifp exp)
;;           (if (caar pf-tree)
;;               (chain-proof (make-form-z-if exp)
;;                            concl
;;                            (list (make-form-z-if (z-left exp)))
;;                            (list (f-if-elim-proof1 (z-test exp)
;;                                                    (make-form-z-if (z-left exp))
;;                                                    (make-form-z-if (z-right exp))
;;                                                    (cadar pf-tree))
;;                                  (rec-form-z-if-eval-proof (cadr pf-tree) (z-left exp) concl)))
;;               (chain-proof (make-form-z-if exp)
;;                            concl
;;                            (list (make-form-z-if (z-right exp)))
;;                            (list (f-if-elim-proof2 (z-test exp)
;;                                                    (make-form-z-if (z-left exp))
;;                                                    (make-form-z-if (z-right exp))
;;                                                    (caddar pf-tree))
;;                                  (rec-form-z-if-eval-proof (caddr pf-tree) (z-right exp) concl))))
;;           pf-tree))
;; ;; the lemma below proves that if each of the leaf nodes of an form-if-tree
;; ;; implies a certain conclusion concl, then the if-expression represented by
;; ;; the if-tree implies concl.
;; (defthm rec-form-z-if-eval-proof-proves

;;              (implies (and (form-z-if exp symbols)
;;                            (proves-rec-form-z-if-eval pf-tree exp concl given defns symbols))
;;                       (proves (rec-form-z-if-eval-proof pf-tree exp concl)
;;                               (f-implies (make-form-z-if exp) concl)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0743 rec-form-z-if-eval-proof t)
;; (defthm rec-form-z-if-eval-proof-proves-again

;;              (implies (and (form-z-if exp symbols)
;;                            (proves-rec-form-z-if-eval pf-tree exp concl given defns symbols)
;;                            (equal form (make-form-z-if exp)))
;;                       (proves (rec-form-z-if-eval-proof pf-tree exp concl)
;;                               (f-implies form concl)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0745 rec-form-z-if-eval-proof-proves t)
;; (defthm termp-if

;;              (equal (g-termp (if x y z) flg symbols)
;;                     (if x (g-termp y flg symbols) (g-termp z flg symbols))))
;; (defn
;;  a-get-defn-part-good-proof1
;;  (x y val trace exp pf)
;;  (rec-form-z-if-eval-proof
;;   (list
;;    (list (zerop x)
;;          (z-zerop-ncode-proof x)
;;          (trans-not-equal-proof (ncode 1)
;;                                 (z-zerop (ncode x))
;;                                 (ncode 0)
;;                                 (ncode-nequal-proof 1 0)
;;                                 (z-zerop-ncode-proof x)))
;;    (trans-implies-proof (f-equal val (z-car (ncode y)))
;;                         (f-equal val (ncode (car y)))
;;                         (f-implies exp (f-equal val (ncode (car y))))
;;                         (list-detach-proof (list (f-equal val val)
;;                                                  (f-equal (z-car (ncode y)) (ncode (car y))))
;;                                            (f-implies (f-equal val (z-car (ncode y)))
;;                                                       (f-equal val (ncode (car y))))
;;                                            (list (ident-axiom-proof val) (z-car-ncode-proof y))
;;                                            (equal-axiom2-proof (p 0 2)
;;                                                                (list val (z-car (ncode y)))
;;                                                                (list val (ncode (car y)))))
;;                         (tautconseq-proof nil
;;                                           (f-implies (f-equal val (ncode (car y)))
;;                                                      (f-implies exp
;;                                                                 (f-equal val (ncode (car y)))))
;;                                           nil))
;;    (trans-implies-proof (isin (z-list (list val (z-sub1 (ncode x)) (z-cdr (ncode y)))) trace)
;;                         (isin (z-list (list val (ncode (sub1 x)) (ncode (cdr y)))) trace)
;;                         (f-implies exp (f-equal val (ncode (get x y))))
;;                         (equal-isin-imp-proof (z-list (list val
;;                                                             (z-sub1 (ncode x))
;;                                                             (z-cdr (ncode y))))
;;                                               (z-list (list val
;;                                                             (ncode (sub1 x))
;;                                                             (ncode (cdr y))))
;;                                               trace
;;                                               (equal-z-list-proof (list val
;;                                                                         (z-sub1 (ncode x))
;;                                                                         (z-cdr (ncode y)))
;;                                                                   (list val
;;                                                                         (ncode (sub1 x))
;;                                                                         (ncode (cdr y)))
;;                                                                   (list (ident-axiom-proof val)
;;                                                                         (z-sub1-ncode-proof x)
;;                                                                         (z-cdr-ncode-proof y))))
;;                         pf))
;;   (z-if (f-equal (z-zerop (ncode x)) (ncode 1))
;;         (f-equal val (z-car (ncode y)))
;;         (isin (z-opair val (z-opair (z-sub1 (ncode x)) (z-cdr (ncode y)))) trace))
;;   (f-implies exp (f-equal val (ncode (get x y))))))
;; ;; the second part involves showing that a-get is `good', i.e., that
;; ;; any "trace" satisfying a-get encodes a computation of get.
;; ;; the proof is somewhat tricky but the essential idea is this:
;; ;; we want to prove "a-get(<x>, <y>, val, trace) -> (val = <(get x y)>)".
;; ;; we start with the left-hand side of this implication, it implies that
;; ;;  "(<<x>, <y>, val> in trace)" and hence by the second part of "a-get"
;; ;; that "<<x>, <y>, val>" satisfies the analogue of the definition of get.
;; ;; if (zerop x), then "((z-zerop <x>) = <1>)" and hence "(val = (z-car <y>))"
;; ;; which by the lemma about "z-car" is "(val = <(car y)>)" which is the
;; ;; desired conclusion.  in the case when (zerop x) is f, we have
;; ;; "(a-get(<x>, <y>, val, trace) -> (<val, (z-sub1 <x>), (z-cdr <y>)> in trace))"
;; ;; (call it [1]), the r.h.s. of which is "(<val, <(sub1 x)>, <(cdr y)>> in trace)"
;; ;; by the induction hypothesis,
;; ;; "(a-get(<(sub1 x)>, <(cdr y)>, val, trace) -> (val = <(get (sub1 x)(cdr y))>))" [2].
;; ;; but "a-get(<x>, <y>, val, trace)" and  "(<val, <(sub1 x)>, <(cdr y)>> in trace)" imply
;; ;; "a-get(<(sub1 x)>, <(cdr y)>, val, trace)".  by [1], [2], and the definition of get,
;; ;; we have the desired conclusion.  the lemma below is one portion of the argument
;; ;; above where we prove
;; ;;  |- "(a-get-defn-part(<x>, <y>, val, trace) -> (exp -> (val = <(get x y)>)))",
;; ;; provided when (zerop x) is f,
;; ;;  |- "((<val, <(sub1 x)>, <(cdr y)>> in trace) -> (exp -> (val = <(get x y)>)))".
;; ;;
;; (defthm a-get-defn-part-good-proof1-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (g-termp val 0 symbols)
;;                            (g-termp trace 0 symbols)
;;                            (g-formula exp symbols)
;;                            (equal val-bar (ncode (get x y)))
;;                            (equal form (a-get-defn-part (ncode x) (ncode y) val trace))
;;                            (if (zerop x)
;;                                t
;;                                (proves pf
;;                                        (f-implies (isin (z-list (list val
;;                                                                       (ncode (sub1 x))
;;                                                                       (ncode (cdr y))))
;;                                                         trace)
;;                                                   (f-implies exp (f-equal val val-bar)))
;;                                        given
;;                                        defns
;;                                        symbols)))
;;                       (proves (a-get-defn-part-good-proof1 x y val trace exp pf)
;;                               (f-implies form (f-implies exp (f-equal val val-bar)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable ncode)))
;; (toggle g0615 a-get-defn-part-good-proof1 t)
;; (defun good-frame1-proof
;;       (a b c)
;;       (tautconseq-proof nil (f-iff (f-implies (f-and a b) c) (f-implies b (f-implies a c))) nil))
;; (defthm good-frame1-proof-proves

;;              (implies (and (g-formula a symbols)
;;                            (g-formula b symbols)
;;                            (g-formula c symbols))
;;                       (proves (good-frame1-proof a b c)
;;                               (f-iff (f-implies (f-and a b) c) (f-implies b (f-implies a c)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (eval-tautconseq-proof-proves (flist nil)
;;                                                  (exp (f-iff (f-implies (f-and a b) c)
;;                                                              (f-implies b (f-implies a c))))
;;                                                  (pflist nil)))
;;               (disable eval-tautconseq-proof-proves)))
;; (toggle g0746 good-frame1-proof t)
;; (defun a-get-reduc-proof
;;       (x y val x1 y1 val1 trace)
;;       (f-iff-mp-proof2 (f-implies (a-get x y val x1 y1 val1 trace)
;;                                   (a-get-defn-part x y val trace))
;;                        (f-implies (list-all-quantify (list x1 y1 val1)
;;                                                      (f-implies (isin (z-list (list val1 x1 y1))
;;                                                                       trace)
;;                                                                 (a-get-defn-part x1
;;                                                                                  y1
;;                                                                                  val1
;;                                                                                  trace)))
;;                                   (f-implies (isin (z-list (list val x y)) trace)
;;                                              (a-get-defn-part x y val trace)))
;;                        (good-frame1-proof (isin (z-list (list val x y)) trace)
;;                                           (list-all-quantify (list x1 y1 val1)
;;                                                              (f-implies (isin (z-list (list val1
;;                                                                                             x1
;;                                                                                             y1))
;;                                                                               trace)
;;                                                                         (a-get-defn-part x1
;;                                                                                          y1
;;                                                                                          val1
;;                                                                                          trace)))
;;                                           (a-get-defn-part x y val trace))
;;                        (subst-thm-b-proof (f-implies (isin (z-list (list val1 x1 y1)) trace)
;;                                                      (a-get-defn-part x1 y1 val1 trace))
;;                                           (list x1 y1 val1)
;;                                           (list x y val))))
;; ;;  |- "(a-get(x, y, val, trace) -> a-get-defn-part(x, y, val, trace))".
;; (defthm a-get-reduc-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (g-termp x 0 symbols)
;;                            (g-termp y 0 symbols)
;;                            (g-termp val 0 symbols)
;;                            (var-set (list x1 y1 val1 trace) 4)
;;                            (equal concl
;;                                   (f-implies (a-get x y val x1 y1 val1 trace)
;;                                              (a-get-defn-part x y val trace))))
;;                       (proves (a-get-reduc-proof x y val x1 y1 val1 trace)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0644 a-get-reduc-proof t)
;; (defun good-frame2-proof
;;       (a b c d pf1 pf2)
;;       (tautconseq-proof (list (f-implies (f-and a b) c) (f-implies c (f-implies b d)))
;;                         (f-implies (f-and a b) d)
;;                         (list pf1 pf2)))
;; (defthm good-frame2-proof-proves

;;              (implies (and (g-formula a symbols)
;;                            (g-formula b symbols)
;;                            (g-formula c symbols)
;;                            (g-formula d symbols)
;;                            (proves pf1 (f-implies (f-and a b) c) given defns symbols)
;;                            (proves pf2 (f-implies c (f-implies b d)) given defns symbols))
;;                       (proves (good-frame2-proof a b c d pf1 pf2)
;;                               (f-implies (f-and a b) d)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (eval-tautconseq-proof-proves (flist (list (f-implies (f-and a b) c)
;;                                                               (f-implies c (f-implies b d))))
;;                                                  (exp (f-implies (f-and a b) d))
;;                                                  (pflist (list pf1 pf2))))
;;               (disable eval-tautconseq-proof-proves)))
;; (toggle g0747 good-frame2-proof t)
;; (defun good-frame3-proof
;;       (a b c pf)
;;       (tautconseq-proof (list (f-implies (f-and a b) c)) (f-implies a (f-implies b c)) (list pf)))
;; (defthm good-frame3-proof-proves

;;              (implies (proves pf (f-implies (f-and a b) c) given defns symbols)
;;                       (proves (good-frame3-proof a b c pf)
;;                               (f-implies a (f-implies b c))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (exp (f-implies (f-and a b) c)))
;;                    (eval-tautconseq-proof-proves (flist (list (f-implies (f-and a b) c)))
;;                                                  (exp (f-implies a (f-implies b c)))
;;                                                  (pflist (list pf))))
;;               (disable eval-tautconseq-proof-proves)))
;; (toggle g0748 good-frame3-proof t)
;; (defn
;;  a-get-good-proof
;;  (x y val x1 y1 val1 trace)
;;  (if
;;   (zerop x)
;;   (good-frame2-proof
;;    (isin (z-list (list val (ncode x) (ncode y))) trace)
;;    (list-all-quantify (list x1 y1 val1)
;;                       (f-implies (isin (z-list (list val1 x1 y1)) trace)
;;                                  (a-get-defn-part x1 y1 val1 trace)))
;;    (a-get-defn-part (ncode x) (ncode y) val trace)
;;    (f-equal val (ncode (get x y)))
;;    (a-get-reduc-proof (ncode x) (ncode y) val x1 y1 val1 trace)
;;    (a-get-defn-part-good-proof1 x
;;                                 y
;;                                 val
;;                                 trace
;;                                 (list-all-quantify (list x1 y1 val1)
;;                                                    (f-implies (isin (z-list (list val1 x1 y1))
;;                                                                     trace)
;;                                                               (a-get-defn-part x1
;;                                                                                y1
;;                                                                                val1
;;                                                                                trace)))
;;                                 nil))
;;   (good-frame2-proof
;;    (isin (z-list (list val (ncode x) (ncode y))) trace)
;;    (list-all-quantify (list x1 y1 val1)
;;                       (f-implies (isin (z-list (list val1 x1 y1)) trace)
;;                                  (a-get-defn-part x1 y1 val1 trace)))
;;    (a-get-defn-part (ncode x) (ncode y) val trace)
;;    (f-equal val (ncode (get x y)))
;;    (a-get-reduc-proof (ncode x) (ncode y) val x1 y1 val1 trace)
;;    (a-get-defn-part-good-proof1
;;     x
;;     y
;;     val
;;     trace
;;     (list-all-quantify (list x1 y1 val1)
;;                        (f-implies (isin (z-list (list val1 x1 y1)) trace)
;;                                   (a-get-defn-part x1 y1 val1 trace)))
;;     (good-frame3-proof (isin (z-list (list val (ncode (sub1 x)) (ncode (cdr y)))) trace)
;;                        (list-all-quantify (list x1 y1 val1)
;;                                           (f-implies (isin (z-list (list val1 x1 y1)) trace)
;;                                                      (a-get-defn-part x1 y1 val1 trace)))
;;                        (f-equal val (ncode (get x y)))
;;                        (a-get-good-proof (sub1 x) (cdr y) val x1 y1 val1 trace))))))
;; ;; the desired `good' part:
;; ;;  |- "(a-get(<x>, <y>, val, trace) -> (val = <(get x y)>))".
;; (defthm a-get-good-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (g-termp val 0 symbols)
;;                            (var-set (list x1 y1 val1 trace) 4))
;;                       (proves (a-get-good-proof x y val x1 y1 val1 trace)
;;                               (f-implies (a-get (ncode x) (ncode y) val x1 y1 val1 trace)
;;                                          (f-equal val (ncode (get x y))))
;;                               given
;;                               defns
;;                               symbols))
;;              ((induct (get x y))))
;; (toggle g0749 a-get-good-proof t)
;; (toggle g0750 ncode t)
;; ;; subrp is a function used in the lisp interpreter which checks if a given
;; ;; e-function symbol, i.e., a function symbol in an expression to be interpreted
;; ;; by the lisp interpreter.  the events below introduce the z2 analogue of this
;; ;; function.
;; (defun z-subrp (fn) (list (fn 16 1) fn))
;; (defun z-subrp-defn
;;       (fn y)
;;       (f-if (f-equal fn (ncode 1))
;;             (f-equal y (ncode 1))
;;             (f-if (f-equal fn (ncode 2))
;;                   (f-equal y (ncode 1))
;;                   (f-if (f-equal fn (ncode 3))
;;                         (f-equal y (ncode 1))
;;                         (f-if (f-equal fn (ncode 4))
;;                               (f-equal y (ncode 1))
;;                               (f-if (f-equal fn (ncode 5))
;;                                     (f-equal y (ncode 1))
;;                                     (f-if (f-equal fn (ncode 6))
;;                                           (f-equal y (ncode 1))
;;                                           (f-if (f-equal fn (ncode 7))
;;                                                 (f-equal y (ncode 1))
;;                                                 (f-if (f-equal fn (ncode 8))
;;                                                       (f-equal y (ncode 1))
;;                                                       (f-if (f-equal fn (ncode 9))
;;                                                             (f-equal y (ncode 1))
;;                                                             (f-equal y (phi))))))))))))
;; (defun z-subrp-expr
;;       (fn)
;;       (z-if (f-equal fn (ncode 1))
;;             (ncode 1)
;;             (z-if (f-equal fn (ncode 2))
;;                   (ncode 1)
;;                   (z-if (f-equal fn (ncode 3))
;;                         (ncode 1)
;;                         (z-if (f-equal fn (ncode 4))
;;                               (ncode 1)
;;                               (z-if (f-equal fn (ncode 5))
;;                                     (ncode 1)
;;                                     (z-if (f-equal fn (ncode 6))
;;                                           (ncode 1)
;;                                           (z-if (f-equal fn (ncode 7))
;;                                                 (ncode 1)
;;                                                 (z-if (f-equal fn (ncode 8))
;;                                                       (ncode 1)
;;                                                       (z-if (f-equal fn (ncode 9))
;;                                                             (ncode 1)
;;                                                             (phi)))))))))))
;; (defun z-subrp-exis-proof (fn y) (term-z-if-exis-proof y (z-subrp-expr fn)))
;; (defun z-subrp-unique-proof (fn y y1) (term-z-if-unique-proof y y1 (z-subrp-expr fn)))
;; (defun z-subrp-defn-proof
;;       (fn)
;;       (instance-proof (z-subrp-defun 0 (z-subrp 0))
;;                       (list 0)
;;                       (list fn)
;;                       (fun-defn-proof (fn 16 1)
;;                                       (list 0)
;;                                       1
;;                                       2
;;                                       (z-subrp-defun 0 1)
;;                                       (z-subrp-exis-proof 0 1)
;;                                       (z-subrp-unique-proof 0 1 2))))
;; (defun z-subrp-hyps
;;       (defns symbols)
;;       (and (equal (assoc (fn 16 1) defns) (z-subrp-defun 0 (z-subrp 0)))
;;            (subset (list (fn 3 1) (fn 1 2) (fn 0 0)) (rest-of (fn 16 1) symbols))))
;; (defthm z-subrp-defn-proof-proves

;;              (implies (and (subset (list (fn 16 1) (fn 0 0) (fn 3 1) (fn 1 2)) symbols)
;;                            (z-subrp-hyps defns symbols)
;;                            (g-termp x 0 symbols)
;;                            (equal concl (z-subrp-defun x (z-subrp x))))
;;                       (proves (z-subrp-defn-proof x) concl given defns symbols)))
;; (toggle g0751 z-subrp-defn-proof t)
;; (toggle g0752 z-subrp-hyps t)
;; (defun subrp
;;       (fn)
;;       (or (equal fn 1)
;;           (equal fn 2)
;;           (equal fn 3)
;;           (equal fn 4)
;;           (equal fn 5)
;;           (equal fn 6)
;;           (equal fn 7)
;;           (equal fn 8)
;;           (equal fn 9)))
;; (defn
;;  z-subrp-ncode-proof
;;  (fn)
;;  (z-if-eval-proof1
;;   (list
;;    (list (equal fn 1) (ident-axiom-proof (ncode 1)) (ncode-nequal-proof fn 1))
;;    (ident-axiom-proof (ncode 1))
;;    (list (list (equal fn 2) (ident-axiom-proof (ncode 2)) (ncode-nequal-proof fn 2))
;;          (ident-axiom-proof (ncode 1))
;;          (list (list (equal fn 3) (ident-axiom-proof (ncode 3)) (ncode-nequal-proof fn 3))
;;                (ident-axiom-proof (ncode 1))
;;                (list (list (equal fn 4)
;;                            (ident-axiom-proof (ncode 4))
;;                            (ncode-nequal-proof fn 4))
;;                      (ident-axiom-proof (ncode 1))
;;                      (list (list (equal fn 5)
;;                                  (ident-axiom-proof (ncode 5))
;;                                  (ncode-nequal-proof fn 5))
;;                            (ident-axiom-proof (ncode 1))
;;                            (list (list (equal fn 6)
;;                                        (ident-axiom-proof (ncode 6))
;;                                        (ncode-nequal-proof fn 6))
;;                                  (ident-axiom-proof (ncode 1))
;;                                  (list (list (equal fn 7)
;;                                              (ident-axiom-proof (ncode 7))
;;                                              (ncode-nequal-proof fn 7))
;;                                        (ident-axiom-proof (ncode 1))
;;                                        (list (list (equal fn 8)
;;                                                    (ident-axiom-proof (ncode 8))
;;                                                    (ncode-nequal-proof fn 8))
;;                                              (ident-axiom-proof (ncode 1))
;;                                              (list (list (equal fn 9)
;;                                                          (ident-axiom-proof (ncode 9))
;;                                                          (ncode-nequal-proof fn 9))
;;                                                    (ident-axiom-proof (ncode 1))
;;                                                    (ident-axiom-proof (phi)))))))))))
;;   (z-subrp-expr (ncode fn))
;;   (z-subrp (ncode fn))
;;   (ncode (bool-fix (subrp fn)))
;;   (z-subrp-defn-proof (ncode fn))))
;; (defthm z-subrp-ncode-proof-proves

;;              (implies (and (subset (list (fn 16 1)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (p 2 1)
;;                                          (p 1 2))
;;                                    symbols)
;;                            (z-subrp-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-subrp (ncode fn)) (ncode (bool-fix (subrp fn))))))
;;                       (proves (z-subrp-ncode-proof fn) concl given defns symbols)))
;; (toggle g0753 z-subrp-ncode-proof t)
;; (toggle g0754 subrp t)
;; (defun eg-proof
;;       (exp vars terms pf)
;;       (detach-proof (parallel-subst exp vars terms 0)
;;                     (list-exis-quantify vars exp)
;;                     pf
;;                     (subst-thm-a-proof exp vars terms)))
;; ;;  if |- "[a1/x1,..., an/xn]a", then |- "(forsome x1,...,xn a)".
;; (defthm eg-proof-proves

;;              (implies (and (g-formula exp symbols)
;;                            (g-termp terms 1 symbols)
;;                            (equal (length vars) (length terms))
;;                            (var-set vars (length vars))
;;                            (free-for-list exp vars terms)
;;                            (proves pf (parallel-subst exp vars terms 0) given defns symbols)
;;                            (equal concl (list-exis-quantify vars exp)))
;;                       (proves (eg-proof exp vars terms pf) concl given defns symbols)))
;; (toggle g0479 eg-proof t)
;; (defthm a-get-ok-proof-proves-again

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (var-set (list val1 x1 y1) 3)
;;                            (equal concl
;;                                   (a-get (ncode x)
;;                                          (ncode y)
;;                                          (ncode (get x y))
;;                                          x1
;;                                          y1
;;                                          val1
;;                                          (graph-trans (get-graph x y)))))
;;                       (proves (a-get-ok-proof1 x y x1 y1 val1) concl given defns symbols))
;;              ((disable subset var-set a-get)))
;; (toggle g0773 a-get-ok-proof-proves t)
;; (defun a-get1 (x y val x1 y1 val1 trace) (forsome trace (a-get x y val x1 y1 val1 trace)))
;; (defun a-get1-ok-proof
;;       (x y x1 y1 val1 trace)
;;       (eg-proof (a-get (ncode x) (ncode y) (ncode (get x y)) x1 y1 val1 trace)
;;                 (list trace)
;;                 (list (graph-trans (get-graph x y)))
;;                 (a-get-ok-proof1 x y x1 y1 val1)))
;; (defthm parallel-subst-ncode

;;              (equal (parallel-subst (ncode x) vars terms 0) (ncode x)))
;; (defthm subst-ncode (equal (g-subst (ncode x) var term 0) (ncode x)))
;; (defthm parallel-subst-graph-trans

;;              (equal (parallel-subst (graph-trans x) vars terms 0) (graph-trans x)))
;; (defthm subst-graph-trans

;;              (equal (g-subst (graph-trans x) var term 0) (graph-trans x)))
;; (toggle g0755 not-free-parallel-subst t)
;; (toggle g0759 not-free-del-pairs-parallel-subst t)
;; (toggle g0768 parallel-subst-nil t)
;; (toggle g0771 parallel-subst-not-free-var t)
;; (toggle g0772 not-member-del-pairs t)
;; (defthm free-for-nil

;;              (implies (equal (collect-free term 0) nil) (free-for exp var term flg)))
;; (defun nil-list-collect-free
;;       (x)
;;       (if (consp x)
;;           (and (equal (collect-free (car x) 0) nil)
;;                (nil-list-collect-free (cdr x)))
;;           t))
;; (defthm free-for-list-nil-list

;;              (implies (nil-list-collect-free terms) (free-for-list exp vars terms)))
;; (toggle g0774 free-for-list t)
;; (defthm consp-parallel-subst

;;              (implies (consp exp) (consp (parallel-subst exp vars terms flg))))
;; (defthm parallel-subst-z-list

;;              (equal (parallel-subst (z-list list) vars terms 0)
;;                     (z-list (parallel-subst list vars terms 1))))
;; (toggle g0775 consp-parallel-subst t)
;; (defthm a-get1-ok-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (var-set (list val1 x1 y1 trace) 4)
;;                            (equal concl
;;                                   (a-get1 (ncode x)
;;                                           (ncode y)
;;                                           (ncode (get x y))
;;                                           x1
;;                                           y1
;;                                           val1
;;                                           trace)))
;;                       (proves (a-get1-ok-proof x y x1 y1 val1 trace) concl given defns symbols)))
;; (toggle g0776 a-get1-ok-proof t)
;; (defthm a-get-good-proof-proves-again

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (g-termp val 0 symbols)
;;                            (var-set (list x1 y1 val1 trace) 4)
;;                            (equal concl
;;                                   (f-implies (a-get (ncode x) (ncode y) val x1 y1 val1 trace)
;;                                              (f-equal val (ncode (get x y))))))
;;                       (proves (a-get-good-proof x y val x1 y1 val1 trace)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable subset var-set a-get) (use (a-get-good-proof-proves))))
;; (toggle g0777 a-get-good-proof-proves t)
;; (defun a-get1-good-proof
;;       (x y val x1 y1 val1 trace)
;;       (forsome-intro-proof trace
;;                            (g-body (a-get1 (ncode x) (ncode y) val x1 y1 val1 trace))
;;                            (f-equal val (ncode (get x y)))
;;                            (a-get-good-proof x y val x1 y1 val1 trace)))
;; (defthm a-get1-good-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (g-termp val 0 symbols)
;;                            (not (member trace (collect-free val 0)))
;;                            (var-set (list x1 y1 val1 trace) 4)
;;                            (equal concl
;;                                   (f-implies (a-get1 (ncode x) (ncode y) val x1 y1 val1 trace)
;;                                              (f-equal val (ncode (get x y))))))
;;                       (proves (a-get1-good-proof x y val x1 y1 val1 trace)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0778 a-get1-good-proof t)
;; ;; the next several pages cover the proof of the representability of the
;; ;; lisp interpreter ev.  apart from the e-expression to be evaluated,
;; ;; the e-variable bindings list, and the e-function symbol bindings list,
;; ;; the interpreter takes a counter n which is the maximum permissible
;; ;; depth of the evaluation stack.  if this bound is exceeded before the
;; ;; expression is fully evaluated, ev returns a bottom object (btm).
;; ;; this object is added by as a shell by the command below.
;; (add-shell btm nil btmp nil)
;; (defun equal-z-list-isin-proof
;;       (list1 list2 exp pflist pf)
;;       (equal-isin-proof (z-list list1)
;;                         (z-list list2)
;;                         exp
;;                         (equal-z-list-proof list1 list2 pflist)
;;                         pf))
;; (defun equal-z-list-isin-imp-proof
;;       (list1 list2 exp pflist)
;;       (equal-isin-imp-proof (z-list list1)
;;                             (z-list list2)
;;                             exp
;;                             (equal-z-list-proof list1 list2 pflist)))
;; (defthm ncode-cons

;;              (equal (ncode (cons x y)) (z-opair (ncode x) (ncode y)))
;;              ((enable ncode)))
;; (toggle g0781 proves-is-formula-again t)
;; (toggle g0782 termp-term-list t)
;; (toggle g0783 term-list-var-list t)
;; (defun ev-equal-z-list-proof
;;       (val flg exp expr va fa pf)
;;       (equal-z-list-proof (list val (ncode flg) (ncode exp) (ncode va) (ncode fa))
;;                           (list val (ncode flg) expr (ncode va) (ncode fa))
;;                           (list (ident-axiom-proof val)
;;                                 (ident-axiom-proof (ncode flg))
;;                                 (flip-equals-proof expr (ncode exp) pf)
;;                                 (ident-axiom-proof (ncode va))
;;                                 (ident-axiom-proof (ncode fa)))))
;; (defun ev-equal-z-list-isin-proof
;;       (val flg exp expr va fa trace pf in-pf)
;;       (equal-z-list-isin-proof (list val (ncode flg) (ncode exp) (ncode va) (ncode fa))
;;                                (list val (ncode flg) expr (ncode va) (ncode fa))
;;                                trace
;;                                (list (ident-axiom-proof val)
;;                                      (ident-axiom-proof (ncode flg))
;;                                      (flip-equals-proof expr (ncode exp) pf)
;;                                      (ident-axiom-proof (ncode va))
;;                                      (ident-axiom-proof (ncode fa)))
;;                                in-pf))
;; (defthm ev-equal-z-list-proof-proves

;;              (implies (and (subset (list (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (g-termp val 0 symbols)
;;                            (proves pf (f-equal expr (ncode exp)) given defns symbols)
;;                            (equal concl
;;                                   (f-equal (z-list (list val
;;                                                          (ncode flg)
;;                                                          (ncode exp)
;;                                                          (ncode va)
;;                                                          (ncode fa)))
;;                                            (z-list (list val
;;                                                          (ncode flg)
;;                                                          expr
;;                                                          (ncode va)
;;                                                          (ncode fa))))))
;;                       (proves (ev-equal-z-list-proof val flg exp expr va fa pf)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list) (use (proves-is-formula (exp (f-equal expr (ncode exp)))))))
;; (toggle g0789 ev-equal-z-list-proof t)
;; (defthm ev-equal-z-list-isin-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (g-termp val 0 symbols)
;;                            (g-termp trace 0 symbols)
;;                            (proves in-pf
;;                                    (isin (z-list (list val
;;                                                        (ncode flg)
;;                                                        (ncode exp)
;;                                                        (ncode va)
;;                                                        (ncode fa)))
;;                                          trace)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (proves pf (f-equal expr (ncode exp)) given defns symbols)
;;                            (equal concl
;;                                   (isin (z-list (list val
;;                                                       (ncode flg)
;;                                                       expr
;;                                                       (ncode va)
;;                                                       (ncode fa)))
;;                                         trace)))
;;                       (proves (ev-equal-z-list-isin-proof val flg exp expr va fa trace pf in-pf)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list) (use (proves-is-formula (exp (f-equal expr (ncode exp)))))))
;; (toggle g0792 ev-equal-z-list-isin-proof t)
;; ;; the skeleton of the representability proof for ev is similar to that of get, but
;; ;; the details are enormously more complicated since ev is an extremely complicated
;; ;; function.  in the first `ok' part of the proof, we prove each section of ev to
;; ;; be `ok' separately.  below, the part of ev which evaluates lisp if-expressions
;; ;; is proved `ok'.
;; (defun a-ev-defn-if1-ok-proof
;;       (exp va fa val test trace in-pf2 in-pf3)
;;       (form-z-if-ok-proof (list (list (ncode-equal test 0)
;;                                       (ident-axiom-proof (ncode test))
;;                                       (ncode-nequal-proof test 0))
;;                                 (ev-equal-z-list-isin-proof val
;;                                                             0
;;                                                             (cadddr exp)
;;                                                             (z-car-cdr (ncode exp) (list 1 2 2 2))
;;                                                             va
;;                                                             fa
;;                                                             trace
;;                                                             (z-car-cdr-proof exp (list 1 2 2 2))
;;                                                             in-pf2)
;;                                 (ev-equal-z-list-isin-proof val
;;                                                             0
;;                                                             (caddr exp)
;;                                                             (z-car-cdr (ncode exp) (list 1 2 2))
;;                                                             va
;;                                                             fa
;;                                                             trace
;;                                                             (z-car-cdr-proof exp (list 1 2 2))
;;                                                             in-pf3))
;;                           (z-if (f-equal (ncode test) (ncode 0))
;;                                 (isin (z-list (list val
;;                                                     (ncode 0)
;;                                                     (z-car-cdr (ncode exp) (list 1 2 2 2))
;;                                                     (ncode va)
;;                                                     (ncode fa)))
;;                                       trace)
;;                                 (isin (z-list (list val
;;                                                     (ncode 0)
;;                                                     (z-car-cdr (ncode exp) (list 1 2 2))
;;                                                     (ncode va)
;;                                                     (ncode fa)))
;;                                       trace))))
;; (toggle g0797 termp-car-cdr t)
;; (defthm a-ev-defn-if1-ok-proof-proves

;;              (implies (and (subset (list (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (g-termp trace 0 symbols)
;;                            (if (ncode-equal test 0)
;;                                (proves in-pf2
;;                                        (isin (z-list (list (ncode val)
;;                                                            (ncode 0)
;;                                                            (ncode (cadddr exp))
;;                                                            (ncode va)
;;                                                            (ncode fa)))
;;                                              trace)
;;                                        given
;;                                        defns
;;                                        symbols)
;;                                (proves in-pf3
;;                                        (isin (z-list (list (ncode val)
;;                                                            (ncode 0)
;;                                                            (ncode (caddr exp))
;;                                                            (ncode va)
;;                                                            (ncode fa)))
;;                                              trace)
;;                                        given
;;                                        defns
;;                                        symbols))
;;                            (equal concl
;;                                   (f-if (f-equal (ncode test) (ncode 0))
;;                                         (isin (z-list (list (ncode val)
;;                                                             (ncode 0)
;;                                                             (z-car-cdr (ncode exp)
;;                                                                        (list 1 2 2 2))
;;                                                             (ncode va)
;;                                                             (ncode fa)))
;;                                               trace)
;;                                         (isin (z-list (list (ncode val)
;;                                                             (ncode 0)
;;                                                             (z-car-cdr (ncode exp)
;;                                                                        (list 1 2 2))
;;                                                             (ncode va)
;;                                                             (ncode fa)))
;;                                               trace))))
;;                       (proves (a-ev-defn-if1-ok-proof exp
;;                                                       va
;;                                                       fa
;;                                                       (ncode val)
;;                                                       test
;;                                                       trace
;;                                                       in-pf2
;;                                                       in-pf3)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list)))
;; (toggle g0798 a-ev-defn-if1-ok-proof t)
;; (defun a-ev-if-part
;;       (exp-bar va-bar fa-bar val-bar trace rvar1)
;;       (forsome rvar1
;;                (f-and (isin (z-list (list rvar1 (ncode 0) (z-car (z-cdr exp-bar)) va-bar fa-bar))
;;                             trace)
;;                       (f-if (f-equal rvar1 (ncode 0))
;;                             (isin (z-list (list val-bar
;;                                                 (ncode 0)
;;                                                 (z-car-cdr exp-bar (list 1 2 2 2))
;;                                                 va-bar
;;                                                 fa-bar))
;;                                   trace)
;;                             (isin (z-list (list val-bar
;;                                                 (ncode 0)
;;                                                 (z-car-cdr exp-bar (list 1 2 2))
;;                                                 va-bar
;;                                                 fa-bar))
;;                                   trace)))))
;; (defun a-ev-defn-if-ok-proof
;;       (exp va fa val test rvar1 graph in-pf1 in-pf2 in-pf3)
;;       (eg-proof (f-and (isin (z-list (list rvar1
;;                                            (ncode 0)
;;                                            (z-car (z-cdr (ncode exp)))
;;                                            (ncode va)
;;                                            (ncode fa)))
;;                              (graph-trans graph))
;;                        (f-if (f-equal rvar1 (ncode 0))
;;                              (isin (z-list (list (ncode val)
;;                                                  (ncode 0)
;;                                                  (z-car-cdr (ncode exp) (list 1 2 2 2))
;;                                                  (ncode va)
;;                                                  (ncode fa)))
;;                                    (graph-trans graph))
;;                              (isin (z-list (list (ncode val)
;;                                                  (ncode 0)
;;                                                  (z-car-cdr (ncode exp) (list 1 2 2))
;;                                                  (ncode va)
;;                                                  (ncode fa)))
;;                                    (graph-trans graph))))
;;                 (list rvar1)
;;                 (list (ncode test))
;;                 (and-join-proof (isin (z-list (list (ncode test)
;;                                                     (ncode 0)
;;                                                     (z-car (z-cdr (ncode exp)))
;;                                                     (ncode va)
;;                                                     (ncode fa)))
;;                                       (graph-trans graph))
;;                                 (f-if (f-equal (ncode test) (ncode 0))
;;                                       (isin (z-list (list (ncode val)
;;                                                           (ncode 0)
;;                                                           (z-car-cdr (ncode exp) (list 1 2 2 2))
;;                                                           (ncode va)
;;                                                           (ncode fa)))
;;                                             (graph-trans graph))
;;                                       (isin (z-list (list (ncode val)
;;                                                           (ncode 0)
;;                                                           (z-car-cdr (ncode exp) (list 1 2 2))
;;                                                           (ncode va)
;;                                                           (ncode fa)))
;;                                             (graph-trans graph)))
;;                                 (ev-equal-z-list-isin-proof (ncode test)
;;                                                             0
;;                                                             (cadr exp)
;;                                                             (z-car (z-cdr (ncode exp)))
;;                                                             va
;;                                                             fa
;;                                                             (graph-trans graph)
;;                                                             (z-car-cdr-proof exp (list 1 2))
;;                                                             in-pf1)
;;                                 (a-ev-defn-if1-ok-proof exp
;;                                                         va
;;                                                         fa
;;                                                         (ncode val)
;;                                                         test
;;                                                         (graph-trans graph)
;;                                                         in-pf2
;;                                                         in-pf3))))
;; (defthm a-ev-defn-if-ok-proof-proves

;;              (implies (and (subset (list (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (g-variable rvar1)
;;                            (proves in-pf1
;;                                    (isin (z-list (list (ncode test)
;;                                                        (ncode 0)
;;                                                        (ncode (cadr exp))
;;                                                        (ncode va)
;;                                                        (ncode fa)))
;;                                          (graph-trans graph))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (if (ncode-equal test 0)
;;                                (proves in-pf2
;;                                        (isin (z-list (list (ncode val)
;;                                                            (ncode 0)
;;                                                            (ncode (cadddr exp))
;;                                                            (ncode va)
;;                                                            (ncode fa)))
;;                                              (graph-trans graph))
;;                                        given
;;                                        defns
;;                                        symbols)
;;                                (proves in-pf3
;;                                        (isin (z-list (list (ncode val)
;;                                                            (ncode 0)
;;                                                            (ncode (caddr exp))
;;                                                            (ncode va)
;;                                                            (ncode fa)))
;;                                              (graph-trans graph))
;;                                        given
;;                                        defns
;;                                        symbols))
;;                            (equal concl
;;                                   (a-ev-if-part (ncode exp)
;;                                                 (ncode va)
;;                                                 (ncode fa)
;;                                                 (ncode val)
;;                                                 (graph-trans graph)
;;                                                 rvar1)))
;;                       (proves (a-ev-defn-if-ok-proof exp
;;                                                      va
;;                                                      fa
;;                                                      val
;;                                                      test
;;                                                      rvar1
;;                                                      graph
;;                                                      in-pf1
;;                                                      in-pf2
;;                                                      in-pf3)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable atom-ncode z-list)))
;; (toggle g0799 a-ev-defn-if-ok-proof t)
;; ;; the z2 representation of the part of ev which evaluates lisp primitives is proved
;; ;; `ok' below.
;; (defun a-ev-subr-part
;;       (exp va fa val rvar trace)
;;       (forsome rvar
;;                (f-and (isin (z-list (list rvar
;;                                           (ncode 1)
;;                                           (z-cdr (ncode exp))
;;                                           (ncode va)
;;                                           (ncode fa)))
;;                             trace)
;;                       (f-equal val (z-apply-subr (z-car (ncode exp)) rvar)))))
;; (defn
;;  a-ev-defn-subr-ok-proof
;;  (exp va fa val rval rvar graph in-pf)
;;  (eg-proof
;;   (f-and (isin (z-list (list rvar (ncode 1) (z-cdr (ncode exp)) (ncode va) (ncode fa)))
;;                (graph-trans graph))
;;          (f-equal val (z-apply-subr (z-car (ncode exp)) rvar)))
;;   (list rvar)
;;   (list (ncode rval))
;;   (and-join-proof (isin (z-list (list (ncode rval)
;;                                       (ncode 1)
;;                                       (z-cdr (ncode exp))
;;                                       (ncode va)
;;                                       (ncode fa)))
;;                         (graph-trans graph))
;;                   (f-equal val (z-apply-subr (z-car (ncode exp)) (ncode rval)))
;;                   (ev-equal-z-list-isin-proof (ncode rval)
;;                                               1
;;                                               (cdr exp)
;;                                               (z-cdr (ncode exp))
;;                                               va
;;                                               fa
;;                                               (graph-trans graph)
;;                                               (z-cdr-ncode-proof exp)
;;                                               in-pf)
;;                   (flip-equals-proof (z-apply-subr (z-car (ncode exp)) (ncode rval))
;;                                      val
;;                                      (compose-proof (fn 15 2)
;;                                                     val
;;                                                     (list (z-car (ncode exp)) (ncode rval))
;;                                                     (list (ncode (car exp)) (ncode rval))
;;                                                     (list (z-car-ncode-proof exp)
;;                                                           (ident-axiom-proof (ncode rval)))
;;                                                     (z-apply-subr-ncode-proof (car exp) rval))))))
;; (defthm a-ev-defn-subr-ok-proof-proves

;;              (implies (and (subset (list (fn 15 2)
;;                                          (fn 14 2)
;;                                          (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (p 2 1)
;;                                          (p 1 2))
;;                                    symbols)
;;                            (z-apply-subr-all-hyps given defns symbols)
;;                            (g-variable rvar)
;;                            (proves in-pf
;;                                    (isin (z-list (list (ncode rval)
;;                                                        (ncode 1)
;;                                                        (ncode (cdr exp))
;;                                                        (ncode va)
;;                                                        (ncode fa)))
;;                                          (graph-trans graph))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal val (ncode (apply-subr (car exp) rval)))
;;                            (equal concl (a-ev-subr-part exp va fa val rvar (graph-trans graph))))
;;                       (proves (a-ev-defn-subr-ok-proof exp va fa val rval rvar graph in-pf)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0802 a-ev-defn-subr-ok-proof t)
;; (toggle g0803 get t)
;; (toggle g0809 pairlist t)
;; (toggle g0816 not-free-covering t)
;; ;; the e-functions symbols 0 is used for the lisp function if, the symbols 1-9
;; ;; are used for the lisp primitives, 10 is used for the quote function.  the defined
;; ;; e-function symbols therefore start from 11.  since the first definition in the
;; ;; function definition list corresponds to 11, we have to subtract 11 from the symbol
;; ;; before we apply get to the definition list.  the function sub1-n subtracts n
;; ;; from exp.  it is represented in z2 by an iterated application of z-sub1.
;; (defun z-sub1-n (exp n) (if (zerop n) exp (z-sub1 (z-sub1-n exp (sub1 n)))))
;; (defun sub1-n (exp n) (if (zerop n) exp (sub1 (sub1-n exp (sub1 n)))))
;; (defun z-sub1-n-ncode-proof
;;       (exp n val pf)
;;       (if (zerop n)
;;           pf
;;           (compose-proof (fn 10 1)
;;                          (ncode (sub1-n val n))
;;                          (list (z-sub1-n exp (sub1 n)))
;;                          (list (ncode (sub1-n val (sub1 n))))
;;                          (list (z-sub1-n-ncode-proof exp (sub1 n) val pf))
;;                          (z-sub1-ncode-proof (sub1-n val (sub1 n))))))
;; (defthm term-z-sub1-n

;;              (implies (and (member (fn 10 1) symbols)
;;                            (g-termp exp 0 symbols))
;;                       (g-termp (z-sub1-n exp n) 0 symbols)))
;; (defthm z-sub1-n-ncode-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 3 1)
;;                                          (p 2 1)
;;                                          (p 1 2)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (proves pf (f-equal exp (ncode val)) given defns symbols)
;;                            (equal concl (f-equal (z-sub1-n exp n) (ncode (sub1-n val n)))))
;;                       (proves (z-sub1-n-ncode-proof exp n val pf) concl given defns symbols))
;;              ((use (proves-is-formula (exp (f-equal exp (ncode val)))))))
;; (toggle g0817 z-sub1-n-ncode-proof t)
;; (toggle g0818 sub1-n t)
;; ;; next we prove the representation of that part of ev which evaluates defined lisp
;; ;; functions, to be `ok'.
;; (defun a-ev-fun-part
;;       (exp va fa val trace)
;;       (forsome 11
;;                (list-all-quantify (list 15 16)
;;                                   (f-and (isin (z-list (list 11
;;                                                              (ncode 1)
;;                                                              (z-cdr (ncode exp))
;;                                                              (ncode va)
;;                                                              (ncode fa)))
;;                                                trace)
;;                                          (f-implies (a-get (z-sub1-n (z-car (ncode exp)) 11)
;;                                                            (ncode fa)
;;                                                            15
;;                                                            11
;;                                                            13
;;                                                            14
;;                                                            16)
;;                                                     (isin (z-list (list val
;;                                                                         (ncode 0)
;;                                                                         15
;;                                                                         11
;;                                                                         (ncode fa)))
;;                                                           trace))))))
;; (defthm formula-list-all-quantify

;;              (implies (and (var-list vars (length vars))
;;                            (g-formula exp symbols))
;;                       (g-formula (list-all-quantify vars exp) symbols)))
;; (defthm list-gen-proof-proves-again

;;              (implies (and (var-list vars (length vars))
;;                            (proves pf exp given defns symbols)
;;                            (equal concl (list-all-quantify vars exp)))
;;                       (proves (list-gen-proof vars exp pf) concl given defns symbols))
;;              ((use (list-gen-proof-proves))))
;; (defn
;;  a-get-ev-reduc-proof
;;  (exp fa getval n x1 y1 val1 tr1)
;;  (tautconseq-proof
;;   (list (f-implies (isin (z-list (list getval (z-sub1-n (z-car (ncode exp)) n) (ncode fa))) tr1)
;;                    (isin (z-list (list getval (ncode (sub1-n (car exp) n)) (ncode fa))) tr1))
;;         (f-implies (a-get (ncode (sub1-n (car exp) n)) (ncode fa) getval x1 y1 val1 tr1)
;;                    (f-equal getval (ncode (get (sub1-n (car exp) n) fa)))))
;;   (f-implies (a-get (z-sub1-n (z-car (ncode exp)) n) (ncode fa) getval x1 y1 val1 tr1)
;;              (f-equal getval (ncode (get (sub1-n (car exp) n) fa))))
;;   (list (equal-z-list-isin-imp-proof (list getval (z-sub1-n (z-car (ncode exp)) n) (ncode fa))
;;                                      (list getval (ncode (sub1-n (car exp) n)) (ncode fa))
;;                                      tr1
;;                                      (list (ident-axiom-proof getval)
;;                                            (z-sub1-n-ncode-proof (z-car (ncode exp))
;;                                                                  n
;;                                                                  (car exp)
;;                                                                  (z-car-ncode-proof exp))
;;                                            (ident-axiom-proof (ncode fa))))
;;         (a-get-good-proof (sub1-n (car exp) n) fa getval x1 y1 val1 tr1))))
;; (defn
;;  a-ev-defn-fun-ok-proof
;;  (exp va fa val rval graph in-pf1 in-pf2)
;;  (eg-proof
;;   (list-all-quantify (list 15 16)
;;                      (f-and (isin (z-list (list 11
;;                                                 (ncode 1)
;;                                                 (z-cdr (ncode exp))
;;                                                 (ncode va)
;;                                                 (ncode fa)))
;;                                   (graph-trans graph))
;;                             (f-implies (a-get (z-sub1-n (z-car (ncode exp)) 11)
;;                                               (ncode fa)
;;                                               15
;;                                               11
;;                                               13
;;                                               14
;;                                               16)
;;                                        (isin (z-list (list val (ncode 0) 15 11 (ncode fa)))
;;                                              (graph-trans graph)))))
;;   (list 11)
;;   (list (ncode rval))
;;   (list-gen-proof
;;    (list 15 16)
;;    (f-and (isin (z-list (list (ncode rval) (ncode 1) (z-cdr (ncode exp)) (ncode va) (ncode fa)))
;;                 (graph-trans graph))
;;           (f-implies (a-get (z-sub1-n (z-car (ncode exp)) 11) (ncode fa) 15 11 13 14 16)
;;                      (isin (z-list (list val (ncode 0) 15 (ncode rval) (ncode fa)))
;;                            (graph-trans graph))))
;;    (and-join-proof
;;     (isin (z-list (list (ncode rval) (ncode 1) (z-cdr (ncode exp)) (ncode va) (ncode fa)))
;;           (graph-trans graph))
;;     (f-implies (a-get (z-sub1-n (z-car (ncode exp)) 11) (ncode fa) 15 11 13 14 16)
;;                (isin (z-list (list val (ncode 0) 15 (ncode rval) (ncode fa)))
;;                      (graph-trans graph)))
;;     (ev-equal-z-list-isin-proof (ncode rval)
;;                                 1
;;                                 (cdr exp)
;;                                 (z-cdr (ncode exp))
;;                                 va
;;                                 fa
;;                                 (graph-trans graph)
;;                                 (z-cdr-ncode-proof exp)
;;                                 in-pf1)
;;     (chain-proof (a-get (z-sub1-n (z-car (ncode exp)) 11) (ncode fa) 15 11 13 14 16)
;;                  (isin (z-list (list val (ncode 0) 15 (ncode rval) (ncode fa)))
;;                        (graph-trans graph))
;;                  (list (f-equal 15 (ncode (get (sub1-n (car exp) 11) fa))))
;;                  (list (a-get-ev-reduc-proof exp fa 15 11 11 13 14 16)
;;                        (form-equal-case-proof (list 15)
;;                                               (list (ncode (get (sub1-n (car exp) 11) fa)))
;;                                               (isin (z-list (list val
;;                                                                   (ncode 0)
;;                                                                   15
;;                                                                   (ncode rval)
;;                                                                   (ncode fa)))
;;                                                     (graph-trans graph))
;;                                               in-pf2)))))))
;; (defthm parallel-subst-z-sub1-n

;;              (equal (parallel-subst (z-sub1-n exp n) vars terms 0)
;;                     (z-sub1-n (parallel-subst exp vars terms 0) n)))
;; (defthm a-ev-defn-fun-ok-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (proves in-pf1
;;                                    (isin (z-list (list (ncode rval)
;;                                                        (ncode 1)
;;                                                        (ncode (cdr exp))
;;                                                        (ncode va)
;;                                                        (ncode fa)))
;;                                          (graph-trans graph))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (proves in-pf2
;;                                    (isin (z-list (list (ncode val)
;;                                                        (ncode 0)
;;                                                        (ncode (get (sub1-n (car exp) 11) fa))
;;                                                        (ncode rval)
;;                                                        (ncode fa)))
;;                                          (graph-trans graph))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl
;;                                   (a-ev-fun-part exp va fa (ncode val) (graph-trans graph))))
;;                       (proves (a-ev-defn-fun-ok-proof exp
;;                                                       va
;;                                                       fa
;;                                                       (ncode val)
;;                                                       rval
;;                                                       graph
;;                                                       in-pf1
;;                                                       in-pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0819 a-ev-defn-fun-ok-proof t)
;; ;; finally we prove the representation of the part of ev which evaluates lists
;; ;; of e-expressions to be `ok'.
;; (defn
;;  a-ev-defn-list-ok-proof
;;  (exp va fa rval1 rval2 rvar1 rvar2 graph in-pf1 in-pf2)
;;  (eg-proof (f-and (isin (z-list (list rvar1 (ncode 0) (z-car (ncode exp)) (ncode va) (ncode fa)))
;;                         (graph-trans graph))
;;                   (f-and (isin (z-list (list rvar2
;;                                              (ncode 1)
;;                                              (z-cdr (ncode exp))
;;                                              (ncode va)
;;                                              (ncode fa)))
;;                                (graph-trans graph))
;;                          (f-equal (ncode (cons rval1 rval2)) (z-opair rvar1 rvar2))))
;;            (list rvar1 rvar2)
;;            (list (ncode rval1) (ncode rval2))
;;            (and-join-proof (isin (z-list (list (ncode rval1)
;;                                                (ncode 0)
;;                                                (z-car (ncode exp))
;;                                                (ncode va)
;;                                                (ncode fa)))
;;                                  (graph-trans graph))
;;                            (f-and (isin (z-list (list (ncode rval2)
;;                                                       (ncode 1)
;;                                                       (z-cdr (ncode exp))
;;                                                       (ncode va)
;;                                                       (ncode fa)))
;;                                         (graph-trans graph))
;;                                   (f-equal (ncode (cons rval1 rval2))
;;                                            (z-opair (ncode rval1) (ncode rval2))))
;;                            (ev-equal-z-list-isin-proof (ncode rval1)
;;                                                        0
;;                                                        (car exp)
;;                                                        (z-car (ncode exp))
;;                                                        va
;;                                                        fa
;;                                                        (graph-trans graph)
;;                                                        (z-car-ncode-proof exp)
;;                                                        in-pf1)
;;                            (and-join-proof (isin (z-list (list (ncode rval2)
;;                                                                (ncode 1)
;;                                                                (z-cdr (ncode exp))
;;                                                                (ncode va)
;;                                                                (ncode fa)))
;;                                                  (graph-trans graph))
;;                                            (f-equal (ncode (cons rval1 rval2))
;;                                                     (z-opair (ncode rval1) (ncode rval2)))
;;                                            (ev-equal-z-list-isin-proof (ncode rval2)
;;                                                                        1
;;                                                                        (cdr exp)
;;                                                                        (z-cdr (ncode exp))
;;                                                                        va
;;                                                                        fa
;;                                                                        (graph-trans graph)
;;                                                                        (z-cdr-ncode-proof exp)
;;                                                                        in-pf2)
;;                                            (ident-axiom-proof (z-opair (ncode rval1)
;;                                                                        (ncode rval2)))))))
;; (defun a-ev-list-part
;;       (exp va fa val rvar1 rvar2 trace)
;;       (forsome rvar1
;;                (forsome rvar2
;;                         (f-and (isin (z-list (list rvar1
;;                                                    (ncode 0)
;;                                                    (z-car (ncode exp))
;;                                                    (ncode va)
;;                                                    (ncode fa)))
;;                                      trace)
;;                                (f-and (isin (z-list (list rvar2
;;                                                           (ncode 1)
;;                                                           (z-cdr (ncode exp))
;;                                                           (ncode va)
;;                                                           (ncode fa)))
;;                                             trace)
;;                                       (f-equal val (z-opair rvar1 rvar2)))))))
;; (defthm a-ev-defn-list-ok-proof-proves

;;              (implies (and (subset (list (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (var-set (list rvar1 rvar2) 2)
;;                            (proves in-pf1
;;                                    (isin (z-list (list (ncode rval1)
;;                                                        (ncode 0)
;;                                                        (ncode (car exp))
;;                                                        (ncode va)
;;                                                        (ncode fa)))
;;                                          (graph-trans graph))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (proves in-pf2
;;                                    (isin (z-list (list (ncode rval2)
;;                                                        (ncode 1)
;;                                                        (ncode (cdr exp))
;;                                                        (ncode va)
;;                                                        (ncode fa)))
;;                                          (graph-trans graph))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl
;;                                   (a-ev-list-part exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (cons rval1 rval2))
;;                                                   rvar1
;;                                                   rvar2
;;                                                   (graph-trans graph))))
;;                       (proves (a-ev-defn-list-ok-proof exp
;;                                                        va
;;                                                        fa
;;                                                        rval1
;;                                                        rval2
;;                                                        rvar1
;;                                                        rvar2
;;                                                        graph
;;                                                        in-pf1
;;                                                        in-pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0823 a-ev-defn-list-ok-proof t)
;; ;; ev is defined below.  it takes a flg to control the recursion, an e-expression exp,
;; ;; an e-variable bindings list va, a e-function symbols definition list fa, and a stack
;; ;; bound n.  if the flg is 1, it is evaluating a list of e-expressions - if any of them
;; ;; evaluates to (btm), the whole list evaluates to (btm).  otherwise, it returns the
;; ;; list of values.  if the flg is not 1, then if exp is not a list, it must be an
;; ;; e-variable and ev returns (get exp va).  otherwise, (car exp) is an e-function
;; ;; symbol.  if the symbol is 0, then the e-expression is evaluated as a lisp
;; ;; if-expression.  if the symbol is 10, then the e-expression is evaluated as a
;; ;; lisp quote-expression.  if the symbol is between 1 and 9, then the appropriate
;; ;; lisp primitive is applied to the recursively evaluated arguments.  in the remaining
;; ;; case, the e-function symbol is a defined one, and the corresponding definition is
;; ;; evaluated with a new e-variable-bindings list consisting of the recursively evaluated
;; ;; arguments.  since there is no guarantee in the last case that the size of the
;; ;; definition is going to be smaller than the e-expression being evaluated, the counter
;; ;; n is decremented by one.  if either the counter is exhausted or one of the
;; ;; evaluated sub-expressions evaluates to (btm), then ev returns (btm).
;; (defun ev
;;       (flg exp va fa n)
;;       (if (equal flg 1)
;;           (if (consp exp)
;;               (if (or (btmp (ev 0 (car exp) va fa n))
;;                       (btmp (ev 1 (cdr exp) va fa n)))
;;                   (btm)
;;                   (cons (ev 0 (car exp) va fa n) (ev 1 (cdr exp) va fa n)))
;;               nil)
;;           (if (consp exp)
;;               (if (zerop (car exp))
;;                   (if (btmp (ev 0 (cadr exp) va fa n))
;;                       (btm)
;;                       (if (ncode-equal (ev 0 (cadr exp) va fa n) 0)
;;                           (ev 0 (cadddr exp) va fa n)
;;                           (ev 0 (caddr exp) va fa n)))
;;                   (if (equal (car exp) 10)
;;                       (cadr exp)
;;                       (if (btmp (ev 1 (cdr exp) va fa n))
;;                           (btm)
;;                           (if (subrp (car exp))
;;                               (apply-subr (car exp) (ev 1 (cdr exp) va fa n))
;;                               (if (zerop n)
;;                                   (btm)
;;                                   (ev 0
;;                                       (get (sub1-n (car exp) 11) fa)
;;                                       (ev 1 (cdr exp) va fa n)
;;                                       fa
;;                                       (sub1 n)))))))
;;               (get exp va)))
;;       ((lex2 (list n (acl2-count exp)))))
;; (defthm ev-if-reduc

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (zerop (car exp))
;;                            (not (btmp (ev flg exp va fa n))))
;;                       (equal (ev flg exp va fa n)
;;                              (if (ncode-equal (ev 0 (cadr exp) va fa n) 0)
;;                                  (ev 0 (cadddr exp) va fa n)
;;                                  (ev 0 (caddr exp) va fa n)))))
;; (defthm ev-subr-reduc

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (not (zerop (car exp)))
;;                            (not (equal (car exp) 10))
;;                            (subrp (car exp))
;;                            (not (btmp (ev flg exp va fa n))))
;;                       (equal (ev flg exp va fa n)
;;                              (apply-subr (car exp) (ev 1 (cdr exp) va fa n)))))
;; (defthm ev-fun-reduc

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (not (zerop (car exp)))
;;                            (not (equal (car exp) 10))
;;                            (not (subrp (car exp)))
;;                            (not (btmp (ev flg exp va fa n))))
;;                       (equal (ev flg exp va fa n)
;;                              (ev 0
;;                                  (get (sub1-n (car exp) 11) fa)
;;                                  (ev 1 (cdr exp) va fa n)
;;                                  fa
;;                                  (sub1 n)))))
;; (defthm ev-list-reduc

;;              (implies (and (equal flg 1)
;;                            (consp exp)
;;                            (not (btmp (ev flg exp va fa n))))
;;                       (equal (ev flg exp va fa n)
;;                              (cons (ev 0 (car exp) va fa n) (ev 1 (cdr exp) va fa n)))))
;; ;; the list of value/argument pairs generated in a computation of ev is constructed
;; ;; by ev-graph below.
;; (defun ev-graph
;;       (flg exp va fa n)
;;       (if (equal flg 1)
;;           (if (consp exp)
;;               (cons (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                     (g-append (ev-graph 0 (car exp) va fa n) (ev-graph 1 (cdr exp) va fa n)))
;;               (list (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))))
;;           (if (consp exp)
;;               (if (zerop (car exp))
;;                   (if (ncode-equal (ev 0 (cadr exp) va fa n) 0)
;;                       (cons (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                             (g-append (ev-graph 0 (cadr exp) va fa n)
;;                                     (ev-graph 0 (cadddr exp) va fa n)))
;;                       (cons (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                             (g-append (ev-graph 0 (cadr exp) va fa n)
;;                                     (ev-graph 0 (caddr exp) va fa n))))
;;                   (if (equal (car exp) 10)
;;                       (list (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa)))))
;;                       (if (subrp (car exp))
;;                           (cons (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                                 (ev-graph 1 (cdr exp) va fa n))
;;                           (if (zerop n)
;;                               (list (cons (ev flg exp va fa n)
;;                                           (cons flg (cons exp (cons va fa)))))
;;                               (cons (cons (ev flg exp va fa n)
;;                                           (cons flg (cons exp (cons va fa))))
;;                                     (g-append (ev-graph 0
;;                                                       (get (sub1-n (car exp) 11) fa)
;;                                                       (ev 1 (cdr exp) va fa n)
;;                                                       fa
;;                                                       (sub1 n))
;;                                             (ev-graph 1 (cdr exp) va fa n)))))))
;;               (list (cons (get exp va) (cons flg (cons exp (cons va fa)))))))
;;       ((lex2 (list n (acl2-count exp)))))
;; (defthm member-ev-graph1

;;              (member (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                      (ev-graph flg exp va fa n)))
;; (defthm subr-member-graph

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (not (zerop (car exp)))
;;                            (not (equal (car exp) 10))
;;                            (subrp (car exp))
;;                            (equal x
;;                                   (cons (ev 1 (cdr exp) va fa n)
;;                                         (cons 1 (cons (cdr exp) (cons va fa))))))
;;                       (member x (ev-graph flg exp va fa n))))
;; (defthm fun-ev-graph

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (not (zerop (car exp)))
;;                            (not (equal (car exp) 10))
;;                            (not (subrp (car exp)))
;;                            (not (btmp (ev flg exp va fa n))))
;;                       (equal (ev-graph flg exp va fa n)
;;                              (cons (cons (ev flg exp va fa n)
;;                                          (cons flg (cons exp (cons va fa))))
;;                                    (g-append (ev-graph 0
;;                                                      (get (sub1-n (car exp) 11) fa)
;;                                                      (ev 1 (cdr exp) va fa n)
;;                                                      fa
;;                                                      (sub1 n))
;;                                            (ev-graph 1 (cdr exp) va fa n))))))
;; (defthm member-fun-graph

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (not (zerop (car exp)))
;;                            (not (equal (car exp) 10))
;;                            (not (subrp (car exp)))
;;                            (equal x
;;                                   (cons (ev 1 (cdr exp) va fa n)
;;                                         (cons 1 (cons (cdr exp) (cons va fa)))))
;;                            (equal y
;;                                   (cons (ev 0
;;                                             (get (sub1-n (car exp) 11) fa)
;;                                             (ev 1 (cdr exp) va fa n)
;;                                             fa
;;                                             (sub1 n))
;;                                         (cons 0
;;                                               (cons (get (sub1-n (car exp) 11) fa)
;;                                                     (cons (ev 1 (cdr exp) va fa n) fa)))))
;;                            (not (btmp (ev flg exp va fa n))))
;;                       (and (member x (ev-graph flg exp va fa n))
;;                            (member y (ev-graph flg exp va fa n)))))
;; (defthm if-ev-graph1

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (zerop (car exp))
;;                            (ncode-equal (ev 0 (cadr exp) va fa n) 0))
;;                       (equal (ev-graph flg exp va fa n)
;;                              (cons (cons (ev flg exp va fa n)
;;                                          (cons flg (cons exp (cons va fa))))
;;                                    (g-append (ev-graph 0 (cadr exp) va fa n)
;;                                            (ev-graph 0 (cadddr exp) va fa n))))))
;; (defthm if-ev-graph2

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (zerop (car exp))
;;                            (not (ncode-equal (ev 0 (cadr exp) va fa n) 0)))
;;                       (equal (ev-graph flg exp va fa n)
;;                              (cons (cons (ev flg exp va fa n)
;;                                          (cons flg (cons exp (cons va fa))))
;;                                    (g-append (ev-graph 0 (cadr exp) va fa n)
;;                                            (ev-graph 0 (caddr exp) va fa n))))))
;; (defthm member-if-graph1

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (zerop (car exp))
;;                            (ncode-equal (ev 0 (cadr exp) va fa n) 0)
;;                            (equal x
;;                                   (cons (ev 0 (cadr exp) va fa n)
;;                                         (cons 0 (cons (cadr exp) (cons va fa)))))
;;                            (equal y
;;                                   (cons (ev 0 (cadddr exp) va fa n)
;;                                         (cons 0 (cons (cadddr exp) (cons va fa))))))
;;                       (and (member x (ev-graph flg exp va fa n))
;;                            (member y (ev-graph flg exp va fa n))))
;;              ((disable ncode-equal ev-graph) (use (member-ev-graph1 (flg 0) (exp (cadr exp)))
;;                                                   (member-ev-graph1 (flg 0) (exp (cadddr exp))))))
;; (defthm member-if-graph2

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (zerop (car exp))
;;                            (not (ncode-equal (ev 0 (cadr exp) va fa n) 0))
;;                            (equal x
;;                                   (cons (ev 0 (cadr exp) va fa n)
;;                                         (cons 0 (cons (cadr exp) (cons va fa)))))
;;                            (equal y
;;                                   (cons (ev 0 (caddr exp) va fa n)
;;                                         (cons 0 (cons (caddr exp) (cons va fa))))))
;;                       (and (member x (ev-graph flg exp va fa n))
;;                            (member y (ev-graph flg exp va fa n))))
;;              ((disable ncode-equal ev-graph) (use (member-ev-graph1 (flg 0) (exp (cadr exp)))
;;                                                   (member-ev-graph1 (flg 0) (exp (caddr exp))))))
;; (defthm member-list-graph

;;              (implies (and (consp exp)
;;                            (equal flg 1)
;;                            (equal x
;;                                   (cons (ev 0 (car exp) va fa n)
;;                                         (cons 0 (cons (car exp) (cons va fa)))))
;;                            (equal y
;;                                   (cons (ev 1 (cdr exp) va fa n)
;;                                         (cons 1 (cons (cdr exp) (cons va fa))))))
;;                       (and (member x (ev-graph flg exp va fa n))
;;                            (member y (ev-graph flg exp va fa n)))))
;; (toggle g0824 fun-ev-graph t)
;; (toggle g0844 if-ev-graph1 t)
;; (toggle g0848 if-ev-graph2 t)
;; (toggle g0849 proves-is-formula-again nil)
;; (toggle g0855 atom-ncode t)
;; ;; below is the z2 analogue of the definition of ev.
;; (defun z-ev-defn-part
;;       (flg exp va fa val trace)
;;       (z-if (f-equal (ncode flg) (ncode 1))
;;             (z-if (f-equal (z-consp (ncode exp)) (ncode 1))
;;                   (a-ev-list-part exp va fa val 11 12 trace)
;;                   (f-equal val (ncode nil)))
;;             (z-if (f-equal (z-consp (ncode exp)) (ncode 1))
;;                   (z-if (f-equal (z-zerop (z-car (ncode exp))) (ncode 1))
;;                         (a-ev-if-part (ncode exp) (ncode va) (ncode fa) val trace 11)
;;                         (z-if (f-equal (z-car (ncode exp)) (ncode 10))
;;                               (f-equal val (z-car-cdr (ncode exp) (list 1 2)))
;;                               (z-if (f-equal (z-subrp (z-car (ncode exp))) (ncode 1))
;;                                     (a-ev-subr-part exp va fa val 11 trace)
;;                                     (a-ev-fun-part exp va fa val trace))))
;;                   (a-get1 (ncode exp) (ncode va) val 11 13 14 16))))
;; (defn
;;  a-ev-defn-part-ok-pftree
;;  (flg exp va fa n)
;;  (list
;;   (list (equal flg 1) (ident-axiom-proof (ncode 1)) (ncode-nequal-proof flg 1))
;;   (list (list (consp exp)
;;               (z-consp-ncode-proof exp)
;;               (trans-not-equal-proof (ncode 1)
;;                                      (z-consp (ncode exp))
;;                                      (ncode 0)
;;                                      (ncode-nequal-proof 1 0)
;;                                      (z-consp-ncode-proof exp)))
;;         (a-ev-defn-list-ok-proof exp
;;                                  va
;;                                  fa
;;                                  (ev 0 (car exp) va fa n)
;;                                  (ev 1 (cdr exp) va fa n)
;;                                  11
;;                                  12
;;                                  (ev-graph flg exp va fa n)
;;                                  (in-graph-proof (cons (ev 0 (car exp) va fa n)
;;                                                        (cons 0 (cons (car exp) (cons va fa))))
;;                                                  (ev-graph flg exp va fa n))
;;                                  (in-graph-proof (cons (ev 1 (cdr exp) va fa n)
;;                                                        (cons 1 (cons (cdr exp) (cons va fa))))
;;                                                  (ev-graph flg exp va fa n)))
;;         (ident-axiom-proof (ncode nil)))
;;   (list
;;    (list (consp exp)
;;          (z-consp-ncode-proof exp)
;;          (trans-not-equal-proof (ncode 1)
;;                                 (z-consp (ncode exp))
;;                                 (ncode 0)
;;                                 (ncode-nequal-proof 1 0)
;;                                 (z-consp-ncode-proof exp)))
;;    (list
;;     (list (zerop (car exp))
;;           (compose-car-proof (fn 9 1) (ncode 1) exp (z-zerop-ncode-proof (car exp)))
;;           (trans-not-equal-proof (ncode 1)
;;                                  (z-zerop (z-car (ncode exp)))
;;                                  (ncode 0)
;;                                  (ncode-nequal-proof 1 0)
;;                                  (compose-car-proof (fn 9 1)
;;                                                     (ncode 0)
;;                                                     exp
;;                                                     (z-zerop-ncode-proof (car exp)))))
;;     (a-ev-defn-if-ok-proof exp
;;                            va
;;                            fa
;;                            (ev flg exp va fa n)
;;                            (ev 0 (cadr exp) va fa n)
;;                            11
;;                            (ev-graph flg exp va fa n)
;;                            (in-graph-proof (cons (ev 0 (cadr exp) va fa n)
;;                                                  (cons 0 (cons (cadr exp) (cons va fa))))
;;                                            (ev-graph flg exp va fa n))
;;                            (in-graph-proof (cons (ev 0 (cadddr exp) va fa n)
;;                                                  (cons 0 (cons (cadddr exp) (cons va fa))))
;;                                            (ev-graph flg exp va fa n))
;;                            (in-graph-proof (cons (ev 0 (caddr exp) va fa n)
;;                                                  (cons 0 (cons (caddr exp) (cons va fa))))
;;                                            (ev-graph flg exp va fa n)))
;;     (list
;;      (list (equal (car exp) 10)
;;            (z-car-ncode-proof exp)
;;            (trans-not-equal-proof (ncode 10)
;;                                   (z-car (ncode exp))
;;                                   (ncode (car exp))
;;                                   (ncode-nequal-proof 10 (car exp))
;;                                   (z-car-ncode-proof exp)))
;;      (flip-equals-proof (z-car-cdr (ncode exp) (list 1 2))
;;                         (ncode (cadr exp))
;;                         (z-car-cdr-proof exp (list 1 2)))
;;      (list (list (subrp (car exp))
;;                  (compose-car-proof (fn 16 1) (ncode 1) exp (z-subrp-ncode-proof (car exp)))
;;                  (trans-not-equal-proof (ncode 1)
;;                                         (z-subrp (z-car (ncode exp)))
;;                                         (ncode 0)
;;                                         (ncode-nequal-proof 1 0)
;;                                         (compose-car-proof (fn 16 1)
;;                                                            (ncode 0)
;;                                                            exp
;;                                                            (z-subrp-ncode-proof (car exp)))))
;;            (a-ev-defn-subr-ok-proof exp
;;                                     va
;;                                     fa
;;                                     (ncode (ev flg exp va fa n))
;;                                     (ev 1 (cdr exp) va fa n)
;;                                     11
;;                                     (ev-graph flg exp va fa n)
;;                                     (in-graph-proof (cons (ev 1 (cdr exp) va fa n)
;;                                                           (cons 1
;;                                                                 (cons (cdr exp)
;;                                                                       (cons va fa))))
;;                                                     (ev-graph flg exp va fa n)))
;;            (a-ev-defn-fun-ok-proof exp
;;                                    va
;;                                    fa
;;                                    (ncode (ev flg exp va fa n))
;;                                    (ev 1 (cdr exp) va fa n)
;;                                    (ev-graph flg exp va fa n)
;;                                    (in-graph-proof (cons (ev 1 (cdr exp) va fa n)
;;                                                          (cons 1
;;                                                                (cons (cdr exp) (cons va fa))))
;;                                                    (ev-graph flg exp va fa n))
;;                                    (in-graph-proof (cons (ev flg exp va fa n)
;;                                                          (cons 0
;;                                                                (cons (get (sub1-n (car exp)
;;                                                                                   11)
;;                                                                           fa)
;;                                                                      (cons (ev 1
;;                                                                                (cdr exp)
;;                                                                                va
;;                                                                                fa
;;                                                                                n)
;;                                                                            fa))))
;;                                                    (ev-graph flg exp va fa n))))))
;;    (a-get1-ok-proof exp va 11 13 14 16))))
;; (defun a-ev-defn-part-ok-proof
;;       (flg exp va fa n)
;;       (form-z-if-ok-proof (a-ev-defn-part-ok-pftree flg exp va fa n)
;;                           (z-ev-defn-part flg
;;                                           exp
;;                                           va
;;                                           fa
;;                                           (ncode (ev flg exp va fa n))
;;                                           (graph-trans (ev-graph flg exp va fa n)))))
;; (defthm form-z-if-z-ev-defn-part

;;              (implies (subset (list (fn 16 1)
;;                                     (fn 15 2)
;;                                     (fn 14 2)
;;                                     (fn 13 2)
;;                                     (fn 12 2)
;;                                     (fn 0 0)
;;                                     (fn 3 1)
;;                                     (fn 4 1)
;;                                     (fn 5 1)
;;                                     (fn 6 1)
;;                                     (fn 7 1)
;;                                     (fn 8 1)
;;                                     (fn 9 1)
;;                                     (fn 10 1)
;;                                     (fn 11 2)
;;                                     (fn 1 2)
;;                                     (fn 2 2)
;;                                     (p 2 1)
;;                                     (p 1 2))
;;                               symbols)
;;                       (form-z-if (z-ev-defn-part flg
;;                                                  exp
;;                                                  va
;;                                                  fa
;;                                                  (ncode (ev flg exp va fa n))
;;                                                  (graph-trans (ev-graph flg exp va fa n)))
;;                                  symbols)))
;; (defun a-ev-defn-part
;;       (flg exp va fa val trace)
;;       (f-if (f-equal (ncode flg) (ncode 1))
;;             (f-if (f-equal (z-consp (ncode exp)) (ncode 1))
;;                   (a-ev-list-part exp va fa val 11 12 trace)
;;                   (f-equal val (ncode nil)))
;;             (f-if (f-equal (z-consp (ncode exp)) (ncode 1))
;;                   (f-if (f-equal (z-zerop (z-car (ncode exp))) (ncode 1))
;;                         (a-ev-if-part (ncode exp) (ncode va) (ncode fa) val trace 11)
;;                         (f-if (f-equal (z-car (ncode exp)) (ncode 10))
;;                               (f-equal val (z-car-cdr (ncode exp) (list 1 2)))
;;                               (f-if (f-equal (z-subrp (z-car (ncode exp))) (ncode 1))
;;                                     (a-ev-subr-part exp va fa val 11 trace)
;;                                     (a-ev-fun-part exp va fa val trace))))
;;                   (a-get1 (ncode exp) (ncode va) val 11 13 14 16))))
;; (defun ev-hyps
;;       (given defns symbols)
;;       (and (subset (list (fn 16 1)
;;                          (fn 15 2)
;;                          (fn 14 2)
;;                          (fn 13 2)
;;                          (fn 12 2)
;;                          (fn 0 0)
;;                          (fn 3 1)
;;                          (fn 4 1)
;;                          (fn 5 1)
;;                          (fn 6 1)
;;                          (fn 7 1)
;;                          (fn 8 1)
;;                          (fn 9 1)
;;                          (fn 10 1)
;;                          (fn 11 2)
;;                          (fn 1 2)
;;                          (fn 2 2)
;;                          (p 2 1)
;;                          (p 1 2))
;;                    symbols)
;;            (z-apply-subr-all-hyps given defns symbols)
;;            (z-subrp-hyps defns symbols)))
;; (defthm a-ev-defn-part-ok-proof-proves-quote-case

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (equal (car exp) 10)
;;                            (ev-hyps given defns symbols)
;;                            (equal concl
;;                                   (a-ev-defn-part flg
;;                                                   exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (ev flg exp va fa n))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))))
;;                       (proves (a-ev-defn-part-ok-proof flg exp va fa n) concl given defns symbols))
;;              ((disable ev-graph
;;                        atom-ncode
;;                        form-z-if
;;                        a-ev-subr-part
;;                        a-get
;;                        a-get1
;;                        a-ev-list-part
;;                        a-ev-fun-part
;;                        a-ev-if-part)
;;               (use (form-z-if-z-ev-defn-part))))
;; (defthm form-z-if-z-ev-defn-part-again

;;              (implies (and (subset (list (fn 16 1)
;;                                          (fn 15 2)
;;                                          (fn 14 2)
;;                                          (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (p 2 1)
;;                                          (p 1 2))
;;                                    symbols)
;;                            (equal concl
;;                                   (z-ev-defn-part flg
;;                                                   exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (ev flg exp va fa n))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))))
;;                       (form-z-if concl symbols))
;;              ((disable z-ev-defn-part subset)))
;; (defthm a-ev-defn-part-ok-proof-proves-list-case

;;              (implies (and (equal flg 1)
;;                            (consp exp)
;;                            (ev-hyps given defns symbols)
;;                            (if (equal flg 1)
;;                                (not (btmp (ev 1 exp va fa n)))
;;                                (not (btmp (ev flg exp va fa n))))
;;                            (equal concl
;;                                   (a-ev-defn-part flg
;;                                                   exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (ev flg exp va fa n))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))))
;;                       (proves (a-ev-defn-part-ok-proof flg exp va fa n) concl given defns symbols))
;;              ((disable ev-graph
;;                        atom-ncode
;;                        nzerop-ncode-equal
;;                        form-z-if
;;                        a-ev-subr-part
;;                        a-get
;;                        a-get1
;;                        a-ev-fun-part
;;                        a-ev-if-part)
;;               (use (form-z-if-z-ev-defn-part))))
;; (defthm a-ev-defn-part-ok-proof-proves-nlist-case

;;              (implies (and (equal flg 1)
;;                            (atom exp)
;;                            (ev-hyps given defns symbols)
;;                            (if (equal flg 1)
;;                                (not (btmp (ev 1 exp va fa n)))
;;                                (not (btmp (ev flg exp va fa n))))
;;                            (equal concl
;;                                   (a-ev-defn-part flg
;;                                                   exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (ev flg exp va fa n))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))))
;;                       (proves (a-ev-defn-part-ok-proof flg exp va fa n) concl given defns symbols))
;;              ((disable ev-graph
;;                        atom-ncode
;;                        nzerop-ncode-equal
;;                        form-z-if
;;                        a-ev-subr-part
;;                        a-get
;;                        a-get1
;;                        a-ev-fun-part
;;                        a-ev-if-part
;;                        a-ev-list-part)
;;               (use (form-z-if-z-ev-defn-part))))
;; (defthm ncode-nequal-proof-proves-case

;;              (implies (and (< 0 y)
;;                            (not (equal x y))
;;                            (subset (list (fn 3 1) (p 2 1) (p 1 2) (fn 2 2) (fn 1 2) (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (equal x-bar (ncode x))
;;                            (equal y-bar (ncode y)))
;;                       (proves (ncode-nequal-proof x y)
;;                               (f-not (f-equal x-bar y-bar))
;;                               given
;;                               defns
;;                               symbols)))
;; (defthm a-ev-defn-part-ok-proof-proves-if-case1

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (zerop (car exp))
;;                            (ncode-equal (ev 0 (cadr exp) va fa n) 0)
;;                            (ev-hyps given defns symbols)
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (a-ev-defn-part flg
;;                                                   exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (ev flg exp va fa n))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))))
;;                       (proves (a-ev-defn-part-ok-proof flg exp va fa n) concl given defns symbols))
;;              ((disable ev-graph
;;                        ncode-equal
;;                        atom-ncode
;;                        nzerop-ncode-equal
;;                        form-z-if
;;                        a-ev-if-part
;;                        a-ev-subr-part
;;                        a-get
;;                        a-get1
;;                        a-ev-fun-part
;;                        a-ev-list-part)
;;               (use (form-z-if-z-ev-defn-part))))
;; (defthm a-ev-defn-part-ok-proof-proves-if-case2

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (zerop (car exp))
;;                            (not (ncode-equal (ev 0 (cadr exp) va fa n) 0))
;;                            (ev-hyps given defns symbols)
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (a-ev-defn-part flg
;;                                                   exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (ev flg exp va fa n))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))))
;;                       (proves (a-ev-defn-part-ok-proof flg exp va fa n) concl given defns symbols))
;;              ((disable ev-graph
;;                        ncode-equal
;;                        atom-ncode
;;                        nzerop-ncode-equal
;;                        form-z-if
;;                        a-ev-if-part
;;                        a-ev-subr-part
;;                        a-get
;;                        a-get1
;;                        a-ev-fun-part
;;                        a-ev-list-part)
;;               (use (form-z-if-z-ev-defn-part))))
;; (defthm a-ev-defn-part-ok-proof-proves-subr-case

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (not (zerop (car exp)))
;;                            (not (equal (car exp) 10))
;;                            (subrp (car exp))
;;                            (ev-hyps given defns symbols)
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (a-ev-defn-part flg
;;                                                   exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (ev flg exp va fa n))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))))
;;                       (proves (a-ev-defn-part-ok-proof flg exp va fa n) concl given defns symbols))
;;              ((disable ev-graph
;;                        atom-ncode
;;                        nzerop-ncode-equal
;;                        form-z-if
;;                        a-ev-subr-part
;;                        a-get
;;                        a-get1
;;                        a-ev-fun-part
;;                        a-ev-if-part
;;                        a-ev-list-part)
;;               (use (form-z-if-z-ev-defn-part))))
;; (defthm a-ev-defn-part-ok-proof-proves-fun-case

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (not (zerop (car exp)))
;;                            (not (equal (car exp) 10))
;;                            (not (subrp (car exp)))
;;                            (ev-hyps given defns symbols)
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (a-ev-defn-part flg
;;                                                   exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (ev flg exp va fa n))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))))
;;                       (proves (a-ev-defn-part-ok-proof flg exp va fa n) concl given defns symbols))
;;              ((disable ev-graph
;;                        atom-ncode
;;                        nzerop-ncode-equal
;;                        form-z-if
;;                        a-ev-subr-part
;;                        a-get
;;                        a-get1
;;                        a-ev-fun-part
;;                        a-ev-if-part
;;                        a-ev-list-part)
;;               (use (form-z-if-z-ev-defn-part))))
;; (defthm a-ev-defn-part-ok-proof-proves-var-case

;;              (implies (and (not (equal flg 1))
;;                            (atom exp)
;;                            (ev-hyps given defns symbols)
;;                            (if (equal flg 1)
;;                                (not (btmp (ev 1 exp va fa n)))
;;                                (not (btmp (ev flg exp va fa n))))
;;                            (equal concl
;;                                   (a-ev-defn-part flg
;;                                                   exp
;;                                                   va
;;                                                   fa
;;                                                   (ncode (ev flg exp va fa n))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))))
;;                       (proves (a-ev-defn-part-ok-proof flg exp va fa n) concl given defns symbols))
;;              ((disable ev-graph
;;                        atom-ncode
;;                        form-z-if
;;                        a-ev-subr-part
;;                        a-get
;;                        a-get1
;;                        a-ev-fun-part
;;                        a-ev-if-part
;;                        a-ev-list-part)
;;               (use (form-z-if-z-ev-defn-part))))
;; (defthm collect-free-var-list

;;              (implies (var-list vlist (length vlist))
;;                       (equal (collect-free vlist 1) (g-append vlist nil))))
;; (defn
;;  graph-trans-append-proof
;;  (x y z exp pf1 pf2)
;;  (if
;;   (consp y)
;;   (graph-trans-merge-proof
;;    (car y)
;;    (g-append (cdr y) z)
;;    x
;;    exp
;;    (chain-proof
;;     (f-equal x (ncode (car y)))
;;     exp
;;     (list (isin x (graph-trans y)))
;;     (list (tautconseq-proof (list (f-implies (f-equal x (ncode (car y)))
;;                                              (f-equal (ncode (car y)) x))
;;                                   (f-equal (graph-trans y) (graph-trans y))
;;                                   (isin (ncode (car y)) (graph-trans y))
;;                                   (f-implies (f-equal (ncode (car y)) x)
;;                                              (f-implies (f-equal (graph-trans y)
;;                                                                  (graph-trans y))
;;                                                         (f-implies (isin (ncode (car y))
;;                                                                          (graph-trans y))
;;                                                                    (isin x (graph-trans y))))))
;;                             (f-implies (f-equal x (ncode (car y))) (isin x (graph-trans y)))
;;                             (list (symmetry-proof1 x (ncode (car y)))
;;                                   (ident-axiom-proof (graph-trans y))
;;                                   (in-graph-proof (car y) y)
;;                                   (equal-axiom2-proof (p 1 2)
;;                                                       (list (ncode (car y)) (graph-trans y))
;;                                                       (list x (graph-trans y)))))
;;           pf1))
;;    (graph-trans-append-proof
;;     x
;;     (cdr y)
;;     z
;;     exp
;;     (chain-proof
;;      (isin x (graph-trans (cdr y)))
;;      exp
;;      (list (isin x (graph-trans y)))
;;      (list (tautconseq-proof (list (f-implies (f-or (f-equal x (ncode (car y)))
;;                                                     (isin x (graph-trans (cdr y))))
;;                                               (isin x (graph-trans y))))
;;                              (f-implies (isin x (graph-trans (cdr y))) (isin x (graph-trans y)))
;;                              (list (iff-split-proof2 (isin x (graph-trans y))
;;                                                      (f-or (f-equal x (ncode (car y)))
;;                                                            (isin x (graph-trans (cdr y))))
;;                                                      (in-graph-trans-proof x (car y) (cdr y)))))
;;            pf1))
;;     pf2))
;;   pf2))
;; (defthm graph-trans-append-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (g-termp x 0 symbols)
;;                            (g-formula exp symbols)
;;                            (proves pf1
;;                                    (f-implies (isin x (graph-trans y)) exp)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (proves pf2
;;                                    (f-implies (isin x (graph-trans z)) exp)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal trace (graph-trans (g-append y z))))
;;                       (proves (graph-trans-append-proof x y z exp pf1 pf2)
;;                               (f-implies (isin x trace) exp)
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0888 graph-trans-append-proof t)
;; ;; since we will be manipulating large if-trees with expressions containing
;; ;;  "in", "forall", "^", "->", and so on, so we introduce symbols (shells) for them.
;; (add-shell s-isin nil s-isinp ((s-elem (none-of) zero) (s-set (none-of) zero)))
;; (add-shell s-and nil s-andp ((s-conj1 (none-of) zero) (s-conj2 (none-of) zero)))
;; (add-shell s-implies nil s-impliesp ((s-prem (none-of) zero) (s-conc (none-of) zero)))
;; (add-shell s-forall nil s-forallp ((s-bind (one-of acl2-numberp) zero) (s-body (none-of) zero)))
;; (defun weaken-isin
;;       (form1 form2 gr1 gr2)
;;       (if (and (z-ifp form1)
;;                (z-ifp form2))
;;           (and (equal (z-test form1) (z-test form2))
;;                (weaken-isin (z-left form1) (z-left form2) gr1 gr2)
;;                (weaken-isin (z-right form1) (z-right form2) gr1 gr2))
;;           (if (and (forsomep form1)
;;                    (forsomep form2))
;;               (and (equal (bind form1) (bind form2))
;;                    (weaken-isin (g-body form1) (g-body form2) gr1 gr2))
;;               (if (and (s-forallp form1)
;;                        (s-forallp form2))
;;                   (and (equal (s-bind form1) (s-bind form2))
;;                        (weaken-isin (s-body form1) (s-body form2) gr1 gr2))
;;                   (if (and (s-andp form1)
;;                            (s-andp form2))
;;                       (and (weaken-isin (s-conj1 form1) (s-conj1 form2) gr1 gr2)
;;                            (weaken-isin (s-conj2 form1) (s-conj2 form2) gr1 gr2))
;;                       (if (and (s-impliesp form1)
;;                                (s-impliesp form2))
;;                           (and (equal (s-prem form1) (s-prem form2))
;;                                (weaken-isin (s-conc form1) (s-conc form2) gr1 gr2))
;;                           (if (and (s-isinp form1)
;;                                    (s-isinp form2))
;;                               (and (equal (s-elem form1) (s-elem form2))
;;                                    (equal (s-set form1) (graph-trans gr2))
;;                                    (equal (s-set form2) (graph-trans (cons gr1 gr2))))
;;                               (equal form1 form2))))))))
;; (defun make-form-symb
;;       (exp)
;;       (if (z-ifp exp)
;;           (f-if (z-test exp) (make-form-symb (z-left exp)) (make-form-symb (z-right exp)))
;;           (if (forsomep exp)
;;               (forsome (bind exp) (make-form-symb (g-body exp)))
;;               (if (s-forallp exp)
;;                   (forall (s-bind exp) (make-form-symb (s-body exp)))
;;                   (if (s-andp exp)
;;                       (f-and (make-form-symb (s-conj1 exp)) (make-form-symb (s-conj2 exp)))
;;                       (if (s-impliesp exp)
;;                           (f-implies (s-prem exp) (make-form-symb (s-conc exp)))
;;                           (if (s-isinp exp) (isin (s-elem exp) (s-set exp)) exp)))))))
;; (defun weaken-isin-proof
;;       (form1 form2 gr1 gr2)
;;       (if (and (z-ifp form1)
;;                (z-ifp form2))
;;           (tautconseq-proof (list (f-implies (make-form-symb (z-left form1))
;;                                              (make-form-symb (z-left form2)))
;;                                   (f-implies (make-form-symb (z-right form1))
;;                                              (make-form-symb (z-right form2))))
;;                             (f-implies (make-form-symb form1) (make-form-symb form2))
;;                             (list (weaken-isin-proof (z-left form1) (z-left form2) gr1 gr2)
;;                                   (weaken-isin-proof (z-right form1) (z-right form2) gr1 gr2)))
;;           (if (and (forsomep form1)
;;                    (forsomep form2))
;;               (distrib-rule-proof-a (bind form2)
;;                                     (make-form-symb (g-body form1))
;;                                     (make-form-symb (g-body form2))
;;                                     (weaken-isin-proof (g-body form1) (g-body form2) gr1 gr2))
;;               (if (and (s-forallp form1)
;;                        (s-forallp form2))
;;                   (distrib-rule-proof-b (s-bind form2)
;;                                         (make-form-symb (s-body form1))
;;                                         (make-form-symb (s-body form2))
;;                                         (weaken-isin-proof (s-body form1)
;;                                                            (s-body form2)
;;                                                            gr1
;;                                                            gr2))
;;                   (if (and (s-andp form1)
;;                            (s-andp form2))
;;                       (tautconseq-proof (list (f-implies (make-form-symb (s-conj1 form1))
;;                                                          (make-form-symb (s-conj1 form2)))
;;                                               (f-implies (make-form-symb (s-conj2 form1))
;;                                                          (make-form-symb (s-conj2 form2))))
;;                                         (f-implies (make-form-symb form1)
;;                                                    (make-form-symb form2))
;;                                         (list (weaken-isin-proof (s-conj1 form1)
;;                                                                  (s-conj1 form2)
;;                                                                  gr1
;;                                                                  gr2)
;;                                               (weaken-isin-proof (s-conj2 form1)
;;                                                                  (s-conj2 form2)
;;                                                                  gr1
;;                                                                  gr2)))
;;                       (if (and (s-impliesp form1)
;;                                (s-impliesp form2))
;;                           (tautconseq-proof (list (f-implies (make-form-symb (s-conc form1))
;;                                                              (make-form-symb (s-conc form2))))
;;                                             (f-implies (make-form-symb form1)
;;                                                        (make-form-symb form2))
;;                                             (list (weaken-isin-proof (s-conc form1)
;;                                                                      (s-conc form2)
;;                                                                      gr1
;;                                                                      gr2)))
;;                           (if (and (s-isinp form1)
;;                                    (s-isinp form2))
;;                               (in-graph-cdr-proof (s-elem form2) gr1 gr2)
;;                               (tautconseq-proof nil (f-implies form1 form2) nil))))))))
;; (defun form-symb1
;;       (exp symbols)
;;       (if (z-ifp exp)
;;           (and (g-formula (z-test exp) symbols)
;;                (form-symb1 (z-left exp) symbols)
;;                (form-symb1 (z-right exp) symbols))
;;           (if (forsomep exp)
;;               (form-symb1 (g-body exp) symbols)
;;               (if (s-forallp exp)
;;                   (form-symb1 (s-body exp) symbols)
;;                   (if (s-andp exp)
;;                       (and (form-symb1 (s-conj1 exp) symbols)
;;                            (form-symb1 (s-conj2 exp) symbols))
;;                       (if (s-impliesp exp)
;;                           (and (g-formula (s-prem exp) symbols)
;;                                (form-symb1 (s-conc exp) symbols))
;;                           (if (s-isinp exp)
;;                               (and (member (p 1 2) symbols)
;;                                    (g-termp (s-elem exp) 0 symbols)
;;                                    (g-termp (s-set exp) 0 symbols))
;;                               (g-formula exp symbols))))))))
;; (defthm formula-make-form-symb

;;              (implies (form-symb1 exp symbols) (g-formula (make-form-symb exp) symbols)))
;; (defthm weaken-isin-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (form-symb1 form1 symbols)
;;                            (form-symb1 form2 symbols)
;;                            (weaken-isin form1 form2 gr1 gr2)
;;                            (equal concl
;;                                   (f-implies (make-form-symb form1) (make-form-symb form2))))
;;                       (proves (weaken-isin-proof form1 form2 gr1 gr2) concl given defns symbols)))
;; (toggle g0859 weaken-isin-proof t)
;; (defn
;;  in-append-graph-proof1
;;  (x gr1 gr2)
;;  (if
;;   (consp gr1)
;;   (tautconseq-proof
;;    (list (f-implies (isin x (graph-trans gr1))
;;                     (f-or (f-equal x (ncode (car gr1))) (isin x (graph-trans (cdr gr1)))))
;;          (f-implies (f-equal x (ncode (car gr1))) (isin x (graph-trans (g-append gr1 gr2))))
;;          (f-implies (isin x (graph-trans (cdr gr1)))
;;                     (isin x (graph-trans (g-append (cdr gr1) gr2))))
;;          (f-implies (isin x (graph-trans (g-append (cdr gr1) gr2)))
;;                     (isin x (graph-trans (g-append gr1 gr2)))))
;;    (f-implies (isin x (graph-trans gr1)) (isin x (graph-trans (g-append gr1 gr2))))
;;    (list
;;     (iff-split-proof1 (isin x (graph-trans gr1))
;;                       (f-or (f-equal x (ncode (car gr1))) (isin x (graph-trans (cdr gr1))))
;;                       (in-graph-trans-proof x (car gr1) (cdr gr1)))
;;     (tautconseq-proof (list (f-implies (f-or (f-equal x (ncode (car gr1)))
;;                                              (isin x (graph-trans (g-append (cdr gr1) gr2))))
;;                                        (isin x
;;                                              (graph-trans (cons (car gr1)
;;                                                                 (g-append (cdr gr1) gr2))))))
;;                       (f-implies (f-equal x (ncode (car gr1)))
;;                                  (isin x (graph-trans (cons (car gr1) (g-append (cdr gr1) gr2)))))
;;                       (list (iff-split-proof2 (isin x
;;                                                     (graph-trans (cons (car gr1)
;;                                                                        (g-append (cdr gr1)
;;                                                                                gr2))))
;;                                               (f-or (f-equal x (ncode (car gr1)))
;;                                                     (isin x
;;                                                           (graph-trans (g-append (cdr gr1)
;;                                                                                gr2))))
;;                                               (in-graph-trans-proof x
;;                                                                     (car gr1)
;;                                                                     (g-append (cdr gr1) gr2)))))
;;     (in-append-graph-proof1 x (cdr gr1) gr2)
;;     (in-graph-cdr-proof x (car gr1) (g-append (cdr gr1) gr2))))
;;   (tautconseq-proof (list (f-not (isin x (graph-trans gr1))))
;;                     (f-implies (isin x (graph-trans gr1))
;;                                (isin x (graph-trans (g-append gr1 gr2))))
;;                     (list (null-axiom-proof x)))))
;; ;; let "(x|y)" denote (g-append x y).  then |- "((x in y) -> (x in (y|z)))".
;; (defthm in-append-graph-proof1-proves

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (g-termp x 0 symbols))
;;                       (proves (in-append-graph-proof1 x gr1 gr2)
;;                               (f-implies (isin x (graph-trans gr1))
;;                                          (isin x (graph-trans (g-append gr1 gr2))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0860 in-append-graph-proof1 t)
;; (defun in-append-graph-proof2
;;       (x gr1 gr2)
;;       (if (consp gr1)
;;           (tautconseq-proof (list (f-implies (isin x (graph-trans gr2))
;;                                              (isin x (graph-trans (g-append (cdr gr1) gr2))))
;;                                   (f-implies (isin x (graph-trans (g-append (cdr gr1) gr2)))
;;                                              (isin x (graph-trans (g-append gr1 gr2)))))
;;                             (f-implies (isin x (graph-trans gr2))
;;                                        (isin x (graph-trans (g-append gr1 gr2))))
;;                             (list (in-append-graph-proof2 x (cdr gr1) gr2)
;;                                   (in-graph-cdr-proof x (car gr1) (g-append (cdr gr1) gr2))))
;;           (tautconseq-proof nil
;;                             (f-implies (isin x (graph-trans gr2))
;;                                        (isin x (graph-trans (g-append gr1 gr2))))
;;                             nil)))
;; ;;  |- "((x in z) -> (x in (y|z)))".
;; (defthm in-append-graph-proof2-proves

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (g-termp x 0 symbols))
;;                       (proves (in-append-graph-proof2 x gr1 gr2)
;;                               (f-implies (isin x (graph-trans gr2))
;;                                          (isin x (graph-trans (g-append gr1 gr2))))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0861 in-append-graph-proof2 t)
;; (defun weaken-append1
;;       (form1 form2 y gr1 gr2)
;;       (if (and (z-ifp form1)
;;                (z-ifp form2))
;;           (and (equal (z-test form1) (z-test form2))
;;                (equal (z-test form2) (z-test form2))
;;                (weaken-append1 (z-left form1) (z-left form2) y gr1 gr2)
;;                (weaken-append1 (z-right form1) (z-right form2) y gr1 gr2))
;;           (if (and (forsomep form1)
;;                    (forsomep form2))
;;               (and (equal (bind form1) (bind form2))
;;                    (weaken-append1 (g-body form1) (g-body form2) y gr1 gr2))
;;               (if (and (s-forallp form1)
;;                        (s-forallp form2))
;;                   (and (equal (s-bind form1) (s-bind form2))
;;                        (weaken-append1 (s-body form1) (s-body form2) y gr1 gr2))
;;                   (if (and (s-andp form1)
;;                            (s-andp form2))
;;                       (and (weaken-append1 (s-conj1 form1) (s-conj1 form2) y gr1 gr2)
;;                            (weaken-append1 (s-conj2 form1) (s-conj2 form2) y gr1 gr2))
;;                       (if (and (s-impliesp form1)
;;                                (s-impliesp form2))
;;                           (and (equal (s-prem form1) (s-prem form2))
;;                                (weaken-append1 (s-conc form1) (s-conc form2) y gr1 gr2))
;;                           (if (and (s-isinp form1)
;;                                    (s-isinp form2))
;;                               (and (equal (s-elem form1) (s-elem form2))
;;                                    (equal (s-set form1) (graph-trans gr1))
;;                                    (equal (s-set form2)
;;                                           (graph-trans (cons y (g-append gr1 gr2)))))
;;                               (equal form1 form2))))))))
;; (defun weaken-append2
;;       (form1 form2 y gr1 gr2)
;;       (if (and (z-ifp form1)
;;                (z-ifp form2))
;;           (and (equal (z-test form1) (z-test form2))
;;                (equal (z-test form2) (z-test form2))
;;                (weaken-append2 (z-left form1) (z-left form2) y gr1 gr2)
;;                (weaken-append2 (z-right form1) (z-right form2) y gr1 gr2))
;;           (if (and (forsomep form1)
;;                    (forsomep form2))
;;               (and (equal (bind form1) (bind form2))
;;                    (weaken-append2 (g-body form1) (g-body form2) y gr1 gr2))
;;               (if (and (s-forallp form1)
;;                        (s-forallp form2))
;;                   (and (equal (s-bind form1) (s-bind form2))
;;                        (weaken-append2 (s-body form1) (s-body form2) y gr1 gr2))
;;                   (if (and (s-andp form1)
;;                            (s-andp form2))
;;                       (and (weaken-append2 (s-conj1 form1) (s-conj1 form2) y gr1 gr2)
;;                            (weaken-append2 (s-conj2 form1) (s-conj2 form2) y gr1 gr2))
;;                       (if (and (s-impliesp form1)
;;                                (s-impliesp form2))
;;                           (and (equal (s-prem form1) (s-prem form2))
;;                                (weaken-append2 (s-conc form1) (s-conc form2) y gr1 gr2))
;;                           (if (and (s-isinp form1)
;;                                    (s-isinp form2))
;;                               (and (equal (s-elem form1) (s-elem form2))
;;                                    (equal (s-set form1) (graph-trans gr2))
;;                                    (equal (s-set form2)
;;                                           (graph-trans (cons y (g-append gr1 gr2)))))
;;                               (equal form1 form2))))))))
;; (defun weaken-append1-proof
;;       (form1 form2 y gr1 gr2)
;;       (if (and (z-ifp form1)
;;                (z-ifp form2))
;;           (tautconseq-proof (list (f-implies (make-form-symb (z-left form1))
;;                                              (make-form-symb (z-left form2)))
;;                                   (f-implies (make-form-symb (z-right form1))
;;                                              (make-form-symb (z-right form2))))
;;                             (f-implies (make-form-symb form1) (make-form-symb form2))
;;                             (list (weaken-append1-proof (z-left form1) (z-left form2) y gr1 gr2)
;;                                   (weaken-append1-proof (z-right form1)
;;                                                         (z-right form2)
;;                                                         y
;;                                                         gr1
;;                                                         gr2)))
;;           (if (and (forsomep form1)
;;                    (forsomep form2))
;;               (distrib-rule-proof-a (bind form2)
;;                                     (make-form-symb (g-body form1))
;;                                     (make-form-symb (g-body form2))
;;                                     (weaken-append1-proof (g-body form1) (g-body form2) y gr1 gr2))
;;               (if (and (s-forallp form1)
;;                        (s-forallp form2))
;;                   (distrib-rule-proof-b (s-bind form2)
;;                                         (make-form-symb (s-body form1))
;;                                         (make-form-symb (s-body form2))
;;                                         (weaken-append1-proof (s-body form1)
;;                                                               (s-body form2)
;;                                                               y
;;                                                               gr1
;;                                                               gr2))
;;                   (if (and (s-andp form1)
;;                            (s-andp form2))
;;                       (tautconseq-proof (list (f-implies (make-form-symb (s-conj1 form1))
;;                                                          (make-form-symb (s-conj1 form2)))
;;                                               (f-implies (make-form-symb (s-conj2 form1))
;;                                                          (make-form-symb (s-conj2 form2))))
;;                                         (f-implies (make-form-symb form1)
;;                                                    (make-form-symb form2))
;;                                         (list (weaken-append1-proof (s-conj1 form1)
;;                                                                     (s-conj1 form2)
;;                                                                     y
;;                                                                     gr1
;;                                                                     gr2)
;;                                               (weaken-append1-proof (s-conj2 form1)
;;                                                                     (s-conj2 form2)
;;                                                                     y
;;                                                                     gr1
;;                                                                     gr2)))
;;                       (if (and (s-impliesp form1)
;;                                (s-impliesp form2))
;;                           (tautconseq-proof (list (f-implies (make-form-symb (s-conc form1))
;;                                                              (make-form-symb (s-conc form2))))
;;                                             (f-implies (make-form-symb form1)
;;                                                        (make-form-symb form2))
;;                                             (list (weaken-append1-proof (s-conc form1)
;;                                                                         (s-conc form2)
;;                                                                         y
;;                                                                         gr1
;;                                                                         gr2)))
;;                           (if (and (s-isinp form1)
;;                                    (s-isinp form2))
;;                               (chain-proof (isin (s-elem form2) (graph-trans gr1))
;;                                            (isin (s-elem form2)
;;                                                  (graph-trans (cons y (g-append gr1 gr2))))
;;                                            (list (isin (s-elem form2)
;;                                                        (graph-trans (g-append gr1 gr2))))
;;                                            (list (in-append-graph-proof1 (s-elem form2)
;;                                                                          gr1
;;                                                                          gr2)
;;                                                  (in-graph-cdr-proof (s-elem form2)
;;                                                                      y
;;                                                                      (g-append gr1 gr2))))
;;                               (tautconseq-proof nil (f-implies form1 form2) nil))))))))
;; (defun weaken-append2-proof
;;       (form1 form2 y gr1 gr2)
;;       (if (and (z-ifp form1)
;;                (z-ifp form2))
;;           (tautconseq-proof (list (f-implies (make-form-symb (z-left form1))
;;                                              (make-form-symb (z-left form2)))
;;                                   (f-implies (make-form-symb (z-right form1))
;;                                              (make-form-symb (z-right form2))))
;;                             (f-implies (make-form-symb form1) (make-form-symb form2))
;;                             (list (weaken-append2-proof (z-left form1) (z-left form2) y gr1 gr2)
;;                                   (weaken-append2-proof (z-right form1)
;;                                                         (z-right form2)
;;                                                         y
;;                                                         gr1
;;                                                         gr2)))
;;           (if (and (forsomep form1)
;;                    (forsomep form2))
;;               (distrib-rule-proof-a (bind form2)
;;                                     (make-form-symb (g-body form1))
;;                                     (make-form-symb (g-body form2))
;;                                     (weaken-append2-proof (g-body form1) (g-body form2) y gr1 gr2))
;;               (if (and (s-forallp form1)
;;                        (s-forallp form2))
;;                   (distrib-rule-proof-b (s-bind form2)
;;                                         (make-form-symb (s-body form1))
;;                                         (make-form-symb (s-body form2))
;;                                         (weaken-append2-proof (s-body form1)
;;                                                               (s-body form2)
;;                                                               y
;;                                                               gr1
;;                                                               gr2))
;;                   (if (and (s-andp form1)
;;                            (s-andp form2))
;;                       (tautconseq-proof (list (f-implies (make-form-symb (s-conj1 form1))
;;                                                          (make-form-symb (s-conj1 form2)))
;;                                               (f-implies (make-form-symb (s-conj2 form1))
;;                                                          (make-form-symb (s-conj2 form2))))
;;                                         (f-implies (make-form-symb form1)
;;                                                    (make-form-symb form2))
;;                                         (list (weaken-append2-proof (s-conj1 form1)
;;                                                                     (s-conj1 form2)
;;                                                                     y
;;                                                                     gr1
;;                                                                     gr2)
;;                                               (weaken-append2-proof (s-conj2 form1)
;;                                                                     (s-conj2 form2)
;;                                                                     y
;;                                                                     gr1
;;                                                                     gr2)))
;;                       (if (and (s-impliesp form1)
;;                                (s-impliesp form2))
;;                           (tautconseq-proof (list (f-implies (make-form-symb (s-conc form1))
;;                                                              (make-form-symb (s-conc form2))))
;;                                             (f-implies (make-form-symb form1)
;;                                                        (make-form-symb form2))
;;                                             (list (weaken-append2-proof (s-conc form1)
;;                                                                         (s-conc form2)
;;                                                                         y
;;                                                                         gr1
;;                                                                         gr2)))
;;                           (if (and (s-isinp form1)
;;                                    (s-isinp form2))
;;                               (chain-proof (isin (s-elem form2) (graph-trans gr2))
;;                                            (isin (s-elem form2)
;;                                                  (graph-trans (cons y (g-append gr1 gr2))))
;;                                            (list (isin (s-elem form2)
;;                                                        (graph-trans (g-append gr1 gr2))))
;;                                            (list (in-append-graph-proof2 (s-elem form2)
;;                                                                          gr1
;;                                                                          gr2)
;;                                                  (in-graph-cdr-proof (s-elem form2)
;;                                                                      y
;;                                                                      (g-append gr1 gr2))))
;;                               (tautconseq-proof nil (f-implies form1 form2) nil))))))))
;; (defthm weaken-append1-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (form-symb1 form1 symbols)
;;                            (form-symb1 form2 symbols)
;;                            (weaken-append1 form1 form2 y gr1 gr2)
;;                            (equal concl
;;                                   (f-implies (make-form-symb form1) (make-form-symb form2))))
;;                       (proves (weaken-append1-proof form1 form2 y gr1 gr2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0862 weaken-append1-proof t)
;; (defthm weaken-append2-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (form-symb1 form1 symbols)
;;                            (form-symb1 form2 symbols)
;;                            (weaken-append2 form1 form2 y gr1 gr2)
;;                            (equal concl
;;                                   (f-implies (make-form-symb form1) (make-form-symb form2))))
;;                       (proves (weaken-append2-proof form1 form2 y gr1 gr2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0863 weaken-append2-proof t)
;; (defn
;;  a-ev-defn-ok-frame-proof2
;;  (formals y
;;           gr1
;;           gr2
;;           defn-part
;;           defn-part-form
;;           rec1-defn-part
;;           rec1-form
;;           rec2-defn-part
;;           rec2-form
;;           defn-pf
;;           recpf1
;;           recpf2)
;;  (graph-trans-merge-proof
;;   y
;;   (g-append gr1 gr2)
;;   formals
;;   defn-part
;;   defn-pf
;;   (graph-trans-append-proof formals
;;                             gr1
;;                             gr2
;;                             defn-part
;;                             (chain-proof (isin formals (graph-trans gr1))
;;                                          defn-part
;;                                          (list rec1-defn-part)
;;                                          (list recpf1
;;                                                (weaken-append1-proof rec1-form
;;                                                                      defn-part-form
;;                                                                      y
;;                                                                      gr1
;;                                                                      gr2)))
;;                             (chain-proof (isin formals (graph-trans gr2))
;;                                          defn-part
;;                                          (list rec2-defn-part)
;;                                          (list recpf2
;;                                                (weaken-append2-proof rec2-form
;;                                                                      defn-part-form
;;                                                                      y
;;                                                                      gr1
;;                                                                      gr2))))))
;; (prove-lemma
;;  a-ev-defn-ok-frame-proof2-proves

;;  (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                (equal graph (cons y (g-append gr1 gr2)))
;;                (form-symb1 defn-part-form symbols)
;;                (form-symb1 rec1-form symbols)
;;                (form-symb1 rec2-form symbols)
;;                (equal defn-part (make-form-symb defn-part-form))
;;                (equal rec1-defn-part (make-form-symb rec1-form))
;;                (equal rec2-defn-part (make-form-symb rec2-form))
;;                (weaken-append1 rec1-form defn-part-form y gr1 gr2)
;;                (weaken-append2 rec2-form defn-part-form y gr1 gr2)
;;                (proves defn-pf
;;                        (f-implies (f-equal formals (ncode y)) defn-part)
;;                        given
;;                        defns
;;                        symbols)
;;                (proves recpf1
;;                        (f-implies (isin formals (graph-trans gr1)) rec1-defn-part)
;;                        given
;;                        defns
;;                        symbols)
;;                (proves recpf2
;;                        (f-implies (isin formals (graph-trans gr2)) rec2-defn-part)
;;                        given
;;                        defns
;;                        symbols))
;;           (proves (a-ev-defn-ok-frame-proof2 formals
;;                                              y
;;                                              gr1
;;                                              gr2
;;                                              defn-part
;;                                              defn-part-form
;;                                              rec1-defn-part
;;                                              rec1-form
;;                                              rec2-defn-part
;;                                              rec2-form
;;                                              defn-pf
;;                                              recpf1
;;                                              recpf2)
;;                   (f-implies (isin formals (graph-trans graph)) defn-part)
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable atom-ncode) (use (proves-is-formula (pf defn-pf)
;;                                                  (exp (f-implies (f-equal formals (ncode y))
;;                                                                  defn-part)))
;;                               (proves-is-formula (pf recpf1)
;;                                                  (exp (f-implies (isin formals
;;                                                                        (graph-trans gr1))
;;                                                                  rec1-defn-part)))
;;                               (proves-is-formula (pf recpf2)
;;                                                  (exp (f-implies (isin formals
;;                                                                        (graph-trans gr2))
;;                                                                  rec2-defn-part))))))
;; (toggle g0864 a-ev-defn-ok-frame-proof2 t)
;; (defn
;;  a-ev-symb-form
;;  (flg exp va fa val trace)
;;  (z-if
;;   (f-equal flg (ncode 1))
;;   (z-if (f-equal (z-consp exp) (ncode 1))
;;         (forsome 11
;;                  (forsome 12
;;                           (s-and (s-isin (z-list (list 11 (ncode 0) (z-car exp) va fa)) trace)
;;                                  (s-and (s-isin (z-list (list 12 (ncode 1) (z-cdr exp) va fa))
;;                                                 trace)
;;                                         (f-equal val (z-opair 11 12))))))
;;         (f-equal val (ncode nil)))
;;   (z-if
;;    (f-equal (z-consp exp) (ncode 1))
;;    (z-if
;;     (f-equal (z-zerop (z-car exp)) (ncode 1))
;;     (forsome 11
;;              (s-and (s-isin (z-list (list 11 (ncode 0) (z-car (z-cdr exp)) va fa)) trace)
;;                     (z-if (f-equal 11 (ncode 0))
;;                           (s-isin (z-list (list val
;;                                                 (ncode 0)
;;                                                 (z-car-cdr exp (list 1 2 2 2))
;;                                                 va
;;                                                 fa))
;;                                   trace)
;;                           (s-isin (z-list (list val
;;                                                 (ncode 0)
;;                                                 (z-car-cdr exp (list 1 2 2))
;;                                                 va
;;                                                 fa))
;;                                   trace))))
;;     (z-if
;;      (f-equal (z-car exp) (ncode 10))
;;      (f-equal val (z-car-cdr exp (list 1 2)))
;;      (z-if
;;       (f-equal (z-subrp (z-car exp)) (ncode 1))
;;       (forsome 11
;;                (s-and (s-isin (z-list (list 11 (ncode 1) (z-cdr exp) va fa)) trace)
;;                       (f-equal val (z-apply-subr (z-car exp) 11))))
;;       (forsome 11
;;                (s-forall 15
;;                          (s-forall 16
;;                                    (s-and (s-isin (z-list (list 11
;;                                                                 (ncode 1)
;;                                                                 (z-cdr exp)
;;                                                                 va
;;                                                                 fa))
;;                                                   trace)
;;                                           (s-implies (a-get (z-sub1-n (z-car exp) 11)
;;                                                             fa
;;                                                             15
;;                                                             11
;;                                                             13
;;                                                             14
;;                                                             16)
;;                                                      (s-isin (z-list (list val
;;                                                                            (ncode 0)
;;                                                                            15
;;                                                                            11
;;                                                                            fa))
;;                                                              trace)))))))))
;;    (a-get1 exp va val 11 13 14 16))))
;; (defn
;;  a-ev-defn-part1
;;  (flg exp va fa val trace)
;;  (f-if
;;   (f-equal flg (ncode 1))
;;   (f-if (f-equal (z-consp exp) (ncode 1))
;;         (forsome 11
;;                  (forsome 12
;;                           (f-and (isin (z-list (list 11 (ncode 0) (z-car exp) va fa)) trace)
;;                                  (f-and (isin (z-list (list 12 (ncode 1) (z-cdr exp) va fa))
;;                                               trace)
;;                                         (f-equal val (z-opair 11 12))))))
;;         (f-equal val (ncode nil)))
;;   (f-if
;;    (f-equal (z-consp exp) (ncode 1))
;;    (f-if
;;     (f-equal (z-zerop (z-car exp)) (ncode 1))
;;     (forsome 11
;;              (f-and (isin (z-list (list 11 (ncode 0) (z-car (z-cdr exp)) va fa)) trace)
;;                     (f-if (f-equal 11 (ncode 0))
;;                           (isin (z-list (list val
;;                                               (ncode 0)
;;                                               (z-car-cdr exp (list 1 2 2 2))
;;                                               va
;;                                               fa))
;;                                 trace)
;;                           (isin (z-list (list val
;;                                               (ncode 0)
;;                                               (z-car-cdr exp (list 1 2 2))
;;                                               va
;;                                               fa))
;;                                 trace))))
;;     (f-if (f-equal (z-car exp) (ncode 10))
;;           (f-equal val (z-car-cdr exp (list 1 2)))
;;           (f-if (f-equal (z-subrp (z-car exp)) (ncode 1))
;;                 (forsome 11
;;                          (f-and (isin (z-list (list 11 (ncode 1) (z-cdr exp) va fa)) trace)
;;                                 (f-equal val (z-apply-subr (z-car exp) 11))))
;;                 (forsome 11
;;                          (forall 15
;;                                  (forall 16
;;                                          (f-and (isin (z-list (list 11
;;                                                                     (ncode 1)
;;                                                                     (z-cdr exp)
;;                                                                     va
;;                                                                     fa))
;;                                                       trace)
;;                                                 (f-implies (a-get (z-sub1-n (z-car exp)
;;                                                                             11)
;;                                                                   fa
;;                                                                   15
;;                                                                   11
;;                                                                   13
;;                                                                   14
;;                                                                   16)
;;                                                            (isin (z-list (list val
;;                                                                                (ncode 0)
;;                                                                                15
;;                                                                                11
;;                                                                                fa))
;;                                                                  trace)))))))))
;;    (a-get1 exp va val 11 13 14 16))))
;; (defthm a-ev-symb-form-a-ev-defn-part

;;              (equal (make-form-symb (a-ev-symb-form (ncode flg)
;;                                                     (ncode exp)
;;                                                     (ncode va)
;;                                                     (ncode fa)
;;                                                     val
;;                                                     trace))
;;                     (a-ev-defn-part flg exp va fa val trace)))
;; (defthm weaken-append2-a-ev-defn-part

;;              (weaken-append2 (a-ev-symb-form flg exp va fa val (graph-trans gr2))
;;                              (a-ev-symb-form flg
;;                                              exp
;;                                              va
;;                                              fa
;;                                              val
;;                                              (graph-trans (cons y (g-append gr1 gr2))))
;;                              y
;;                              gr1
;;                              gr2))
;; (defthm weaken-append1-a-ev-defn-part

;;              (weaken-append1 (a-ev-symb-form flg exp va fa val (graph-trans gr1))
;;                              (a-ev-symb-form flg
;;                                              exp
;;                                              va
;;                                              fa
;;                                              val
;;                                              (graph-trans (cons y (g-append gr1 gr2))))
;;                              y
;;                              gr1
;;                              gr2))
;; (defun a-ev-inst-formals-proof
;;       (flg exp va fa n)
;;       (inst-formals-proof (list 10 6 7 8 9)
;;                           (list (ncode (ev flg exp va fa n))
;;                                 (ncode flg)
;;                                 (ncode exp)
;;                                 (ncode va)
;;                                 (ncode fa))
;;                           (a-ev-defn-part1 6 7 8 9 10 (graph-trans (ev-graph flg exp va fa n)))
;;                           (a-ev-defn-part-ok-proof flg exp va fa n)))
;; (defthm form-symb1-a-ev-symb-form

;;              (implies (and (g-termp (list flg exp va fa val trace) 1 symbols)
;;                            (subset (list (p 1 2)
;;                                          (fn 0 0)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (fn 3 1)
;;                                          (fn 6 1)
;;                                          (fn 10 1)
;;                                          (fn 16 1)
;;                                          (fn 15 2)
;;                                          (fn 9 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1))
;;                                    symbols))
;;                       (form-symb1 (a-ev-symb-form flg exp va fa val trace) symbols)))
;; (defthm formula-a-ev-defn-part1

;;              (implies (and (subset (list (p 1 2)
;;                                          (fn 0 0)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (fn 3 1)
;;                                          (fn 6 1)
;;                                          (fn 10 1)
;;                                          (fn 16 1)
;;                                          (fn 15 2)
;;                                          (fn 9 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1))
;;                                    symbols)
;;                            (g-termp (list flg exp va fa val trace) 1 symbols))
;;                       (g-formula (a-ev-defn-part1 flg exp va fa val trace) symbols)))
;; (defthm formula-a-ev-defn-part

;;              (implies (and (subset (list (p 1 2)
;;                                          (fn 0 0)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (fn 3 1)
;;                                          (fn 6 1)
;;                                          (fn 10 1)
;;                                          (fn 16 1)
;;                                          (fn 15 2)
;;                                          (fn 9 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1))
;;                                    symbols)
;;                            (g-termp (list val trace) 1 symbols))
;;                       (g-formula (a-ev-defn-part flg exp va fa val trace) symbols)))
;; (defthm parallel-subst-a-ev-defn-part1

;;              (equal (parallel-subst (a-ev-defn-part1 6 7 8 9 10 (graph-trans graph))
;;                                     (list 10 6 7 8 9)
;;                                     (list val (ncode flg) (ncode exp) (ncode va) (ncode fa))
;;                                     0)
;;                     (a-ev-defn-part flg exp va fa val (graph-trans graph))))
;; (toggle g0865 a-ev-defn-part1 t)
;; (toggle g0866 a-ev-defn-part t)
;; (defthm termp-z-opair-case

;;              (implies (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                       (equal (g-termp (z-opair x y) 0 symbols)
;;                              (and (g-termp x 0 symbols)
;;                                   (g-termp y 0 symbols)))))
;; (defthm graph-trans-merge-again

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (proves pf1
;;                                    (f-implies (f-equal exp1 (ncode x)) exp2)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (proves pf2
;;                                    (f-implies (isin exp1 (graph-trans y)) exp2)
;;                                    given
;;                                    defns
;;                                    symbols))
;;                       (proves (graph-trans-merge-proof x y exp1 exp2 pf1 pf2)
;;                               (f-implies (isin exp1 (graph-trans (cons x y))) exp2)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies (f-equal exp1 (ncode x)) exp2)))
;;                    (graph-trans-merge))
;;               ))
;; (toggle g0867 graph-trans-merge t)
;; (defun a-ev-defn-ok-frame-proof3
;;       (formals y gr defn-part defn-part-form rec-defn-part rec-form defn-pf recpf)
;;       (graph-trans-merge-proof y
;;                                gr
;;                                formals
;;                                defn-part
;;                                defn-pf
;;                                (chain-proof (isin formals (graph-trans gr))
;;                                             defn-part
;;                                             (list rec-defn-part)
;;                                             (list recpf
;;                                                   (weaken-isin-proof rec-form
;;                                                                      defn-part-form
;;                                                                      y
;;                                                                      gr)))))
;; (prove-lemma
;;  a-ev-defn-ok-frame-proof3-proves

;;  (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                (equal graph (cons y gr))
;;                (form-symb1 defn-part-form symbols)
;;                (form-symb1 rec-form symbols)
;;                (equal defn-part (make-form-symb defn-part-form))
;;                (equal rec-defn-part (make-form-symb rec-form))
;;                (weaken-isin rec-form defn-part-form y gr)
;;                (proves defn-pf
;;                        (f-implies (f-equal formals (ncode y)) defn-part)
;;                        given
;;                        defns
;;                        symbols)
;;                (proves recpf
;;                        (f-implies (isin formals (graph-trans gr)) rec-defn-part)
;;                        given
;;                        defns
;;                        symbols))
;;           (proves (a-ev-defn-ok-frame-proof3 formals
;;                                              y
;;                                              gr
;;                                              defn-part
;;                                              defn-part-form
;;                                              rec-defn-part
;;                                              rec-form
;;                                              defn-pf
;;                                              recpf)
;;                   (f-implies (isin formals (graph-trans graph)) defn-part)
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable atom-ncode) (use (proves-is-formula (pf defn-pf)
;;                                                  (exp (f-implies (f-equal formals (ncode y))
;;                                                                  defn-part)))
;;                               (proves-is-formula (pf recpf)
;;                                                  (exp (f-implies (isin formals
;;                                                                        (graph-trans gr))
;;                                                                  rec-defn-part))))))
;; (toggle g0869 a-ev-defn-ok-frame-proof3 t)
;; (defthm weaken-isin-a-ev-defn-part

;;              (weaken-isin (a-ev-symb-form flg exp va fa val (graph-trans gr))
;;                           (a-ev-symb-form flg exp va fa val (graph-trans (cons y gr)))
;;                           y
;;                           gr))
;; (defthm term-ncode-case

;;              (implies (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                       (g-termp (ncode x) 0 symbols)))
;; (defthm term-graph-trans-case

;;              (implies (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                       (g-termp (graph-trans x) 0 symbols)))
;; (defthm a-ev-symb-form-a-ev-defn-part1

;;              (equal (make-form-symb (a-ev-symb-form flg exp va fa val trace))
;;                     (a-ev-defn-part1 flg exp va fa val trace))
;;              ((enable a-ev-defn-part1)))
;; (toggle g0890 a-ev-symb-form t)
;; (toggle g0891 a-ev-defn-part-ok-proof t)
;; (defn
;;  a-ev-defn-ok-proof
;;  (flg exp va fa n flg1 exp1 va1 fa1 val1)
;;  (if
;;   (equal flg 1)
;;   (if
;;    (consp exp)
;;    (a-ev-defn-ok-frame-proof2 (z-list (list val1 flg1 exp1 va1 fa1))
;;                               (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                               (ev-graph 0 (car exp) va fa n)
;;                               (ev-graph 1 (cdr exp) va fa n)
;;                               (a-ev-defn-part1 flg1
;;                                                exp1
;;                                                va1
;;                                                fa1
;;                                                val1
;;                                                (graph-trans (ev-graph flg exp va fa n)))
;;                               (a-ev-symb-form flg1
;;                                               exp1
;;                                               va1
;;                                               fa1
;;                                               val1
;;                                               (graph-trans (ev-graph flg exp va fa n)))
;;                               (a-ev-defn-part1 flg1
;;                                                exp1
;;                                                va1
;;                                                fa1
;;                                                val1
;;                                                (graph-trans (ev-graph 0 (car exp) va fa n)))
;;                               (a-ev-symb-form flg1
;;                                               exp1
;;                                               va1
;;                                               fa1
;;                                               val1
;;                                               (graph-trans (ev-graph 0 (car exp) va fa n)))
;;                               (a-ev-defn-part1 flg1
;;                                                exp1
;;                                                va1
;;                                                fa1
;;                                                val1
;;                                                (graph-trans (ev-graph 1 (cdr exp) va fa n)))
;;                               (a-ev-symb-form flg1
;;                                               exp1
;;                                               va1
;;                                               fa1
;;                                               val1
;;                                               (graph-trans (ev-graph 1 (cdr exp) va fa n)))
;;                               (a-ev-inst-formals-proof flg exp va fa n)
;;                               (a-ev-defn-ok-proof 0 (car exp) va fa n flg1 exp1 va1 fa1 val1)
;;                               (a-ev-defn-ok-proof 1 (cdr exp) va fa n flg1 exp1 va1 fa1 val1))
;;    (graph-trans-merge-proof
;;     (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;     nil
;;     (z-list (list val1 flg1 exp1 va1 fa1))
;;     (a-ev-defn-part1 flg1 exp1 va1 fa1 val1 (graph-trans (ev-graph flg exp va fa n)))
;;     (a-ev-inst-formals-proof flg exp va fa n)
;;     (tautconseq-proof (list (f-not (isin (z-list (list val1 flg1 exp1 va1 fa1))
;;                                          (graph-trans nil))))
;;                       (f-implies (isin (z-list (list val1 flg1 exp1 va1 fa1)) (graph-trans nil))
;;                                  (a-ev-defn-part1 flg1
;;                                                   exp1
;;                                                   va1
;;                                                   fa1
;;                                                   val1
;;                                                   (graph-trans (ev-graph flg exp va fa n))))
;;                       (list (null-axiom-proof (z-list (list val1 flg1 exp1 va1 fa1)))))))
;;   (if
;;    (consp exp)
;;    (if
;;     (zerop (car exp))
;;     (if (ncode-equal (ev 0 (cadr exp) va fa n) 0)
;;         (a-ev-defn-ok-frame-proof2 (z-list (list val1 flg1 exp1 va1 fa1))
;;                                    (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                                    (ev-graph 0 (cadr exp) va fa n)
;;                                    (ev-graph 0 (cadddr exp) va fa n)
;;                                    (a-ev-defn-part1 flg1
;;                                                     exp1
;;                                                     va1
;;                                                     fa1
;;                                                     val1
;;                                                     (graph-trans (ev-graph flg exp va fa n)))
;;                                    (a-ev-symb-form flg1
;;                                                    exp1
;;                                                    va1
;;                                                    fa1
;;                                                    val1
;;                                                    (graph-trans (ev-graph flg exp va fa n)))
;;                                    (a-ev-defn-part1 flg1
;;                                                     exp1
;;                                                     va1
;;                                                     fa1
;;                                                     val1
;;                                                     (graph-trans (ev-graph 0 (cadr exp) va fa n)))
;;                                    (a-ev-symb-form flg1
;;                                                    exp1
;;                                                    va1
;;                                                    fa1
;;                                                    val1
;;                                                    (graph-trans (ev-graph 0 (cadr exp) va fa n)))
;;                                    (a-ev-defn-part1 flg1
;;                                                     exp1
;;                                                     va1
;;                                                     fa1
;;                                                     val1
;;                                                     (graph-trans (ev-graph 0
;;                                                                            (cadddr exp)
;;                                                                            va
;;                                                                            fa
;;                                                                            n)))
;;                                    (a-ev-symb-form flg1
;;                                                    exp1
;;                                                    va1
;;                                                    fa1
;;                                                    val1
;;                                                    (graph-trans (ev-graph 0
;;                                                                           (cadddr exp)
;;                                                                           va
;;                                                                           fa
;;                                                                           n)))
;;                                    (a-ev-inst-formals-proof flg exp va fa n)
;;                                    (a-ev-defn-ok-proof 0
;;                                                        (cadr exp)
;;                                                        va
;;                                                        fa
;;                                                        n
;;                                                        flg1
;;                                                        exp1
;;                                                        va1
;;                                                        fa1
;;                                                        val1)
;;                                    (a-ev-defn-ok-proof 0
;;                                                        (cadddr exp)
;;                                                        va
;;                                                        fa
;;                                                        n
;;                                                        flg1
;;                                                        exp1
;;                                                        va1
;;                                                        fa1
;;                                                        val1))
;;         (a-ev-defn-ok-frame-proof2 (z-list (list val1 flg1 exp1 va1 fa1))
;;                                    (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                                    (ev-graph 0 (cadr exp) va fa n)
;;                                    (ev-graph 0 (caddr exp) va fa n)
;;                                    (a-ev-defn-part1 flg1
;;                                                     exp1
;;                                                     va1
;;                                                     fa1
;;                                                     val1
;;                                                     (graph-trans (ev-graph flg exp va fa n)))
;;                                    (a-ev-symb-form flg1
;;                                                    exp1
;;                                                    va1
;;                                                    fa1
;;                                                    val1
;;                                                    (graph-trans (ev-graph flg exp va fa n)))
;;                                    (a-ev-defn-part1 flg1
;;                                                     exp1
;;                                                     va1
;;                                                     fa1
;;                                                     val1
;;                                                     (graph-trans (ev-graph 0
;;                                                                            (cadr exp)
;;                                                                            va
;;                                                                            fa
;;                                                                            n)))
;;                                    (a-ev-symb-form flg1
;;                                                    exp1
;;                                                    va1
;;                                                    fa1
;;                                                    val1
;;                                                    (graph-trans (ev-graph 0 (cadr exp) va fa n)))
;;                                    (a-ev-defn-part1 flg1
;;                                                     exp1
;;                                                     va1
;;                                                     fa1
;;                                                     val1
;;                                                     (graph-trans (ev-graph 0
;;                                                                            (caddr exp)
;;                                                                            va
;;                                                                            fa
;;                                                                            n)))
;;                                    (a-ev-symb-form flg1
;;                                                    exp1
;;                                                    va1
;;                                                    fa1
;;                                                    val1
;;                                                    (graph-trans (ev-graph 0
;;                                                                           (caddr exp)
;;                                                                           va
;;                                                                           fa
;;                                                                           n)))
;;                                    (a-ev-inst-formals-proof flg exp va fa n)
;;                                    (a-ev-defn-ok-proof 0
;;                                                        (cadr exp)
;;                                                        va
;;                                                        fa
;;                                                        n
;;                                                        flg1
;;                                                        exp1
;;                                                        va1
;;                                                        fa1
;;                                                        val1)
;;                                    (a-ev-defn-ok-proof 0
;;                                                        (caddr exp)
;;                                                        va
;;                                                        fa
;;                                                        n
;;                                                        flg1
;;                                                        exp1
;;                                                        va1
;;                                                        fa1
;;                                                        val1)))
;;     (if
;;      (equal (car exp) 10)
;;      (graph-trans-merge-proof
;;       (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;       nil
;;       (z-list (list val1 flg1 exp1 va1 fa1))
;;       (a-ev-defn-part1 flg1 exp1 va1 fa1 val1 (graph-trans (ev-graph flg exp va fa n)))
;;       (a-ev-inst-formals-proof flg exp va fa n)
;;       (tautconseq-proof (list (f-not (isin (z-list (list val1 flg1 exp1 va1 fa1))
;;                                            (graph-trans nil))))
;;                         (f-implies (isin (z-list (list val1 flg1 exp1 va1 fa1))
;;                                          (graph-trans nil))
;;                                    (a-ev-defn-part1 flg1
;;                                                     exp1
;;                                                     va1
;;                                                     fa1
;;                                                     val1
;;                                                     (graph-trans (ev-graph flg exp va fa n))))
;;                         (list (null-axiom-proof (z-list (list val1 flg1 exp1 va1 fa1))))))
;;      (if
;;       (subrp (car exp))
;;       (a-ev-defn-ok-frame-proof3 (z-list (list val1 flg1 exp1 va1 fa1))
;;                                  (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                                  (ev-graph 1 (cdr exp) va fa n)
;;                                  (a-ev-defn-part1 flg1
;;                                                   exp1
;;                                                   va1
;;                                                   fa1
;;                                                   val1
;;                                                   (graph-trans (ev-graph flg exp va fa n)))
;;                                  (a-ev-symb-form flg1
;;                                                  exp1
;;                                                  va1
;;                                                  fa1
;;                                                  val1
;;                                                  (graph-trans (ev-graph flg exp va fa n)))
;;                                  (a-ev-defn-part1 flg1
;;                                                   exp1
;;                                                   va1
;;                                                   fa1
;;                                                   val1
;;                                                   (graph-trans (ev-graph 1 (cdr exp) va fa n)))
;;                                  (a-ev-symb-form flg1
;;                                                  exp1
;;                                                  va1
;;                                                  fa1
;;                                                  val1
;;                                                  (graph-trans (ev-graph 1 (cdr exp) va fa n)))
;;                                  (a-ev-inst-formals-proof flg exp va fa n)
;;                                  (a-ev-defn-ok-proof 1
;;                                                      (cdr exp)
;;                                                      va
;;                                                      fa
;;                                                      n
;;                                                      flg1
;;                                                      exp1
;;                                                      va1
;;                                                      fa1
;;                                                      val1))
;;       (if
;;        (zerop n)
;;        nil
;;        (a-ev-defn-ok-frame-proof2
;;         (z-list (list val1 flg1 exp1 va1 fa1))
;;         (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;         (ev-graph 0 (get (sub1-n (car exp) 11) fa) (ev 1 (cdr exp) va fa n) fa (sub1 n))
;;         (ev-graph 1 (cdr exp) va fa n)
;;         (a-ev-defn-part1 flg1 exp1 va1 fa1 val1 (graph-trans (ev-graph flg exp va fa n)))
;;         (a-ev-symb-form flg1 exp1 va1 fa1 val1 (graph-trans (ev-graph flg exp va fa n)))
;;         (a-ev-defn-part1 flg1
;;                          exp1
;;                          va1
;;                          fa1
;;                          val1
;;                          (graph-trans (ev-graph 0
;;                                                 (get (sub1-n (car exp) 11) fa)
;;                                                 (ev 1 (cdr exp) va fa n)
;;                                                 fa
;;                                                 (sub1 n))))
;;         (a-ev-symb-form flg1
;;                         exp1
;;                         va1
;;                         fa1
;;                         val1
;;                         (graph-trans (ev-graph 0
;;                                                (get (sub1-n (car exp) 11) fa)
;;                                                (ev 1 (cdr exp) va fa n)
;;                                                fa
;;                                                (sub1 n))))
;;         (a-ev-defn-part1 flg1 exp1 va1 fa1 val1 (graph-trans (ev-graph 1 (cdr exp) va fa n)))
;;         (a-ev-symb-form flg1 exp1 va1 fa1 val1 (graph-trans (ev-graph 1 (cdr exp) va fa n)))
;;         (a-ev-inst-formals-proof flg exp va fa n)
;;         (a-ev-defn-ok-proof 0
;;                             (get (sub1-n (car exp) 11) fa)
;;                             (ev 1 (cdr exp) va fa n)
;;                             fa
;;                             (sub1 n)
;;                             flg1
;;                             exp1
;;                             va1
;;                             fa1
;;                             val1)
;;         (a-ev-defn-ok-proof 1 (cdr exp) va fa n flg1 exp1 va1 fa1 val1))))))
;;    (graph-trans-merge-proof
;;     (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;     nil
;;     (z-list (list val1 flg1 exp1 va1 fa1))
;;     (a-ev-defn-part1 flg1 exp1 va1 fa1 val1 (graph-trans (ev-graph flg exp va fa n)))
;;     (a-ev-inst-formals-proof flg exp va fa n)
;;     (tautconseq-proof (list (f-not (isin (z-list (list val1 flg1 exp1 va1 fa1))
;;                                          (graph-trans nil))))
;;                       (f-implies (isin (z-list (list val1 flg1 exp1 va1 fa1)) (graph-trans nil))
;;                                  (a-ev-defn-part1 flg1
;;                                                   exp1
;;                                                   va1
;;                                                   fa1
;;                                                   val1
;;                                                   (graph-trans (ev-graph flg exp va fa n))))
;;                       (list (null-axiom-proof (z-list (list val1 flg1 exp1 va1 fa1))))))))
;;  ((lex2 (list n (acl2-count exp)))))
;; ;; the definition part of "a-ev" is `ok'.
;; (defthm a-ev-defn-ok-proof-proves

;;              (implies (and (subset (list (fn 16 1)
;;                                          (fn 15 2)
;;                                          (fn 14 2)
;;                                          (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (p 2 1)
;;                                          (p 1 2))
;;                                    symbols)
;;                            (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (subset (list (p 1 2)
;;                                          (fn 0 0)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (fn 3 1)
;;                                          (fn 6 1)
;;                                          (fn 10 1)
;;                                          (fn 16 1)
;;                                          (fn 15 2)
;;                                          (fn 9 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1))
;;                                    symbols)
;;                            (subset (list (p 1 2) (fn 1 2)) symbols)
;;                            (member (fn 0 0) symbols)
;;                            (member (fn 1 2) symbols)
;;                            (member (p 1 2) symbols)
;;                            (subset (list (fn 0 0) (p 1 2)) symbols)
;;                            (z-apply-subr-all-hyps given defns symbols)
;;                            (z-subrp-hyps defns symbols)
;;                            (not (btmp (ev flg exp va fa n))))
;;                       (proves (a-ev-defn-ok-proof flg exp va fa n 6 7 8 9 10)
;;                               (f-implies (isin (z-list (list 10 6 7 8 9))
;;                                                (graph-trans (ev-graph flg exp va fa n)))
;;                                          (a-ev-defn-part1 6
;;                                                           7
;;                                                           8
;;                                                           9
;;                                                           10
;;                                                           (graph-trans (ev-graph flg
;;                                                                                  exp
;;                                                                                  va
;;                                                                                  fa
;;                                                                                  n))))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable atom-ncode
;;                        z-apply-subr-all-hyps
;;                        z-subrp-hyps
;;                        nzerop-ncode-equal
;;                        ev-if-reduc
;;                        subset)
;;               ))
;; (toggle g0896 a-ev-defn-ok-proof t)
;; (toggle g0897 ev-graph t)
;; (defun a-ev
;;       (flg exp va fa val trace)
;;       (f-and (isin (z-list (list val flg exp va fa)) trace)
;;              (list-all-quantify (list 6 7 8 9 10)
;;                                 (f-implies (isin (z-list (list 10 6 7 8 9)) trace)
;;                                            (a-ev-defn-part1 6 7 8 9 10 trace)))))
;; (defn
;;  a-ev-ok-proof
;;  (flg exp va fa n)
;;  (and-join-proof (isin (z-list (list (ncode (ev flg exp va fa n))
;;                                      (ncode flg)
;;                                      (ncode exp)
;;                                      (ncode va)
;;                                      (ncode fa)))
;;                        (graph-trans (ev-graph flg exp va fa n)))
;;                  (list-all-quantify (list 6 7 8 9 10)
;;                                     (f-implies (isin (z-list (list 10 6 7 8 9))
;;                                                      (graph-trans (ev-graph flg exp va fa n)))
;;                                                (a-ev-defn-part1 6
;;                                                                 7
;;                                                                 8
;;                                                                 9
;;                                                                 10
;;                                                                 (graph-trans (ev-graph flg
;;                                                                                        exp
;;                                                                                        va
;;                                                                                        fa
;;                                                                                        n)))))
;;                  (in-graph-proof (cons (ev flg exp va fa n) (cons flg (cons exp (cons va fa))))
;;                                  (ev-graph flg exp va fa n))
;;                  (list-gen-proof (list 6 7 8 9 10)
;;                                  (f-implies (isin (z-list (list 10 6 7 8 9))
;;                                                   (graph-trans (ev-graph flg exp va fa n)))
;;                                             (a-ev-defn-part1 6
;;                                                              7
;;                                                              8
;;                                                              9
;;                                                              10
;;                                                              (graph-trans (ev-graph flg
;;                                                                                     exp
;;                                                                                     va
;;                                                                                     fa
;;                                                                                     n))))
;;                                  (a-ev-defn-ok-proof flg exp va fa n 6 7 8 9 10))))
;; (defthm a-ev-defn-ok-proof-proves-again

;;              (implies (and (ev-hyps given defns symbols)
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (f-implies (isin (z-list (list 10 6 7 8 9))
;;                                                    (graph-trans (ev-graph flg exp va fa n)))
;;                                              (a-ev-defn-part1 6
;;                                                               7
;;                                                               8
;;                                                               9
;;                                                               10
;;                                                               (graph-trans (ev-graph flg
;;                                                                                      exp
;;                                                                                      va
;;                                                                                      fa
;;                                                                                      n))))))
;;                       (proves (a-ev-defn-ok-proof flg exp va fa n 6 7 8 9 10)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable atom-ncode z-apply-subr-all-hyps z-list)))
;; (toggle g0898 a-ev-defn-ok-proof-proves t)
;; ;; "a-ev" is `ok', i.e.,
;; ;; |- "a-ev(<flg>, <exp>, <va>, <fa>, <(ev flg exp va fa n)>,
;; ;;          [(ev-graph flg exp va fa n)])"
;; (defthm a-ev-ok-proof-proves

;;              (implies (and (ev-hyps given defns symbols)
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (a-ev (ncode flg)
;;                                         (ncode exp)
;;                                         (ncode va)
;;                                         (ncode fa)
;;                                         (ncode (ev flg exp va fa n))
;;                                         (graph-trans (ev-graph flg exp va fa n)))))
;;                       (proves (a-ev-ok-proof flg exp va fa n) concl given defns symbols))
;;              ((disable z-apply-subr-all-hyps ev list-all-quantify)))
;; (toggle g0899 a-ev-ok-proof t)
;; (defthm forsome-intro-proves-again

;;              (implies (and (g-variable var)
;;                            (not (member var (collect-free b 0)))
;;                            (proves pf (f-implies a b) given defns symbols))
;;                       (proves (forsome-intro-proof var a b pf)
;;                               (f-implies (forsome var a) b)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (exp (f-implies a b))))))
;; (defn
;;  a-ev-good-reduc-proof
;;  (flg exp expr va fa val1 trace conc pfexpr pf)
;;  (chain-proof (isin (z-list (list val1 (ncode flg) expr (ncode va) (ncode fa))) trace)
;;               conc
;;               (list (isin (z-list (list val1 (ncode flg) (ncode exp) (ncode va) (ncode fa)))
;;                           trace))
;;               (list (equal-isin-imp-proof (z-list (list val1
;;                                                         (ncode flg)
;;                                                         expr
;;                                                         (ncode va)
;;                                                         (ncode fa)))
;;                                           (z-list (list val1
;;                                                         (ncode flg)
;;                                                         (ncode exp)
;;                                                         (ncode va)
;;                                                         (ncode fa)))
;;                                           trace
;;                                           (flip-equals-proof (z-list (list val1
;;                                                                            (ncode flg)
;;                                                                            (ncode exp)
;;                                                                            (ncode va)
;;                                                                            (ncode fa)))
;;                                                              (z-list (list val1
;;                                                                            (ncode flg)
;;                                                                            expr
;;                                                                            (ncode va)
;;                                                                            (ncode fa)))
;;                                                              (ev-equal-z-list-proof val1
;;                                                                                     flg
;;                                                                                     exp
;;                                                                                     expr
;;                                                                                     va
;;                                                                                     fa
;;                                                                                     pfexpr)))
;;                     pf)))
;; (defthm a-ev-good-reduc-proof-proves

;;              (implies (and (subset (list (p 1 2) (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (g-termp (list val1 trace) 1 symbols)
;;                            (proves pfexpr (f-equal expr (ncode exp)) given defns symbols)
;;                            (proves pf
;;                                    (f-implies (isin (z-list (list val1
;;                                                                   (ncode flg)
;;                                                                   (ncode exp)
;;                                                                   (ncode va)
;;                                                                   (ncode fa)))
;;                                                     trace)
;;                                               conc)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl
;;                                   (f-implies (isin (z-list (list val1
;;                                                                  (ncode flg)
;;                                                                  expr
;;                                                                  (ncode va)
;;                                                                  (ncode fa)))
;;                                                    trace)
;;                                              conc)))
;;                       (proves (a-ev-good-reduc-proof flg exp expr va fa val1 trace conc pfexpr pf)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list) (use (proves-is-formula (pf pfexpr)
;;                                                        (exp (f-equal expr (ncode exp)))))))
;; (toggle g0900 a-ev-good-reduc-proof t)
;; (defun a-ev-defn-good-step-proof
;;       (cl1 cl2 dexp rvar rval val1 val-bar pf1 pf2)
;;       (tautconseq-proof (list (f-implies cl1 (f-implies dexp (f-equal rvar (ncode rval))))
;;                               (f-implies (f-equal rvar (ncode rval))
;;                                          (f-implies cl2 (f-implies dexp (f-equal val1 val-bar)))))
;;                         (f-implies (f-and cl1 cl2) (f-implies dexp (f-equal val1 val-bar)))
;;                         (list pf1
;;                               (form-equal-case-proof (list rvar)
;;                                                      (list (ncode rval))
;;                                                      (f-implies cl2
;;                                                                 (f-implies dexp
;;                                                                            (f-equal val1
;;                                                                                     val-bar)))
;;                                                      pf2))))
;; (defthm a-ev-defn-good-step-proof-proves

;;              (implies (and (g-variable rvar)
;;                            (g-formula cl2 symbols)
;;                            (g-termp (list val1 val-bar) 1 symbols)
;;                            (proves pf1
;;                                    (f-implies cl1 (f-implies dexp (f-equal rvar (ncode rval))))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (proves pf2
;;                                    (parallel-subst (f-implies cl2
;;                                                               (f-implies dexp
;;                                                                          (f-equal val1 val-bar)))
;;                                                    (list rvar)
;;                                                    (list (ncode rval))
;;                                                    0)
;;                                    given
;;                                    defns
;;                                    symbols))
;;                       (proves (a-ev-defn-good-step-proof cl1
;;                                                          cl2
;;                                                          dexp
;;                                                          rvar
;;                                                          rval
;;                                                          val1
;;                                                          val-bar
;;                                                          pf1
;;                                                          pf2)
;;                               (f-implies (f-and cl1 cl2) (f-implies dexp (f-equal val1 val-bar)))
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1)
;;                                       (exp (f-implies cl1
;;                                                       (f-implies dexp
;;                                                                  (f-equal rvar (ncode rval)))))))
;;               ))
;; (toggle g0901 a-ev-defn-good-step-proof t)
;; (defn
;;  a-ev-defn-part-list-good-proof
;;  (exp va fa val1 rvar1 rvar2 rval1 rval2 trace dexp pf1 pf2)
;;  (forsome-intro-proof
;;   rvar1
;;   (forsome rvar2
;;            (f-and (isin (z-list (list rvar1 (ncode 0) (z-car (ncode exp)) (ncode va) (ncode fa)))
;;                         trace)
;;                   (f-and (isin (z-list (list rvar2
;;                                              (ncode 1)
;;                                              (z-cdr (ncode exp))
;;                                              (ncode va)
;;                                              (ncode fa)))
;;                                trace)
;;                          (f-equal val1 (z-opair rvar1 rvar2)))))
;;   (f-implies dexp (f-equal val1 (ncode (cons rval1 rval2))))
;;   (forsome-intro-proof
;;    rvar2
;;    (f-and (isin (z-list (list rvar1 (ncode 0) (z-car (ncode exp)) (ncode va) (ncode fa))) trace)
;;           (f-and (isin (z-list (list rvar2 (ncode 1) (z-cdr (ncode exp)) (ncode va) (ncode fa)))
;;                        trace)
;;                  (f-equal val1 (z-opair rvar1 rvar2))))
;;    (f-implies dexp (f-equal val1 (ncode (cons rval1 rval2))))
;;    (a-ev-defn-good-step-proof
;;     (isin (z-list (list rvar1 (ncode 0) (z-car (ncode exp)) (ncode va) (ncode fa))) trace)
;;     (f-and (isin (z-list (list rvar2 (ncode 1) (z-cdr (ncode exp)) (ncode va) (ncode fa)))
;;                  trace)
;;            (f-equal val1 (z-opair rvar1 rvar2)))
;;     dexp
;;     rvar1
;;     rval1
;;     val1
;;     (ncode (cons rval1 rval2))
;;     (a-ev-good-reduc-proof 0
;;                            (car exp)
;;                            (z-car (ncode exp))
;;                            va
;;                            fa
;;                            rvar1
;;                            trace
;;                            (f-implies dexp (f-equal rvar1 (ncode rval1)))
;;                            (z-car-ncode-proof exp)
;;                            pf1)
;;     (a-ev-defn-good-step-proof
;;      (isin (z-list (list rvar2 (ncode 1) (z-cdr (ncode exp)) (ncode va) (ncode fa))) trace)
;;      (f-equal val1 (z-opair (ncode rval1) rvar2))
;;      dexp
;;      rvar2
;;      rval2
;;      val1
;;      (ncode (cons rval1 rval2))
;;      (a-ev-good-reduc-proof 1
;;                             (cdr exp)
;;                             (z-cdr (ncode exp))
;;                             va
;;                             fa
;;                             rvar2
;;                             trace
;;                             (f-implies dexp (f-equal rvar2 (ncode rval2)))
;;                             (z-cdr-ncode-proof exp)
;;                             pf2)
;;      (tautconseq-proof nil
;;                        (f-implies (f-equal val1 (ncode (cons rval1 rval2)))
;;                                   (f-implies dexp (f-equal val1 (ncode (cons rval1 rval2)))))
;;                        nil))))))
;; (toggle g0908 not-free-parallel-subst nil)
;; (prove-lemma
;;  a-ev-defn-part-list-good-proof-proves

;;  (implies (and (subset (list (fn 5 1) (fn 4 1) (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (p 2 1) (fn 0 0))
;;                        symbols)
;;                (z-succ-hyps defns symbols)
;;                (z-car-hyps defns symbols)
;;                (z-cdr-hyps defns symbols)
;;                (z-int-hyps defns symbols)
;;                (var-set (list rvar1 rvar2 val1 trace) 4)
;;                (nil-intersect (list rvar1 rvar2) (collect-free dexp 0))
;;                (proves pf1
;;                        (f-implies (isin (z-list (list rvar1
;;                                                       (ncode 0)
;;                                                       (ncode (car exp))
;;                                                       (ncode va)
;;                                                       (ncode fa)))
;;                                         trace)
;;                                   (f-implies dexp (f-equal rvar1 (ncode rval1))))
;;                        given
;;                        defns
;;                        symbols)
;;                (proves pf2
;;                        (f-implies (isin (z-list (list rvar2
;;                                                       (ncode 1)
;;                                                       (ncode (cdr exp))
;;                                                       (ncode va)
;;                                                       (ncode fa)))
;;                                         trace)
;;                                   (f-implies dexp (f-equal rvar2 (ncode rval2))))
;;                        given
;;                        defns
;;                        symbols)
;;                (equal concl
;;                       (f-implies (a-ev-list-part exp va fa val1 rvar1 rvar2 trace)
;;                                  (f-implies dexp (f-equal val1 (ncode (cons rval1 rval2)))))))
;;           (proves (a-ev-defn-part-list-good-proof exp
;;                                                   va
;;                                                   fa
;;                                                   val1
;;                                                   rvar1
;;                                                   rvar2
;;                                                   rval1
;;                                                   rval2
;;                                                   trace
;;                                                   dexp
;;                                                   pf1
;;                                                   pf2)
;;                   concl
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable z-list)
;;   (use (proves-is-formula (pf pf1)
;;                           (exp (f-implies (isin (z-list (list rvar1
;;                                                               (ncode 0)
;;                                                               (ncode (car exp))
;;                                                               (ncode va)
;;                                                               (ncode fa)))
;;                                                 trace)
;;                                           (f-implies dexp (f-equal rvar1 (ncode rval1)))))))))
;; (toggle g0916 a-ev-defn-part-list-good-proof t)
;; (defn
;;  a-ev-defn-part-if-good-proof
;;  (exp va fa val1 val trace rvar1 rval1 dexp pf1 pf)
;;  (forsome-intro-proof
;;   rvar1
;;   (g-body (a-ev-if-part (ncode exp) (ncode va) (ncode fa) val1 trace rvar1))
;;   (f-implies dexp (f-equal val1 (ncode val)))
;;   (a-ev-defn-good-step-proof
;;    (isin (z-list (list rvar1 (ncode 0) (z-car (z-cdr (ncode exp))) (ncode va) (ncode fa))) trace)
;;    (f-if (f-equal rvar1 (ncode 0))
;;          (isin (z-list (list val1
;;                              (ncode 0)
;;                              (z-car-cdr (ncode exp) (list 1 2 2 2))
;;                              (ncode va)
;;                              (ncode fa)))
;;                trace)
;;          (isin (z-list (list val1
;;                              (ncode 0)
;;                              (z-car-cdr (ncode exp) (list 1 2 2))
;;                              (ncode va)
;;                              (ncode fa)))
;;                trace))
;;    dexp
;;    rvar1
;;    rval1
;;    val1
;;    (ncode val)
;;    (a-ev-good-reduc-proof 0
;;                           (cadr exp)
;;                           (z-car (z-cdr (ncode exp)))
;;                           va
;;                           fa
;;                           rvar1
;;                           trace
;;                           (f-implies dexp (f-equal rvar1 (ncode rval1)))
;;                           (z-car-cdr-proof exp (list 1 2))
;;                           pf1)
;;    (rec-form-z-if-eval-proof (list (list (ncode-equal rval1 0)
;;                                          (ident-axiom-proof (ncode 0))
;;                                          (ncode-nequal-proof rval1 0))
;;                                    (a-ev-good-reduc-proof 0
;;                                                           (cadddr exp)
;;                                                           (z-car-cdr (ncode exp) (list 1 2 2 2))
;;                                                           va
;;                                                           fa
;;                                                           val1
;;                                                           trace
;;                                                           (f-implies dexp
;;                                                                      (f-equal val1 (ncode val)))
;;                                                           (z-car-cdr-proof exp (list 1 2 2 2))
;;                                                           pf)
;;                                    (a-ev-good-reduc-proof 0
;;                                                           (caddr exp)
;;                                                           (z-car-cdr (ncode exp) (list 1 2 2))
;;                                                           va
;;                                                           fa
;;                                                           val1
;;                                                           trace
;;                                                           (f-implies dexp
;;                                                                      (f-equal val1
;;                                                                               (ncode val)))
;;                                                           (z-car-cdr-proof exp (list 1 2 2))
;;                                                           pf))
;;                              (z-if (f-equal (ncode rval1) (ncode 0))
;;                                    (isin (z-list (list val1
;;                                                        (ncode 0)
;;                                                        (z-car-cdr (ncode exp) (list 1 2 2 2))
;;                                                        (ncode va)
;;                                                        (ncode fa)))
;;                                          trace)
;;                                    (isin (z-list (list val1
;;                                                        (ncode 0)
;;                                                        (z-car-cdr (ncode exp) (list 1 2 2))
;;                                                        (ncode va)
;;                                                        (ncode fa)))
;;                                          trace))
;;                              (f-implies dexp (f-equal val1 (ncode val)))))))
;; (defthm atom-nacl2-numberp-ncode

;;              (implies (and (not (consp x))
;;                            (not (acl2-numberp x)))
;;                       (equal (ncode x) (ncode 0)))
;;              ((enable ncode)))
;; (prove-lemma
;;  a-ev-defn-part-if-good-proof-proves

;;  (implies (and (subset (list (fn 5 1) (fn 4 1) (fn 3 1) (fn 2 2) (fn 1 2) (p 1 2) (p 2 1) (fn 0 0))
;;                        symbols)
;;                (z-succ-hyps defns symbols)
;;                (z-car-hyps defns symbols)
;;                (z-cdr-hyps defns symbols)
;;                (z-int-hyps defns symbols)
;;                (var-set (list rvar1 val1 trace) 3)
;;                (not (member rvar1 (collect-free dexp 0)))
;;                (proves pf1
;;                        (f-implies (isin (z-list (list rvar1
;;                                                       (ncode 0)
;;                                                       (ncode (cadr exp))
;;                                                       (ncode va)
;;                                                       (ncode fa)))
;;                                         trace)
;;                                   (f-implies dexp (f-equal rvar1 (ncode rval1))))
;;                        given
;;                        defns
;;                        symbols)
;;                (if (ncode-equal rval1 0)
;;                    (proves pf
;;                            (f-implies (isin (z-list (list val1
;;                                                           (ncode 0)
;;                                                           (ncode (cadddr exp))
;;                                                           (ncode va)
;;                                                           (ncode fa)))
;;                                             trace)
;;                                       (f-implies dexp (f-equal val1 (ncode val))))
;;                            given
;;                            defns
;;                            symbols)
;;                    (proves pf
;;                            (f-implies (isin (z-list (list val1
;;                                                           (ncode 0)
;;                                                           (ncode (caddr exp))
;;                                                           (ncode va)
;;                                                           (ncode fa)))
;;                                             trace)
;;                                       (f-implies dexp (f-equal val1 (ncode val))))
;;                            given
;;                            defns
;;                            symbols))
;;                (equal concl
;;                       (f-implies (a-ev-if-part (ncode exp)
;;                                                (ncode va)
;;                                                (ncode fa)
;;                                                val1
;;                                                trace
;;                                                rvar1)
;;                                  (f-implies dexp (f-equal val1 (ncode val))))))
;;           (proves (a-ev-defn-part-if-good-proof exp va fa val1 val trace rvar1 rval1 dexp pf1 pf)
;;                   concl
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable z-list)
;;   (use (proves-is-formula (pf pf1)
;;                           (exp (f-implies (isin (z-list (list rvar1
;;                                                               (ncode 0)
;;                                                               (ncode (cadr exp))
;;                                                               (ncode va)
;;                                                               (ncode fa)))
;;                                                 trace)
;;                                           (f-implies dexp (f-equal rvar1 (ncode rval1)))))))))
;; (toggle g0919 a-ev-defn-part-if-good-proof t)
;; (toggle g0920 atom-nacl2-numberp-ncode t)
;; (defn
;;  a-ev-defn-part-subr-good-proof
;;  (exp va fa val1 trace rvar1 rval1 dexp pf)
;;  (forsome-intro-proof
;;   rvar1
;;   (g-body (a-ev-subr-part exp va fa val1 rvar1 trace))
;;   (f-implies dexp (f-equal val1 (ncode (apply-subr (car exp) rval1))))
;;   (a-ev-defn-good-step-proof
;;    (isin (z-list (list rvar1 (ncode 1) (z-cdr (ncode exp)) (ncode va) (ncode fa))) trace)
;;    (f-equal val1 (z-apply-subr (z-car (ncode exp)) rvar1))
;;    dexp
;;    rvar1
;;    rval1
;;    val1
;;    (ncode (apply-subr (car exp) rval1))
;;    (a-ev-good-reduc-proof 1
;;                           (cdr exp)
;;                           (z-cdr (ncode exp))
;;                           va
;;                           fa
;;                           rvar1
;;                           trace
;;                           (f-implies dexp (f-equal rvar1 (ncode rval1)))
;;                           (z-cdr-ncode-proof exp)
;;                           pf)
;;    (tautconseq-proof (list (f-equal (z-apply-subr (z-car (ncode exp)) (ncode rval1))
;;                                     (ncode (apply-subr (car exp) rval1)))
;;                            (f-implies (f-equal val1
;;                                                (z-apply-subr (z-car (ncode exp))
;;                                                              (ncode rval1)))
;;                                       (f-implies (f-equal (z-apply-subr (z-car (ncode exp))
;;                                                                         (ncode rval1))
;;                                                           (ncode (apply-subr (car exp)
;;                                                                              rval1)))
;;                                                  (f-equal val1
;;                                                           (ncode (apply-subr (car exp)
;;                                                                              rval1))))))
;;                      (f-implies (f-equal val1 (z-apply-subr (z-car (ncode exp)) (ncode rval1)))
;;                                 (f-implies dexp
;;                                            (f-equal val1 (ncode (apply-subr (car exp) rval1)))))
;;                      (list (compose-proof (fn 15 2)
;;                                           (ncode (apply-subr (car exp) rval1))
;;                                           (list (z-car (ncode exp)) (ncode rval1))
;;                                           (list (ncode (car exp)) (ncode rval1))
;;                                           (list (z-car-ncode-proof exp)
;;                                                 (ident-axiom-proof (ncode rval1)))
;;                                           (z-apply-subr-ncode-proof (car exp) rval1))
;;                            (trans-equal-proof3 val1
;;                                                (z-apply-subr (z-car (ncode exp))
;;                                                              (ncode rval1))
;;                                                (ncode (apply-subr (car exp) rval1))))))))
;; (prove-lemma
;;  a-ev-defn-part-subr-good-proof-proves

;;  (implies (and (subset (list (fn 15 2)
;;                              (fn 14 2)
;;                              (fn 13 2)
;;                              (fn 12 2)
;;                              (fn 0 0)
;;                              (fn 3 1)
;;                              (fn 4 1)
;;                              (fn 5 1)
;;                              (fn 6 1)
;;                              (fn 7 1)
;;                              (fn 8 1)
;;                              (fn 9 1)
;;                              (fn 10 1)
;;                              (fn 11 2)
;;                              (fn 1 2)
;;                              (fn 2 2)
;;                              (p 2 1)
;;                              (p 1 2))
;;                        symbols)
;;                (z-apply-subr-all-hyps given defns symbols)
;;                (var-set (list rvar1 val1 trace) 3)
;;                (not (member rvar1 (collect-free dexp 0)))
;;                (proves pf
;;                        (f-implies (isin (z-list (list rvar1
;;                                                       (ncode 1)
;;                                                       (ncode (cdr exp))
;;                                                       (ncode va)
;;                                                       (ncode fa)))
;;                                         trace)
;;                                   (f-implies dexp (f-equal rvar1 (ncode rval1))))
;;                        given
;;                        defns
;;                        symbols)
;;                (equal concl
;;                       (f-implies (a-ev-subr-part exp va fa val1 rvar1 trace)
;;                                  (f-implies dexp
;;                                             (f-equal val1 (ncode (apply-subr (car exp) rval1)))))))
;;           (proves (a-ev-defn-part-subr-good-proof exp va fa val1 trace rvar1 rval1 dexp pf)
;;                   concl
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable z-list)
;;   (use (proves-is-formula (exp (f-implies (isin (z-list (list rvar1
;;                                                               (ncode 1)
;;                                                               (ncode (cdr exp))
;;                                                               (ncode va)
;;                                                               (ncode fa)))
;;                                                 trace)
;;                                           (f-implies dexp (f-equal rvar1 (ncode rval1)))))))))
;; (toggle g0921 a-ev-defn-part-subr-good-proof t)
;; (defthm parallel-subst-var

;;              (implies (acl2-numberp exp)
;;                       (equal (parallel-subst exp vars terms 0) (getpf exp vars terms))))
;; (toggle g0922 not-free-parallel-subst t)
;; (toggle g0923 parallel-subst-nil nil)
;; (toggle g0924 get-graph t)
;; (defun a-ev-fun-part-body
;;       (exp fa val1 trace rvar1 getva tr1)
;;       (f-implies (a-get (z-sub1-n (z-car (ncode exp)) 11) (ncode fa) getva 11 13 14 tr1)
;;                  (isin (z-list (list val1 (ncode 0) getva rvar1 (ncode fa))) trace)))
;; (defn
;;  a-get-ev-good-reduc-proof
;;  (exp fa getval x1 y1 val1 tr1)
;;  (tautconseq-proof
;;   (list (f-implies (isin (z-list (list getval (ncode (sub1-n (car exp) 11)) (ncode fa))) tr1)
;;                    (isin (z-list (list getval (z-sub1-n (z-car (ncode exp)) 11) (ncode fa))) tr1))
;;         (a-get (ncode (sub1-n (car exp) 11)) (ncode fa) getval x1 y1 val1 tr1))
;;   (a-get (z-sub1-n (z-car (ncode exp)) 11) (ncode fa) getval x1 y1 val1 tr1)
;;   (list
;;    (equal-z-list-isin-imp-proof
;;     (list getval (ncode (sub1-n (car exp) 11)) (ncode fa))
;;     (list getval (z-sub1-n (z-car (ncode exp)) 11) (ncode fa))
;;     tr1
;;     (list (ident-axiom-proof getval)
;;           (flip-equals-proof (z-sub1-n (z-car (ncode exp)) 11)
;;                              (ncode (sub1-n (car exp) 11))
;;                              (z-sub1-n-ncode-proof (z-car (ncode exp))
;;                                                    11
;;                                                    (car exp)
;;                                                    (z-car-ncode-proof exp)))
;;           (ident-axiom-proof (ncode fa))))
;;    (a-get-ok-proof1 (sub1-n (car exp) 11) fa x1 y1 val1))))
;; (defthm a-get-ev-good-reduc-proof-proves

;;              (implies (and (subset (list (fn 10 1)
;;                                          (fn 9 1)
;;                                          (fn 5 1)
;;                                          (fn 4 1)
;;                                          (fn 3 1)
;;                                          (fn 2 2)
;;                                          (fn 1 2)
;;                                          (p 1 2)
;;                                          (p 2 1)
;;                                          (fn 0 0))
;;                                    symbols)
;;                            (z-succ-hyps defns symbols)
;;                            (z-car-hyps defns symbols)
;;                            (z-cdr-hyps defns symbols)
;;                            (z-zerop-hyps defns symbols)
;;                            (z-sub1-hyps defns symbols)
;;                            (z-int-hyps defns symbols)
;;                            (var-set (list x1 y1 val1) 3)
;;                            (equal getval (ncode (get (sub1-n (car exp) 11) fa)))
;;                            (equal tr1 (graph-trans (get-graph (sub1-n (car exp) 11) fa)))
;;                            (equal concl
;;                                   (a-get (z-sub1-n (z-car (ncode exp)) 11)
;;                                          (ncode fa)
;;                                          getval
;;                                          x1
;;                                          y1
;;                                          val1
;;                                          tr1)))
;;                       (proves (a-get-ev-good-reduc-proof exp fa getval x1 y1 val1 tr1)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0925 a-get-ev-good-reduc-proof t)
;; (defn
;;  a-ev-defn-part-fun-good-proof
;;  (exp va fa val1 val trace rval1 dexp pf1 pf2)
;;  (forsome-intro-proof
;;   11
;;   (g-body (a-ev-fun-part exp va fa val1 trace))
;;   (f-implies dexp (f-equal val1 (ncode val)))
;;   (chain-proof
;;    (g-body (a-ev-fun-part exp va fa val1 trace))
;;    (f-implies dexp (f-equal val1 (ncode val)))
;;    (list (f-and (isin (z-list (list 11 (ncode 1) (z-cdr (ncode exp)) (ncode va) (ncode fa)))
;;                       trace)
;;                 (a-ev-fun-part-body exp
;;                                     fa
;;                                     val1
;;                                     trace
;;                                     11
;;                                     (ncode (get (sub1-n (car exp) 11) fa))
;;                                     (graph-trans (get-graph (sub1-n (car exp) 11) fa)))))
;;    (list
;;     (subst-thm-b-proof (f-and (isin (z-list (list 11
;;                                                   (ncode 1)
;;                                                   (z-cdr (ncode exp))
;;                                                   (ncode va)
;;                                                   (ncode fa)))
;;                                     trace)
;;                               (a-ev-fun-part-body exp fa val1 trace 11 15 16))
;;                        (list 15 16)
;;                        (list (ncode (get (sub1-n (car exp) 11) fa))
;;                              (graph-trans (get-graph (sub1-n (car exp) 11) fa))))
;;     (a-ev-defn-good-step-proof
;;      (isin (z-list (list 11 (ncode 1) (z-cdr (ncode exp)) (ncode va) (ncode fa))) trace)
;;      (a-ev-fun-part-body exp
;;                          fa
;;                          val1
;;                          trace
;;                          11
;;                          (ncode (get (sub1-n (car exp) 11) fa))
;;                          (graph-trans (get-graph (sub1-n (car exp) 11) fa)))
;;      dexp
;;      11
;;      rval1
;;      val1
;;      (ncode val)
;;      (a-ev-good-reduc-proof 1
;;                             (cdr exp)
;;                             (z-cdr (ncode exp))
;;                             va
;;                             fa
;;                             11
;;                             trace
;;                             (f-implies dexp (f-equal 11 (ncode rval1)))
;;                             (z-cdr-ncode-proof exp)
;;                             pf1)
;;      (tautconseq-proof
;;       (list (a-get (z-sub1-n (z-car (ncode exp)) 11)
;;                    (ncode fa)
;;                    (ncode (get (sub1-n (car exp) 11) fa))
;;                    11
;;                    13
;;                    14
;;                    (graph-trans (get-graph (sub1-n (car exp) 11) fa)))
;;             (f-implies (isin (z-list (list val1
;;                                            (ncode 0)
;;                                            (ncode (get (sub1-n (car exp) 11) fa))
;;                                            (ncode rval1)
;;                                            (ncode fa)))
;;                              trace)
;;                        (f-implies dexp (f-equal val1 (ncode val)))))
;;       (f-implies (a-ev-fun-part-body exp
;;                                      fa
;;                                      val1
;;                                      trace
;;                                      (ncode rval1)
;;                                      (ncode (get (sub1-n (car exp) 11) fa))
;;                                      (graph-trans (get-graph (sub1-n (car exp) 11) fa)))
;;                  (f-implies dexp (f-equal val1 (ncode val))))
;;       (list (a-get-ev-good-reduc-proof exp
;;                                        fa
;;                                        (ncode (get (sub1-n (car exp) 11) fa))
;;                                        11
;;                                        13
;;                                        14
;;                                        (graph-trans (get-graph (sub1-n (car exp) 11) fa)))
;;             pf2)))))))
;; (prove-lemma
;;  a-ev-defn-part-fun-good-proof-proves

;;  (implies (and (subset (list (fn 10 1)
;;                              (fn 9 1)
;;                              (fn 5 1)
;;                              (fn 4 1)
;;                              (fn 3 1)
;;                              (fn 2 2)
;;                              (fn 1 2)
;;                              (p 1 2)
;;                              (p 2 1)
;;                              (fn 0 0))
;;                        symbols)
;;                (z-succ-hyps defns symbols)
;;                (z-car-hyps defns symbols)
;;                (z-cdr-hyps defns symbols)
;;                (z-int-hyps defns symbols)
;;                (z-zerop-hyps defns symbols)
;;                (z-sub1-hyps defns symbols)
;;                (var-set (list 11 15 16 val1 trace) 5)
;;                (not (member 11 (collect-free dexp 0)))
;;                (proves pf1
;;                        (f-implies (isin (z-list (list 11
;;                                                       (ncode 1)
;;                                                       (ncode (cdr exp))
;;                                                       (ncode va)
;;                                                       (ncode fa)))
;;                                         trace)
;;                                   (f-implies dexp (f-equal 11 (ncode rval1))))
;;                        given
;;                        defns
;;                        symbols)
;;                (proves pf2
;;                        (f-implies (isin (z-list (list val1
;;                                                       (ncode 0)
;;                                                       (ncode (get (sub1-n (car exp) 11) fa))
;;                                                       (ncode rval1)
;;                                                       (ncode fa)))
;;                                         trace)
;;                                   (f-implies dexp (f-equal val1 (ncode val))))
;;                        given
;;                        defns
;;                        symbols)
;;                (equal concl
;;                       (f-implies (a-ev-fun-part exp va fa val1 trace)
;;                                  (f-implies dexp (f-equal val1 (ncode val))))))
;;           (proves (a-ev-defn-part-fun-good-proof exp va fa val1 val trace rval1 dexp pf1 pf2)
;;                   concl
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable z-list)
;;   (use (proves-is-formula (pf pf1)
;;                           (exp (f-implies (isin (z-list (list 11
;;                                                               (ncode 1)
;;                                                               (ncode (cdr exp))
;;                                                               (ncode va)
;;                                                               (ncode fa)))
;;                                                 trace)
;;                                           (f-implies dexp (f-equal 11 (ncode rval1))))))
;;        (not-free-parallel-subst (exp dexp)
;;                                 (vars (list 11))
;;                                 (terms (list (ncode rval1)))
;;                                 (flg 0)))))
;; (toggle g0926 a-ev-defn-part-fun-good-proof t)
;; (defun sub-rvar-proof
;;       (flg exp va fa trace rvar val1 dexp rval pf)
;;       (subst-rule-proof (f-implies (isin (z-list (list val1
;;                                                        (ncode flg)
;;                                                        (ncode exp)
;;                                                        (ncode va)
;;                                                        (ncode fa)))
;;                                          trace)
;;                                    (f-implies dexp (f-equal val1 (ncode rval))))
;;                         val1
;;                         rvar
;;                         pf))
;; (toggle g0927 not-free-covering nil)
;; (defthm sub-rvar-proof-proves

;;              (implies (and (var-set (list val1 trace) 2)
;;                            (g-termp rvar 0 symbols)
;;                            (not (member val1 (collect-free dexp 0)))
;;                            (proves pf
;;                                    (f-implies (isin (z-list (list val1
;;                                                                   (ncode flg)
;;                                                                   (ncode exp)
;;                                                                   (ncode va)
;;                                                                   (ncode fa)))
;;                                                     trace)
;;                                               (f-implies dexp (f-equal val1 (ncode rval))))
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl
;;                                   (f-implies (isin (z-list (list rvar
;;                                                                  (ncode flg)
;;                                                                  (ncode exp)
;;                                                                  (ncode va)
;;                                                                  (ncode fa)))
;;                                                    trace)
;;                                              (f-implies dexp (f-equal rvar (ncode rval))))))
;;                       (proves (sub-rvar-proof flg exp va fa trace rvar val1 dexp rval pf)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0928 sub-rvar-proof t)
;; (defun ind-form
;;       (flg exp va fa val1 val trace dexp)
;;       (f-implies (isin (z-list (list val1 (ncode flg) (ncode exp) (ncode va) (ncode fa))) trace)
;;                  (f-implies dexp (f-equal val1 (ncode val)))))
;; (defthm form-z-if-ev-defn-part-again

;;              (implies (and (subset (list (fn 16 1)
;;                                          (fn 15 2)
;;                                          (fn 14 2)
;;                                          (fn 13 2)
;;                                          (fn 12 2)
;;                                          (fn 0 0)
;;                                          (fn 3 1)
;;                                          (fn 4 1)
;;                                          (fn 5 1)
;;                                          (fn 6 1)
;;                                          (fn 7 1)
;;                                          (fn 8 1)
;;                                          (fn 9 1)
;;                                          (fn 10 1)
;;                                          (fn 11 2)
;;                                          (fn 1 2)
;;                                          (fn 2 2)
;;                                          (p 2 1)
;;                                          (p 1 2))
;;                                    symbols)
;;                            (g-termp (list val1 trace) 1 symbols))
;;                       (form-z-if (z-ev-defn-part flg exp va fa val1 trace) symbols)))
;; (defthm ncode-equal-ident-axiom-proof-proves

;;              (implies (and (subset (list (fn 0 0) (fn 1 2) (fn 2 2) (fn 3 1)) symbols)
;;                            (ncode-equal x y))
;;                       (proves (ident-axiom-proof (ncode x))
;;                               (f-equal (ncode x) (ncode y))
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0929 a-ev-defn-part nil)
;; (defn
;;  a-ev-defn-part-good-pftree
;;  (flg exp va fa n val1 trace dexp pf1 pf2)
;;  (list
;;   (list (equal flg 1) (ident-axiom-proof (ncode 1)) (ncode-nequal-proof flg 1))
;;   (list (list (consp exp)
;;               (z-consp-ncode-proof exp)
;;               (trans-not-equal-proof (ncode 1)
;;                                      (z-consp (ncode exp))
;;                                      (ncode 0)
;;                                      (ncode-nequal-proof 1 0)
;;                                      (z-consp-ncode-proof exp)))
;;         (a-ev-defn-part-list-good-proof exp
;;                                         va
;;                                         fa
;;                                         val1
;;                                         11
;;                                         12
;;                                         (ev 0 (car exp) va fa n)
;;                                         (ev 1 (cdr exp) va fa n)
;;                                         trace
;;                                         dexp
;;                                         (sub-rvar-proof 0
;;                                                         (car exp)
;;                                                         va
;;                                                         fa
;;                                                         trace
;;                                                         11
;;                                                         val1
;;                                                         dexp
;;                                                         (ev 0 (car exp) va fa n)
;;                                                         pf1)
;;                                         (sub-rvar-proof 1
;;                                                         (cdr exp)
;;                                                         va
;;                                                         fa
;;                                                         trace
;;                                                         12
;;                                                         val1
;;                                                         dexp
;;                                                         (ev 1 (cdr exp) va fa n)
;;                                                         pf2))
;;         (tautconseq-proof nil
;;                           (f-implies (f-equal val1 (ncode nil))
;;                                      (f-implies dexp (f-equal val1 (ncode nil))))
;;                           nil))
;;   (list
;;    (list (consp exp)
;;          (z-consp-ncode-proof exp)
;;          (trans-not-equal-proof (ncode 1)
;;                                 (z-consp (ncode exp))
;;                                 (ncode 0)
;;                                 (ncode-nequal-proof 1 0)
;;                                 (z-consp-ncode-proof exp)))
;;    (list
;;     (list (zerop (car exp))
;;           (compose-car-proof (fn 9 1) (ncode 1) exp (z-zerop-ncode-proof (car exp)))
;;           (trans-not-equal-proof (ncode 1)
;;                                  (z-zerop (z-car (ncode exp)))
;;                                  (ncode 0)
;;                                  (ncode-nequal-proof 1 0)
;;                                  (compose-car-proof (fn 9 1)
;;                                                     (ncode 0)
;;                                                     exp
;;                                                     (z-zerop-ncode-proof (car exp)))))
;;     (a-ev-defn-part-if-good-proof exp
;;                                   va
;;                                   fa
;;                                   val1
;;                                   (ev flg exp va fa n)
;;                                   trace
;;                                   11
;;                                   (ev 0 (cadr exp) va fa n)
;;                                   dexp
;;                                   (sub-rvar-proof 0
;;                                                   (cadr exp)
;;                                                   va
;;                                                   fa
;;                                                   trace
;;                                                   11
;;                                                   val1
;;                                                   dexp
;;                                                   (ev 0 (cadr exp) va fa n)
;;                                                   pf1)
;;                                   pf2)
;;     (list
;;      (list (equal (car exp) 10)
;;            (z-car-ncode-proof exp)
;;            (trans-not-equal-proof (ncode 10)
;;                                   (z-car (ncode exp))
;;                                   (ncode (car exp))
;;                                   (ncode-nequal-proof 10 (car exp))
;;                                   (z-car-ncode-proof exp)))
;;      (tautconseq-proof (list (f-equal (z-car-cdr (ncode exp) (list 1 2)) (ncode (cadr exp)))
;;                              (f-implies (f-equal val1 (z-car-cdr (ncode exp) (list 1 2)))
;;                                         (f-implies (f-equal (z-car-cdr (ncode exp) (list 1 2))
;;                                                             (ncode (cadr exp)))
;;                                                    (f-equal val1 (ncode (cadr exp))))))
;;                        (f-implies (f-equal val1 (z-car-cdr (ncode exp) (list 1 2)))
;;                                   (f-implies dexp (f-equal val1 (ncode (cadr exp)))))
;;                        (list (z-car-cdr-proof exp (list 1 2))
;;                              (trans-equal-proof3 val1
;;                                                  (z-car-cdr (ncode exp) (list 1 2))
;;                                                  (ncode (cadr exp)))))
;;      (list (list (subrp (car exp))
;;                  (compose-car-proof (fn 16 1) (ncode 1) exp (z-subrp-ncode-proof (car exp)))
;;                  (trans-not-equal-proof (ncode 1)
;;                                         (z-subrp (z-car (ncode exp)))
;;                                         (ncode 0)
;;                                         (ncode-nequal-proof 1 0)
;;                                         (compose-car-proof (fn 16 1)
;;                                                            (ncode 0)
;;                                                            exp
;;                                                            (z-subrp-ncode-proof (car exp)))))
;;            (a-ev-defn-part-subr-good-proof exp
;;                                            va
;;                                            fa
;;                                            val1
;;                                            trace
;;                                            11
;;                                            (ev 1 (cdr exp) va fa n)
;;                                            dexp
;;                                            (sub-rvar-proof 1
;;                                                            (cdr exp)
;;                                                            va
;;                                                            fa
;;                                                            trace
;;                                                            11
;;                                                            val1
;;                                                            dexp
;;                                                            (ev 1 (cdr exp) va fa n)
;;                                                            pf1))
;;            (a-ev-defn-part-fun-good-proof exp
;;                                           va
;;                                           fa
;;                                           val1
;;                                           (ev flg exp va fa n)
;;                                           trace
;;                                           (ev 1 (cdr exp) va fa n)
;;                                           dexp
;;                                           (sub-rvar-proof 1
;;                                                           (cdr exp)
;;                                                           va
;;                                                           fa
;;                                                           trace
;;                                                           11
;;                                                           val1
;;                                                           dexp
;;                                                           (ev 1 (cdr exp) va fa n)
;;                                                           pf1)
;;                                           pf2))))
;;    (tautconseq-proof (list (f-implies (a-get1 (ncode exp) (ncode va) val1 11 13 14 16)
;;                                       (f-equal val1 (ncode (ev flg exp va fa n)))))
;;                      (f-implies (a-get1 (ncode exp) (ncode va) val1 11 13 14 16)
;;                                 (f-implies dexp (f-equal val1 (ncode (ev flg exp va fa n)))))
;;                      (list (a-get1-good-proof exp va val1 11 13 14 16))))))
;; (defun a-ev-defn-part-good-proof
;;       (flg exp va fa n val1 trace dexp pf1 pf2)
;;       (rec-form-z-if-eval-proof (a-ev-defn-part-good-pftree flg
;;                                                             exp
;;                                                             va
;;                                                             fa
;;                                                             n
;;                                                             val1
;;                                                             trace
;;                                                             dexp
;;                                                             pf1
;;                                                             pf2)
;;                                 (z-ev-defn-part flg exp va fa val1 trace)
;;                                 (f-implies dexp (f-equal val1 (ncode (ev flg exp va fa n))))))
;; (defthm a-ev-defn-part-good-proof-proves-quote-case

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (equal (car exp) 10)
;;                            (ev-hyps given defns symbols)
;;                            (var-set (list 11 12 15 16 val1 trace) 6)
;;                            (g-formula dexp symbols)
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (f-implies (a-ev-defn-part flg exp va fa val1 trace)
;;                                              (f-implies dexp
;;                                                         (f-equal val1
;;                                                                  (ncode (ev flg exp va fa n)))))))
;;                       (proves (a-ev-defn-part-good-proof flg exp va fa n val1 trace dexp pf1 pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list
;;                        a-ev-list-part
;;                        a-ev-if-part
;;                        a-ev-subr-part
;;                        a-ev-fun-part
;;                        a-get1
;;                        atom-ncode
;;                        nzerop-ncode-equal
;;                        form-z-if
;;                        proves-is-formula-again
;;                        ev-if-reduc
;;                        ev-list-reduc
;;                        ev-subr-reduc
;;                        ev-fun-reduc)
;;               (use (form-z-if-ev-defn-part-again))))
;; (defthm a-ev-defn-part-good-proof-proves-list-case

;;              (implies (and (equal flg 1)
;;                            (consp exp)
;;                            (ev-hyps given defns symbols)
;;                            (var-set (list 11 12 15 16 val1 trace) 6)
;;                            (nil-intersect (list 11 12 val1) (collect-free dexp 0))
;;                            (not (btmp (ev 1 exp va fa n)))
;;                            (and (proves pf1
;;                                         (ind-form 0
;;                                                   (car exp)
;;                                                   va
;;                                                   fa
;;                                                   val1
;;                                                   (ev 0 (car exp) va fa n)
;;                                                   trace
;;                                                   dexp)
;;                                         given
;;                                         defns
;;                                         symbols)
;;                                 (proves pf2
;;                                         (ind-form 1
;;                                                   (cdr exp)
;;                                                   va
;;                                                   fa
;;                                                   val1
;;                                                   (ev 1 (cdr exp) va fa n)
;;                                                   trace
;;                                                   dexp)
;;                                         given
;;                                         defns
;;                                         symbols))
;;                            (equal concl
;;                                   (f-implies (a-ev-defn-part flg exp va fa val1 trace)
;;                                              (f-implies dexp
;;                                                         (f-equal val1
;;                                                                  (ncode (ev flg exp va fa n)))))))
;;                       (proves (a-ev-defn-part-good-proof flg exp va fa n val1 trace dexp pf1 pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list
;;                        a-ev-list-part
;;                        a-ev-if-part
;;                        a-ev-subr-part
;;                        a-ev-fun-part
;;                        a-get1
;;                        atom-ncode
;;                        nzerop-ncode-equal
;;                        form-z-if
;;                        proves-is-formula-again
;;                        ev
;;                        ev-if-reduc
;;                        ev-subr-reduc
;;                        ev-fun-reduc)
;;               (use (form-z-if-ev-defn-part-again))))
;; (defthm a-ev-defn-part-good-proof-proves-nlist-case

;;              (implies (and (equal flg 1)
;;                            (atom exp)
;;                            (ev-hyps given defns symbols)
;;                            (var-set (list 11 12 15 16 val1 trace) 6)
;;                            (g-formula dexp symbols)
;;                            (not (btmp (ev 1 exp va fa n)))
;;                            (equal concl
;;                                   (f-implies (a-ev-defn-part flg exp va fa val1 trace)
;;                                              (f-implies dexp
;;                                                         (f-equal val1
;;                                                                  (ncode (ev flg exp va fa n)))))))
;;                       (proves (a-ev-defn-part-good-proof flg exp va fa n val1 trace dexp pf1 pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list
;;                        a-ev-list-part
;;                        a-ev-if-part
;;                        a-ev-subr-part
;;                        a-ev-fun-part
;;                        a-get1
;;                        atom-ncode
;;                        nzerop-ncode-equal
;;                        form-z-if
;;                        proves-is-formula-again
;;                        ev-if-reduc
;;                        ev-list-reduc
;;                        ev-subr-reduc
;;                        ev-fun-reduc)
;;               (use (form-z-if-ev-defn-part-again))))
;; (defthm a-ev-defn-part-good-proof-proves-if-case

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (zerop (car exp))
;;                            (ev-hyps given defns symbols)
;;                            (var-set (list 11 12 15 16 val1 trace) 6)
;;                            (nil-intersect (list 11 12 val1) (collect-free dexp 0))
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (and (proves pf1
;;                                         (ind-form 0
;;                                                   (cadr exp)
;;                                                   va
;;                                                   fa
;;                                                   val1
;;                                                   (ev 0 (cadr exp) va fa n)
;;                                                   trace
;;                                                   dexp)
;;                                         given
;;                                         defns
;;                                         symbols)
;;                                 (if (ncode-equal (ev 0 (cadr exp) va fa n) 0)
;;                                     (proves pf2
;;                                             (ind-form 0
;;                                                       (cadddr exp)
;;                                                       va
;;                                                       fa
;;                                                       val1
;;                                                       (ev 0 (cadddr exp) va fa n)
;;                                                       trace
;;                                                       dexp)
;;                                             given
;;                                             defns
;;                                             symbols)
;;                                     (proves pf2
;;                                             (ind-form 0
;;                                                       (caddr exp)
;;                                                       va
;;                                                       fa
;;                                                       val1
;;                                                       (ev 0 (caddr exp) va fa n)
;;                                                       trace
;;                                                       dexp)
;;                                             given
;;                                             defns
;;                                             symbols)))
;;                            (equal concl
;;                                   (f-implies (a-ev-defn-part flg exp va fa val1 trace)
;;                                              (f-implies dexp
;;                                                         (f-equal val1
;;                                                                  (ncode (ev flg exp va fa n)))))))
;;                       (proves (a-ev-defn-part-good-proof flg exp va fa n val1 trace dexp pf1 pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list
;;                        a-ev-list-part
;;                        a-ev-if-part
;;                        a-ev-subr-part
;;                        a-ev-fun-part
;;                        a-get1
;;                        atom-ncode
;;                        form-z-if
;;                        proves-is-formula-again
;;                        ev
;;                        ev-list-reduc
;;                        ev-subr-reduc
;;                        ev-fun-reduc)
;;               (use (form-z-if-ev-defn-part-again))))
;; (defthm a-ev-defn-part-good-proof-proves-subr-case

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (not (zerop (car exp)))
;;                            (not (equal (car exp) 10))
;;                            (subrp (car exp))
;;                            (ev-hyps given defns symbols)
;;                            (var-set (list 11 12 15 16 val1 trace) 6)
;;                            (nil-intersect (list 11 12 val1) (collect-free dexp 0))
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (proves pf1
;;                                    (ind-form 1
;;                                              (cdr exp)
;;                                              va
;;                                              fa
;;                                              val1
;;                                              (ev 1 (cdr exp) va fa n)
;;                                              trace
;;                                              dexp)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl
;;                                   (f-implies (a-ev-defn-part flg exp va fa val1 trace)
;;                                              (f-implies dexp
;;                                                         (f-equal val1
;;                                                                  (ncode (ev flg exp va fa n)))))))
;;                       (proves (a-ev-defn-part-good-proof flg exp va fa n val1 trace dexp pf1 pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list
;;                        a-ev-list-part
;;                        a-ev-if-part
;;                        a-ev-subr-part
;;                        a-ev-fun-part
;;                        a-get1
;;                        atom-ncode
;;                        form-z-if
;;                        proves-is-formula-again
;;                        ev
;;                        ev-list-reduc
;;                        ev-if-reduc
;;                        ev-fun-reduc)
;;               (use (form-z-if-ev-defn-part-again))))
;; (defthm a-ev-defn-part-good-proof-proves-fun-case

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (not (zerop (car exp)))
;;                            (not (equal (car exp) 10))
;;                            (not (subrp (car exp)))
;;                            (ev-hyps given defns symbols)
;;                            (var-set (list 11 12 15 16 val1 trace) 6)
;;                            (nil-intersect (list 11 12 val1) (collect-free dexp 0))
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (proves pf1
;;                                    (ind-form 1
;;                                              (cdr exp)
;;                                              va
;;                                              fa
;;                                              val1
;;                                              (ev 1 (cdr exp) va fa n)
;;                                              trace
;;                                              dexp)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (proves pf2
;;                                    (ind-form 0
;;                                              (get (sub1-n (car exp) 11) fa)
;;                                              (ev 1 (cdr exp) va fa n)
;;                                              fa
;;                                              val1
;;                                              (ev flg exp va fa n)
;;                                              trace
;;                                              dexp)
;;                                    given
;;                                    defns
;;                                    symbols)
;;                            (equal concl
;;                                   (f-implies (a-ev-defn-part flg exp va fa val1 trace)
;;                                              (f-implies dexp
;;                                                         (f-equal val1
;;                                                                  (ncode (ev flg exp va fa n)))))))
;;                       (proves (a-ev-defn-part-good-proof flg exp va fa n val1 trace dexp pf1 pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list
;;                        a-ev-list-part
;;                        a-ev-if-part
;;                        a-ev-subr-part
;;                        a-ev-fun-part
;;                        a-get1
;;                        atom-ncode
;;                        form-z-if
;;                        proves-is-formula-again
;;                        ev
;;                        ev-list-reduc
;;                        ev-if-reduc
;;                        ev-subr-reduc)
;;               (use (form-z-if-ev-defn-part-again))))
;; (defthm a-ev-defn-part-good-proof-proves-var-case

;;              (implies (and (not (equal flg 1))
;;                            (not (consp exp))
;;                            (ev-hyps given defns symbols)
;;                            (g-formula dexp symbols)
;;                            (var-set (list 11 12 15 16 val1 trace) 6)
;;                            (nil-intersect (list 11 12 val1) (collect-free dexp 0))
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (f-implies (a-ev-defn-part flg exp va fa val1 trace)
;;                                              (f-implies dexp
;;                                                         (f-equal val1
;;                                                                  (ncode (ev flg exp va fa n)))))))
;;                       (proves (a-ev-defn-part-good-proof flg exp va fa n val1 trace dexp pf1 pf2)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-list
;;                        a-ev-list-part
;;                        a-ev-if-part
;;                        a-ev-subr-part
;;                        a-ev-fun-part
;;                        atom-ncode
;;                        form-z-if
;;                        proves-is-formula-again
;;                        ev-fun-reduc
;;                        ev-list-reduc
;;                        ev-if-reduc
;;                        ev-subr-reduc)
;;               (use (form-z-if-ev-defn-part-again))))
;; (toggle g0930 a-ev-defn-part-good-proof t)
;; (defthm free-for-x-x (implies (g-variable x) (free-for exp x x flg)))
;; (toggle g0932 free-for t)
;; (toggle g0933 free-for-list nil)
;; (defun a-ev-reduc-proof
;;       (flg exp va fa val1 trace)
;;       (f-iff-mp-proof2 (f-implies (a-ev (ncode flg) (ncode exp) (ncode va) (ncode fa) val1 trace)
;;                                   (a-ev-defn-part flg exp va fa val1 trace))
;;                        (f-implies (list-all-quantify (list 6 7 8 9 10)
;;                                                      (f-implies (isin (z-list (list 10 6 7 8 9))
;;                                                                       trace)
;;                                                                 (a-ev-defn-part1 6
;;                                                                                  7
;;                                                                                  8
;;                                                                                  9
;;                                                                                  10
;;                                                                                  trace)))
;;                                   (f-implies (isin (z-list (list val1
;;                                                                  (ncode flg)
;;                                                                  (ncode exp)
;;                                                                  (ncode va)
;;                                                                  (ncode fa)))
;;                                                    trace)
;;                                              (a-ev-defn-part flg exp va fa val1 trace)))
;;                        (good-frame1-proof (isin (z-list (list val1
;;                                                               (ncode flg)
;;                                                               (ncode exp)
;;                                                               (ncode va)
;;                                                               (ncode fa)))
;;                                                 trace)
;;                                           (list-all-quantify (list 6 7 8 9 10)
;;                                                              (f-implies (isin (z-list (list 10
;;                                                                                             6
;;                                                                                             7
;;                                                                                             8
;;                                                                                             9))
;;                                                                               trace)
;;                                                                         (a-ev-defn-part1 6
;;                                                                                          7
;;                                                                                          8
;;                                                                                          9
;;                                                                                          10
;;                                                                                          trace)))
;;                                           (a-ev-defn-part flg exp va fa val1 trace))
;;                        (subst-thm-b-proof (f-implies (isin (z-list (list 10 6 7 8 9)) trace)
;;                                                      (a-ev-defn-part1 6 7 8 9 10 trace))
;;                                           (list 6 7 8 9 10)
;;                                           (list (ncode flg)
;;                                                 (ncode exp)
;;                                                 (ncode va)
;;                                                 (ncode fa)
;;                                                 val1))))
;; (defthm parallel-subst-a-ev-defn-part1-again

;;              (implies (and (g-variable trace)
;;                            (not (member trace (list 6 7 8 9 10))))
;;                       (equal (parallel-subst (a-ev-defn-part1 6 7 8 9 10 trace)
;;                                              (list 6 7 8 9 10)
;;                                              (list (ncode flg)
;;                                                    (ncode exp)
;;                                                    (ncode va)
;;                                                    (ncode fa)
;;                                                    val-bar)
;;                                              0)
;;                              (a-ev-defn-part flg exp va fa val-bar trace)))
;;              ((enable a-ev-defn-part1)))
;; (toggle g0935 a-ev-defn-part t)
;; (defthm free-for-list-reduc

;;              (equal (free-for-list exp vars terms)
;;                     (if (and (consp vars)
;;                              (consp terms))
;;                         (and (free-for exp (car vars) (car terms) 0)
;;                              (free-for-list exp (cdr vars) (cdr terms)))
;;                         t)))
;; (toggle g0940 free-for-list t)
;; (defun all-symbs
;;       (symbols)
;;       (subset (list (fn 16 1)
;;                     (fn 15 2)
;;                     (fn 14 2)
;;                     (fn 13 2)
;;                     (fn 12 2)
;;                     (fn 0 0)
;;                     (fn 3 1)
;;                     (fn 4 1)
;;                     (fn 5 1)
;;                     (fn 6 1)
;;                     (fn 7 1)
;;                     (fn 8 1)
;;                     (fn 9 1)
;;                     (fn 10 1)
;;                     (fn 11 2)
;;                     (fn 1 2)
;;                     (fn 2 2)
;;                     (p 2 1)
;;                     (p 1 2))
;;               symbols))
;; (defthm a-ev-reduc-proof-proves

;;              (implies (and (all-symbs symbols)
;;                            (g-variable trace)
;;                            (not (member trace (list 6 7 8 9 10)))
;;                            (equal concl
;;                                   (f-implies (a-ev (ncode flg)
;;                                                    (ncode exp)
;;                                                    (ncode va)
;;                                                    (ncode fa)
;;                                                    10
;;                                                    trace)
;;                                              (a-ev-defn-part flg exp va fa 10 trace))))
;;                       (proves (a-ev-reduc-proof flg exp va fa 10 trace)
;;                               concl
;;                               given
;;                               defns
;;                               symbols)))
;; (toggle g0947 a-ev-reduc-proof t)
;; (toggle g0949 a-ev-defn-part1 nil)
;; (defun a-ev-defn
;;       (trace )
;;       (list-all-quantify (list 6 7 8 9 10)
;;                          (f-implies (isin (z-list (list 10 6 7 8 9)) trace)
;;                                     (a-ev-defn-part1 6 7 8 9 10 trace))))
;; (defthm collect-free-z-sub1-n

;;              (equal (member var (collect-free (z-sub1-n exp n) 0))
;;                     (member var (collect-free exp 0))))
;; (defthm nil-int-a-ev-defn

;;              (implies (and (g-variable trace)
;;                            (not (member trace (list 11 12 10))))
;;                       (nil-intersect (list 11 12 10) (collect-free (a-ev-defun trace) 0))))
;; (defthm formula-a-ev-defn

;;              (implies (and (all-symbs symbols)
;;                            (g-variable trace))
;;                       (g-formula (a-ev-defun trace) symbols)))
;; (toggle g0950 a-ev-defn-part1 t)
;; (defthm a-ev-reduc

;;              (equal (a-ev flg-bar exp-bar va-bar fa-bar val1 trace)
;;                     (f-and (isin (z-list (list val1 flg-bar exp-bar va-bar fa-bar)) trace)
;;                            (a-ev-defun trace))))
;; (toggle g0951 a-ev-defun t)
;; (toggle g0952 a-ev t)
;; (defthm good-frame2-proof-proves-again

;;              (implies (and (proves pf1 (f-implies (f-and a b) c) given defns symbols)
;;                            (proves pf2 (f-implies c (f-implies b d)) given defns symbols))
;;                       (proves (good-frame2-proof a b c d pf1 pf2)
;;                               (f-implies (f-and a b) d)
;;                               given
;;                               defns
;;                               symbols))
;;              ((use (proves-is-formula (pf pf1) (exp (f-implies (f-and a b) c)))
;;                    (proves-is-formula (pf pf2) (exp (f-implies c (f-implies b d)))))
;;               ))
;; (toggle g0953 good-frame2-proof-proves t)
;; (defn
;;  a-ev-good-proof
;;  (flg exp va fa n trace)
;;  (if
;;   (equal flg 1)
;;   (if
;;    (consp exp)
;;    (good-frame2-proof
;;     (isin (z-list (list 10 (ncode flg) (ncode exp) (ncode va) (ncode fa))) trace)
;;     (a-ev-defun trace)
;;     (a-ev-defn-part flg exp va fa 10 trace)
;;     (f-equal 10 (ncode (ev flg exp va fa n)))
;;     (a-ev-reduc-proof flg exp va fa 10 trace)
;;     (a-ev-defn-part-good-proof flg
;;                                exp
;;                                va
;;                                fa
;;                                n
;;                                10
;;                                trace
;;                                (a-ev-defun trace)
;;                                (good-frame3-proof (isin (z-list (list 10
;;                                                                       (ncode 0)
;;                                                                       (ncode (car exp))
;;                                                                       (ncode va)
;;                                                                       (ncode fa)))
;;                                                         trace)
;;                                                   (a-ev-defun trace)
;;                                                   (f-equal 10 (ncode (ev 0 (car exp) va fa n)))
;;                                                   (a-ev-good-proof 0 (car exp) va fa n trace))
;;                                (good-frame3-proof (isin (z-list (list 10
;;                                                                       (ncode 1)
;;                                                                       (ncode (cdr exp))
;;                                                                       (ncode va)
;;                                                                       (ncode fa)))
;;                                                         trace)
;;                                                   (a-ev-defun trace)
;;                                                   (f-equal 10 (ncode (ev 1 (cdr exp) va fa n)))
;;                                                   (a-ev-good-proof 1 (cdr exp) va fa n trace))))
;;    (good-frame2-proof (isin (z-list (list 10 (ncode flg) (ncode exp) (ncode va) (ncode fa)))
;;                             trace)
;;                       (a-ev-defun trace)
;;                       (a-ev-defn-part flg exp va fa 10 trace)
;;                       (f-equal 10 (ncode (ev flg exp va fa n)))
;;                       (a-ev-reduc-proof flg exp va fa 10 trace)
;;                       (a-ev-defn-part-good-proof flg
;;                                                  exp
;;                                                  va
;;                                                  fa
;;                                                  n
;;                                                  10
;;                                                  trace
;;                                                  (a-ev-defun trace)
;;                                                  nil
;;                                                  nil)))
;;   (if
;;    (consp exp)
;;    (if
;;     (zerop (car exp))
;;     (good-frame2-proof
;;      (isin (z-list (list 10 (ncode flg) (ncode exp) (ncode va) (ncode fa))) trace)
;;      (a-ev-defun trace)
;;      (a-ev-defn-part flg exp va fa 10 trace)
;;      (f-equal 10 (ncode (ev flg exp va fa n)))
;;      (a-ev-reduc-proof flg exp va fa 10 trace)
;;      (a-ev-defn-part-good-proof flg
;;                                 exp
;;                                 va
;;                                 fa
;;                                 n
;;                                 10
;;                                 trace
;;                                 (a-ev-defun trace)
;;                                 (good-frame3-proof (isin (z-list (list 10
;;                                                                        (ncode 0)
;;                                                                        (ncode (cadr exp))
;;                                                                        (ncode va)
;;                                                                        (ncode fa)))
;;                                                          trace)
;;                                                    (a-ev-defun trace)
;;                                                    (f-equal 10 (ncode (ev 0 (cadr exp) va fa n)))
;;                                                    (a-ev-good-proof 0 (cadr exp) va fa n trace))
;;                                 (if (ncode-equal (ev 0 (cadr exp) va fa n) 0)
;;                                     (good-frame3-proof (isin (z-list (list 10
;;                                                                            (ncode 0)
;;                                                                            (ncode (cadddr exp))
;;                                                                            (ncode va)
;;                                                                            (ncode fa)))
;;                                                              trace)
;;                                                        (a-ev-defun trace)
;;                                                        (f-equal 10
;;                                                                 (ncode (ev 0
;;                                                                            (cadddr exp)
;;                                                                            va
;;                                                                            fa
;;                                                                            n)))
;;                                                        (a-ev-good-proof 0
;;                                                                         (cadddr exp)
;;                                                                         va
;;                                                                         fa
;;                                                                         n
;;                                                                         trace))
;;                                     (good-frame3-proof (isin (z-list (list 10
;;                                                                            (ncode 0)
;;                                                                            (ncode (caddr exp))
;;                                                                            (ncode va)
;;                                                                            (ncode fa)))
;;                                                              trace)
;;                                                        (a-ev-defun trace)
;;                                                        (f-equal 10
;;                                                                 (ncode (ev 0
;;                                                                            (caddr exp)
;;                                                                            va
;;                                                                            fa
;;                                                                            n)))
;;                                                        (a-ev-good-proof 0
;;                                                                         (caddr exp)
;;                                                                         va
;;                                                                         fa
;;                                                                         n
;;                                                                         trace)))))
;;     (if
;;      (equal (car exp) 10)
;;      (good-frame2-proof (isin (z-list (list 10 (ncode flg) (ncode exp) (ncode va) (ncode fa)))
;;                               trace)
;;                         (a-ev-defun trace)
;;                         (a-ev-defn-part flg exp va fa 10 trace)
;;                         (f-equal 10 (ncode (ev flg exp va fa n)))
;;                         (a-ev-reduc-proof flg exp va fa 10 trace)
;;                         (a-ev-defn-part-good-proof flg
;;                                                    exp
;;                                                    va
;;                                                    fa
;;                                                    n
;;                                                    10
;;                                                    trace
;;                                                    (a-ev-defun trace)
;;                                                    nil
;;                                                    nil))
;;      (if
;;       (subrp (car exp))
;;       (good-frame2-proof
;;        (isin (z-list (list 10 (ncode flg) (ncode exp) (ncode va) (ncode fa))) trace)
;;        (a-ev-defun trace)
;;        (a-ev-defn-part flg exp va fa 10 trace)
;;        (f-equal 10 (ncode (ev flg exp va fa n)))
;;        (a-ev-reduc-proof flg exp va fa 10 trace)
;;        (a-ev-defn-part-good-proof flg
;;                                   exp
;;                                   va
;;                                   fa
;;                                   n
;;                                   10
;;                                   trace
;;                                   (a-ev-defun trace)
;;                                   (good-frame3-proof (isin (z-list (list 10
;;                                                                          (ncode 1)
;;                                                                          (ncode (cdr exp))
;;                                                                          (ncode va)
;;                                                                          (ncode fa)))
;;                                                            trace)
;;                                                      (a-ev-defun trace)
;;                                                      (f-equal 10
;;                                                               (ncode (ev 1 (cdr exp) va fa n)))
;;                                                      (a-ev-good-proof 1
;;                                                                       (cdr exp)
;;                                                                       va
;;                                                                       fa
;;                                                                       n
;;                                                                       trace))
;;                                   nil))
;;       (if
;;        (zerop n)
;;        nil
;;        (good-frame2-proof
;;         (isin (z-list (list 10 (ncode flg) (ncode exp) (ncode va) (ncode fa))) trace)
;;         (a-ev-defun trace)
;;         (a-ev-defn-part flg exp va fa 10 trace)
;;         (f-equal 10 (ncode (ev flg exp va fa n)))
;;         (a-ev-reduc-proof flg exp va fa 10 trace)
;;         (a-ev-defn-part-good-proof
;;          flg
;;          exp
;;          va
;;          fa
;;          n
;;          10
;;          trace
;;          (a-ev-defun trace)
;;          (good-frame3-proof (isin (z-list (list 10
;;                                                 (ncode 1)
;;                                                 (ncode (cdr exp))
;;                                                 (ncode va)
;;                                                 (ncode fa)))
;;                                   trace)
;;                             (a-ev-defun trace)
;;                             (f-equal 10 (ncode (ev 1 (cdr exp) va fa n)))
;;                             (a-ev-good-proof 1 (cdr exp) va fa n trace))
;;          (good-frame3-proof (isin (z-list (list 10
;;                                                 (ncode 0)
;;                                                 (ncode (get (sub1-n (car exp) 11) fa))
;;                                                 (ncode (ev 1 (cdr exp) va fa n))
;;                                                 (ncode fa)))
;;                                   trace)
;;                             (a-ev-defun trace)
;;                             (f-equal 10
;;                                      (ncode (ev 0
;;                                                 (get (sub1-n (car exp) 11) fa)
;;                                                 (ev 1 (cdr exp) va fa n)
;;                                                 fa
;;                                                 (sub1 n))))
;;                             (a-ev-good-proof 0
;;                                              (get (sub1-n (car exp) 11) fa)
;;                                              (ev 1 (cdr exp) va fa n)
;;                                              fa
;;                                              (sub1 n)
;;                                              trace))))))))
;;    (good-frame2-proof (isin (z-list (list 10 (ncode flg) (ncode exp) (ncode va) (ncode fa)))
;;                             trace)
;;                       (a-ev-defun trace)
;;                       (a-ev-defn-part flg exp va fa 10 trace)
;;                       (f-equal 10 (ncode (ev flg exp va fa n)))
;;                       (a-ev-reduc-proof flg exp va fa 10 trace)
;;                       (a-ev-defn-part-good-proof flg
;;                                                  exp
;;                                                  va
;;                                                  fa
;;                                                  n
;;                                                  10
;;                                                  trace
;;                                                  (a-ev-defun trace)
;;                                                  nil
;;                                                  nil))))
;;  ((lex2 (list n (acl2-count exp)))))
;; ;; "a-ev" is `good', i.e.,
;; ;;  |- "(a-ev(<flg>, <exp>, <va>, <fa>, val, trace) -> (val = <(ev flg va fa n)>))".
;; (prove-lemma
;;  a-ev-good-proof-proves

;;  (implies (and (ev-hyps given defns symbols)
;;                (g-variable trace)
;;                (not (member trace (list 6 7 8 9 10 11 12 15 16)))
;;                (not (btmp (ev flg exp va fa n))))
;;           (proves (a-ev-good-proof flg exp va fa n trace)
;;                   (f-implies (a-ev (ncode flg) (ncode exp) (ncode va) (ncode fa) 10 trace)
;;                              (f-equal 10 (ncode (ev flg exp va fa n))))
;;                   given
;;                   defns
;;                   symbols))
;;  ((disable z-list ncode-equal nil-intersect proves-is-formula-again subset) (induct (ev flg
;;                                                                                         exp
;;                                                                                         va
;;                                                                                         fa
;;                                                                                         n))))
;; (toggle g0954 a-ev-good-proof t)
;; ;;
;; ;; this brings us to an entirely different section of the proof.  so far we have
;; ;; shown that a lisp interpreter is representable by a z2 formula.  in order to
;; ;; construct the undecidable sentence, we need to show that the metatheory of z2
;; ;; is representable in z2.  we do that by showing that the metatheoretic formalization
;; ;; of z2 is computable by means of the lisp interpreter ev.  since ev is only aware
;; ;; of data-structures which are lists or numbers (num-trees), we need to first
;; ;; represent the z2 expressions and proofs in these terms.  the function gcode
;; ;; translates the shell-constructors f-not, f-or, forsome, cons, and add1, into
;; ;; distinct num-trees.  if it is none of the above (nil, for instance), then gcode
;; ;; returns the num-tree (cons 5 0).
;; ;;
;; (defun gcode
;;       (x)
;;       (if (consp x)
;;           (cons 1 (cons (gcode (car x)) (gcode (cdr x))))
;;           (if (f-notp x)
;;               (cons 2 (cons (gcode (arg x)) 0))
;;               (if (f-orp x)
;;                   (cons 3 (cons (gcode (arg1 x)) (gcode (arg2 x))))
;;                   (if (forsomep x)
;;                       (cons 4 (cons (bind x) (gcode (g-body x))))
;;                       (if (acl2-numberp x) x (cons 5 0)))))))
;; ;; the lemma below establishes the connection between eql and gcode.
;; (defthm eql-gcode-equal (equal (g-eql x y) (equal (gcode x) (gcode y))))
;; ;; then we introduce functions which form e-expressions corresponding to e-function
;; ;; applications of the lisp primitives.  the prefix pr stands for `primitive'.
;; (defun pr-cons (x y) (list 7 x y))
;; (defun pr-car (x) (list 8 x))
;; (defun pr-cdr (x) (list 9 x))
;; (defun pr-equal (x y) (list 1 x y))
;; (defun pr-acl2-numberp (x) (list 2 x))
;; (defun pr-zerop (x) (list 3 x))
;; (defun pr-add1 (x) (list 4 x))
;; (defun pr-sub1 (x) (list 5 x))
;; (defun pr-consp (x) (list 6 x))
;; ;; the functions suffixed with `n' are the lisp analogues of the e-functions.
;; ;; cons is not the lisp analogue of pr-cons since pr-cons can return (btm),
;; ;; whereas cons cannot.  the function pr-consn returns (btm) if one of its
;; ;; arguments is (btm), and (cons x y) otherwise.  similarly, we have the
;; ;; lisp analogues for the other primitives.
;; (defun pr-consn
;;       (x y)
;;       (if (or (btmp x)
;;               (btmp y))
;;           (btm)
;;           (cons x y)))
;; (defun pr-carn (x) (if (btmp x) (btm) (car x)))
;; (defun pr-cdrn (x) (if (btmp x) (btm) (cdr x)))
;; (defun pr-equaln
;;       (x y)
;;       (if (or (btmp x)
;;               (btmp y))
;;           (btm)
;;           (bool-fix (ncode-equal x y))))
;; (defun pr-acl2-numberpn (x) (if (btmp x) (btm) (bool-fix (not (consp x)))))
;; (defun pr-zeropn (x) (if (btmp x) (btm) (bool-fix (zerop x))))
;; (defun pr-add1n (x) (if (btmp x) (btm) (add1 x)))
;; (defun pr-conspn (x) (if (btmp x) (btm) (bool-fix (consp x))))
;; (toggle g0955 subrp nil)
;; (toggle g0956 apply-subr nil)
;; (toggle g0957 apply-subr1 nil)
;; (toggle g0958 apply-subr2 nil)
;; ;; the relationship between pr-cons and pr-consn is established below.  the lemma
;; ;; asserts that the result of evaluating (pr-cons x y) with ev is (pr-consn x y),
;; ;; where x and y are the results of evaluating x and y, respectively.
;; (defthm pr-cons-eval

;;              (equal (ev 0 (pr-cons x y) va fa n) (pr-consn (ev 0 x va fa n) (ev 0 y va fa n))))
;; (defthm pr-car-eval (equal (ev 0 (pr-car x) va fa n) (pr-carn (ev 0 x va fa n))))
;; (defthm pr-cdr-eval (equal (ev 0 (pr-cdr x) va fa n) (pr-cdrn (ev 0 x va fa n))))
;; (defthm pr-equal-eval

;;              (equal (ev 0 (pr-equal x y) va fa n) (pr-equaln (ev 0 x va fa n) (ev 0 y va fa n))))
;; (defthm pr-acl2-numberp-eval

;;              (equal (ev 0 (pr-acl2-numberp x) va fa n) (pr-acl2-numberpn (ev 0 x va fa n))))
;; (defthm pr-zerop-eval

;;              (equal (ev 0 (pr-zerop x) va fa n) (pr-zeropn (ev 0 x va fa n))))
;; (defthm pr-add1-eval (equal (ev 0 (pr-add1 x) va fa n) (pr-add1n (ev 0 x va fa n))))
;; (defun pr-sub1n (x) (if (btmp x) (btm) (sub1 x)))
;; (defthm pr-sub1-eval (equal (ev 0 (pr-sub1 x) va fa n) (pr-sub1n (ev 0 x va fa n))))
;; (defthm pr-consp-eval

;;              (equal (ev 0 (pr-consp x) va fa n) (pr-conspn (ev 0 x va fa n))))
;; (toggle g0959 pr-cons t)
;; (toggle g0960 pr-car t)
;; (toggle g0961 pr-cdr t)
;; (toggle g0962 pr-equal t)
;; (toggle g0963 pr-zerop t)
;; (toggle g0964 pr-acl2-numberp t)
;; (toggle g0965 pr-add1 t)
;; (toggle g0966 pr-sub1 t)
;; (toggle g0967 pr-consp t)
;; ;; similarly we construct e-expressions for if-expressions and quote-expressions,
;; ;; and show how they are evaluated.
;; (defun pr-if (x y z) (list 0 x y z))
;; (defthm pr-if-eval

;;              (equal (ev 0 (pr-if x y z) va fa n)
;;                     (if (btmp (ev 0 x va fa n))
;;                         (btm)
;;                         (if (ncode-equal (ev 0 x va fa n) 0) (ev 0 z va fa n) (ev 0 y va fa n)))))
;; (toggle g0968 pr-if t)
;; (defun pr-quote (x) (list 10 x))
;; (defthm pr-quote-eval (equal (ev 0 (pr-quote x) va fa n) x))
;; ;; having dealt with the primitives, we now get into the defined notions.
;; ;; there are two kinds of definitions: explicit and recursive.  the explicit
;; ;; definitions will be treated as abbreviations and no efunction symbol will
;; ;; introduced on their behalf.  e-function symbols will be introduced for
;; ;; recursively defined e-functions.  we first develop the basic logical connectives
;; ;; and analogues for the gcoded versions of the shell-constructors/destructors/recognizers.
;; ;; g-cons constructs the e-expression for the gcode analogue of cons, i.e., (g-cons x y)
;; ;; evaluates to (gcode (cons x y)).  we will adopt the convention of representing the
;; ;; value of x by x.
;; (defun g-cons (x y) (pr-cons (pr-quote 1) (pr-cons x y)))
;; ;; the logical-and connective is defined below.  note that pr-and evaluates to 1 or 0.
;; (defun pr-and (x y) (pr-if x (pr-if y (pr-quote 1) (pr-quote 0)) (pr-quote 0)))
;; (defun pr-andn
;;       (x y)
;;       (if (btmp x) (btm) (if (ncode-equal x 0) 0 (if (btmp y) (btm) (if (ncode-equal y 0) 0 1)))))
;; (defthm pr-and-eval

;;              (equal (ev 0 (pr-and x y) va fa n) (pr-andn (ev 0 x va fa n) (ev 0 y va fa n))))
;; (toggle g0990 pr-and t)
;; (defthm pr-andn-reduc

;;              (equal (pr-andn (bool-fix x) (bool-fix y))
;;                     (bool-fix (and x y))))
;; ;; the logical-not connective.
;; (defun pr-not (x) (pr-if x (pr-quote 0) (pr-quote 1)))
;; (defun pr-notn (x) (if (btmp x) (btm) (if (ncode-equal x 0) 1 0)))
;; (defthm pr-not-eval (equal (ev 0 (pr-not x) va fa n) (pr-notn (ev 0 x va fa n))))
;; (toggle g0991 pr-quote t)
;; (toggle g0992 pr-not t)
;; (defthm pr-notn-reduc (equal (pr-notn (bool-fix x)) (bool-fix (not x))))
;; ;; the logical-or connective.
;; (defun pr-or (x y) (pr-if x (pr-quote 1) (pr-if y (pr-quote 1) (pr-quote 0))))
;; (defun pr-orn
;;       (x y)
;;       (if (btmp x) (btm) (if (ncode-equal x 0) (if (btmp y) (btm) (if (ncode-equal y 0) 0 1)) 1)))
;; (defthm pr-or-eval

;;              (equal (ev 0 (pr-or x y) va fa n) (pr-orn (ev 0 x va fa n) (ev 0 y va fa n))))
;; (toggle g0993 pr-or t)
;; (defthm pr-orn-reduc

;;              (equal (pr-orn (bool-fix x) (bool-fix y))
;;                     (bool-fix (or x y))))
;; ;; the next e-definition is an important one.  given (gcode x), we can recover
;; ;; the type of x by looking at (car x).  if it is 1, x is a list; if it is 2,
;; ;; x is of the form (f-not y); if it is 3, x is of the form (f-or y z); if it is
;; ;; 4, x is of the form (forsome y z); otherwise it could either be a natural number
;; ;; for which we already have a acl2-numberp primitive, or any remaining type which is
;; ;; coerced to nil.  g-typep checks if x is of type type.  note that type is going
;; ;; to be a number, not an e-expression, since it appears withing pr-quote in g-typep.
;; (defun g-typep (x type) (pr-equal (pr-car x) (pr-quote type)))
;; (defun g-typepn (x type) (pr-equaln (pr-carn x) type))
;; (defthm g-typep-eval

;;              (equal (ev 0 (g-typep x type) va fa n) (g-typepn (ev 0 x va fa n) type)))
;; (toggle g0995 g-typep t)
;; ;; pr-ifn is the lisp analogue of pr-if.
;; (defun pr-ifn (x y z) (if (btmp x) (btm) (if (ncode-equal x 0) z y)))
;; ;; pr-car-cdr is the iterated car/cdr e-expression.
;; (defun pr-car-cdr
;;       (x list)
;;       (if (consp list)
;;           (if (equal (car list) 1)
;;               (pr-car (pr-car-cdr x (cdr list)))
;;               (pr-cdr (pr-car-cdr x (cdr list))))
;;           x))
;; ;; the destructors for gcoded objects are derived from g-arg below.
;; ;; let us represent (gcode x) as \x\.
;; ;; g-arg selects a field from \x\ according to its type type and the
;; ;; desired field argnum.  e.g., (g-arg y (pr-quote 1) 1) evaluates to
;; ;; \(car x)\, if y evaluates to \x\.
;; (defun g-arg
;;       (x argnum type)
;;       (pr-if (g-typep x type)
;;              (pr-if argnum (pr-car-cdr x (list 2 2)) (pr-car-cdr x (list 1 2)))
;;              (pr-quote 0)))
;; (toggle g0997 g-typepn t)
;; (toggle g0998 pr-carn t)
;; (toggle g0999 pr-cdrn t)
;; (defun g-argn
;;       (x argnum type)
;;       (pr-ifn (g-typepn x type) (pr-ifn argnum (pr-cdrn (pr-cdrn x)) (pr-carn (pr-cdrn x))) 0))
;; (defthm g-arg-eval

;;              (equal (ev 0 (g-arg x argnum type) va fa n)
;;                     (g-argn (ev 0 x va fa n) (ev 0 argnum va fa n) type)))
;; (toggle g1000 g-arg t)
;; (toggle g1001 g-typepn nil)
;; (toggle g1003 pr-carn nil)
;; (defthm pr-carn-gcode (equal (pr-carn (gcode x)) (car (gcode x))))
;; (toggle g1004 pr-cdrn nil)
;; (defthm pr-cdrn-gcode (equal (pr-cdrn (gcode x)) (cdr (gcode x))))
;; ;; g-typepn on lists, negations, disjunctions, and existential quantifications.
;; (defthm g-typepn-gcode-list (equal (g-typepn (gcode x) 1) (bool-fix (consp x))))
;; (defthm g-typepn-gcode-f-notp (equal (g-typepn (gcode x) 2) (bool-fix (f-notp x))))
;; (defthm g-typepn-gcode-f-orp (equal (g-typepn (gcode x) 3) (bool-fix (f-orp x))))
;; (defthm g-typepn-gcode-forsomep

;;              (equal (g-typepn (gcode x) 4) (bool-fix (forsomep x))))
;; (defthm car-gcode (equal (g-argn (gcode x) 0 1) (gcode (car x))))
;; (defthm cdr-gcode (equal (g-argn (gcode x) 1 1) (gcode (cdr x))))
;; (defthm arg-gcode (equal (g-argn (gcode x) 0 2) (gcode (arg x))))
;; (defthm arg1-gcode (equal (g-argn (gcode x) 0 3) (gcode (arg1 x))))
;; (defthm arg2-gcode (equal (g-argn (gcode x) 1 3) (gcode (arg2 x))))
;; (defthm bind-gcode (equal (g-argn (gcode x) 0 4) (gcode (bind x))))
;; (defthm body-gcode (equal (g-argn (gcode x) 1 4) (gcode (g-body x))))
;; ;; from g-arg, we derive the selectors (destructors) for the gcoded objects.
;; (defun g-car (x) (g-arg x (pr-quote 0) 1))
;; (defun g-cdr (x) (g-arg x (pr-quote 1) 1))
;; (defun g-carn (x) (g-argn x 0 1))
;; ;; g-function is the ev analogue of the metatheoretic function function.
;; (defun g-function (fn) (pr-equal (g-car fn) (pr-quote 2)))
;; (defun g-functionn (fn) (pr-equaln (g-carn fn) 2))
;; (defthm eval-g-function

;;              (equal (ev 0 (g-function fn) va fa n) (g-functionn (ev 0 fn va fa n))))
;; (toggle g0969 function nil)
;; (defthm g-functionn-gcode (equal (g-functionn (gcode fn)) (bool-fix (g-function fn))))
;; (toggle g0970 function t)
;; (toggle g0971 g-function t)
;; (toggle g0972 g-functionn t)
;; ;; g-variable is the ev analogue of variable.
;; (defun g-variable (x) (pr-acl2-numberp x))
;; (defun g-variablen (x) (pr-acl2-numberpn x))
;; (defthm eval-g-variable

;;              (equal (ev 0 (g-variable x) va fa n) (g-variablen (ev 0 x va fa n))))
;; (defthm g-variablen-gcode (equal (g-variablen (gcode x)) (bool-fix (g-variable x))))
;; (toggle g0973 g-variable t)
;; (toggle g0976 g-variablen t)
;; (toggle g0977 pr-consn t)
;; (defun g-consn (x y) (pr-consn 1 (pr-consn x y)))
;; (defthm g-cons-eval

;;              (equal (ev 0 (g-cons x y) va fa n) (g-consn (ev 0 x va fa n) (ev 0 y va fa n))))
;; (toggle g0978 pr-consn nil)
;; (defthm g-consn-gcode (equal (g-consn (gcode x) (gcode y)) (gcode (cons x y))))
;; (toggle g0979 pr-consn t)
;; (toggle g0980 g-consn t)
;; (toggle g0981 g-cons t)
;; ;; g-fix is the ev analogue of fix.
;; (defun g-fix (x) (pr-if (pr-acl2-numberp x) x (pr-quote 0)))
;; (defun g-fixn (x) (pr-ifn (pr-acl2-numberpn x) x 0))
;; (defthm eval-g-fix (equal (ev 0 (g-fix x) va fa n) (g-fixn (ev 0 x va fa n))))
;; (defthm g-fix-gcode (equal (g-fixn (gcode x)) (gcode (fix x))))
;; (toggle g0982 g-fix t)
;; (toggle g0983 g-fixn t)
;; (defun g-f-not (x) (pr-cons (pr-quote 2) (pr-cons x (pr-quote 0))))
;; (defun g-f-notn (x) (pr-consn 2 (pr-consn x 0)))
;; (defthm eval-g-f-not (equal (ev 0 (g-f-not x) va fa n) (g-f-notn (ev 0 x va fa n))))
;; (toggle g0984 pr-consn nil)
;; (defthm g-f-notn-gcode (equal (g-f-notn (gcode x)) (gcode (f-not x))))
;; (toggle g0985 g-f-not t)
;; (toggle g0986 g-f-notn t)
;; (defun g-f-or (x y) (pr-cons (pr-quote 3) (pr-cons x y)))
;; (defun g-f-orn (x y) (pr-consn 3 (pr-consn x y)))
;; (defthm eval-g-f-or

;;              (equal (ev 0 (g-f-or x y) va fa n) (g-f-orn (ev 0 x va fa n) (ev 0 y va fa n))))
;; (defthm g-f-orn-gcode (equal (g-f-orn (gcode x) (gcode y)) (gcode (f-or x y))))
;; (toggle g0987 g-f-or t)
;; (toggle g0988 g-f-orn t)
;; (defun g-forsome (x y) (pr-cons (pr-quote 4) (pr-cons (g-fix x) y)))
;; (defun g-forsomen (x y) (pr-consn 4 (pr-consn (g-fixn x) y)))
;; (defthm eval-g-forsome

;;              (equal (ev 0 (g-forsome x y) va fa n) (g-forsomen (ev 0 x va fa n) (ev 0 y va fa n))))
;; (defthm g-forsomen-gcode

;;              (equal (g-forsomen (gcode x) (gcode y)) (gcode (forsome x y))))
;; (toggle g0989 g-forsome t)
;; (toggle g0994 g-forsomen t)
;; ;; g-predicate is the ev analogue of predicate.  in general g-foo is the
;; ;; ev analogue of foo.
;; (defun g-predicate (x) (pr-equal (g-car x) (pr-quote 3)))
;; (defun g-predicaten (x) (pr-equaln (g-carn x) 3))
;; (defthm eval-g-predicate

;;              (equal (ev 0 (g-predicate x) va fa n) (g-predicaten (ev 0 x va fa n))))
;; (toggle g0996 predicate nil)
;; (defthm g-predicaten-gcode

;;              (equal (g-predicaten (gcode x)) (bool-fix (predicate x))))
;; (toggle g1002 predicate t)
;; (toggle g1005 g-predicate t)
;; (toggle g1006 g-predicaten t)
;; (defun g-func-pred (x) (pr-or (g-function x) (g-predicate x)))
;; (defun g-func-predn (x) (pr-orn (g-functionn x) (g-predicaten x)))
;; (defthm eval-g-func-pred

;;              (equal (ev 0 (g-func-pred x) va fa n) (g-func-predn (ev 0 x va fa n))))
;; (defthm g-func-predn-gcode

;;              (equal (g-func-predn (gcode x)) (bool-fix (func-pred x))))
;; (toggle g1007 g-func-pred t)
;; (toggle g1008 g-func-predn t)
;; ;; now we start defining the ev analogues of the recursive metatheoretic functions.
;; ;; these will all be defined first, and then shown to correspond to their
;; ;; boyer-moore counterparts.
;; (defun g-append (x y) (list 11 x y))
;; (defun g-cdrn (x) (g-argn x 1 1))
;; (toggle g1009 g-argn t)
;; (toggle g1010 g-typepn t)
;; (defthm eval-pr-if-again

;;              (equal (ev 0 (pr-if x y z) va fa n)
;;                     (pr-ifn (ev 0 x va fa n) (ev 0 y va fa n) (ev 0 z va fa n))))
;; (defthm pr-ifn-gcode (equal (pr-ifn (bool-fix x) y z) (if x y z)))
;; (toggle g1011 pr-ifn t)
;; (defthm eval-var (implies (acl2-numberp x) (equal (ev 0 x va fa n) (get x va))))
;; (defthm eval-fun-zero

;;              (implies (and (< 10 fn)
;;                            (zerop n))
;;                       (equal (ev 0 (cons fn args) va fa n) (btm))))
;; (defthm eval-fun1

;;              (implies (and (not (equal flg 1))
;;                            (consp exp)
;;                            (< 10 (car exp)))
;;                       (equal (ev flg exp va fa n)
;;                              (if (btmp (ev 1 (cdr exp) va fa n))
;;                                  (btm)
;;                                  (if (zerop n)
;;                                      (btm)
;;                                      (ev 0
;;                                          (get (sub1-n (car exp) 11) fa)
;;                                          (ev 1 (cdr exp) va fa n)
;;                                          fa
;;                                          (sub1 n)))))))
;; (defthm eval-fun2

;;              (implies (< 10 fn)
;;                       (equal (ev 0 (cons fn args) va fa n)
;;                              (if (btmp (ev 1 args va fa n))
;;                                  (btm)
;;                                  (if (zerop n)
;;                                      (btm)
;;                                      (ev 0
;;                                          (get (sub1-n fn 11) fa)
;;                                          (ev 1 args va fa n)
;;                                          fa
;;                                          (sub1 n)))))))
;; (defthm ev-list1

;;              (equal (ev 1 (cons x y) va fa n)
;;                     (if (or (btmp (ev 0 x va fa n))
;;                             (btmp (ev 1 y va fa n)))
;;                         (btm)
;;                         (cons (ev 0 x va fa n) (ev 1 y va fa n)))))
;; (defthm ev-list2 (equal (ev 1 nil va fa n) nil))
;; (toggle g1012 ev t)
;; (toggle g1013 sub1 nil)
;; (toggle g1014 get nil)
;; (toggle g1015 g-typepn t)
;; (toggle g1016 eval-fun1 t)
;; (defthm eval-fun3

;;              (implies (and (< 10 fn)
;;                            (not (zerop n)))
;;                       (equal (ev 0 (cons fn args) va fa n)
;;                              (if (btmp (ev 1 args va fa n))
;;                                  (btm)
;;                                  (ev 0 (get (sub1-n fn 11) fa) (ev 1 args va fa n) fa (sub1 n))))))
;; ;; the e-definition of g-append.
;; (defun g-append-defun nil (pr-if (g-typep 0 1) (g-cons (g-car 0) (g-append (g-cdr 0) 1)) 1))
;; (toggle g1017 g-append t)
;; ;; the e-definition of g-del.
;; (defun g-del (x y) (list 12 x y))
;; (defun g-del-defn
;;       nil
;;       (pr-if (g-typep 1 1)
;;              (pr-if (pr-equal 0 (g-car 1))
;;                     (g-del 0 (g-cdr 1))
;;                     (g-cons (g-car 1) (g-del 0 (g-cdr 1))))
;;              1))
;; (toggle g1018 g-del t)
;; ;; the e-definition of g-memb.
;; (defun g-memb (x y) (list 13 x y))
;; (defun g-memb-defn
;;       nil
;;       (pr-if (g-typep 1 1)
;;              (pr-if (pr-equal 0 (g-car 1)) (pr-quote 1) (g-memb 0 (g-cdr 1)))
;;              (pr-quote 0)))
;; (toggle g1019 g-memb t)
;; ;; the e-definition of g-collect-free.
;; (defun g-collect-free (exp flg) (list 14 exp flg))
;; (defun g-collect-free-defn
;;       nil
;;       (pr-if (pr-zerop 1)
;;              (pr-if (g-variable 0)
;;                     (g-cons 0 (pr-quote (gcode nil)))
;;                     (pr-if (g-typep 0 2)
;;                            (g-collect-free (g-arg 0 (pr-quote 0) 2) (pr-quote 0))
;;                            (pr-if (g-typep 0 3)
;;                                   (g-append (g-collect-free (g-arg 0 (pr-quote 0) 3)
;;                                                             (pr-quote 0))
;;                                             (g-collect-free (g-arg 0 (pr-quote 1) 3)
;;                                                             (pr-quote 0)))
;;                                   (pr-if (g-typep 0 4)
;;                                          (g-del (g-arg 0 (pr-quote 0) 4)
;;                                                 (g-collect-free (g-arg 0 (pr-quote 1) 4)
;;                                                                 (pr-quote 0)))
;;                                          (pr-if (g-typep 0 1)
;;                                                 (g-collect-free (g-cdr 0) (pr-quote 1))
;;                                                 (pr-quote (gcode nil)))))))
;;              (pr-if (g-typep 0 1)
;;                     (g-append (g-collect-free (g-car 0) (pr-quote 0))
;;                               (g-collect-free (g-cdr 0) (pr-quote 1)))
;;                     (pr-quote (gcode nil)))))
;; (toggle g1020 g-collect-free t)
;; ;; the e-definition of g-covering.
;; (defun g-covering (exp var flg) (list 15 exp var flg))
;; (defun g-covering-defn
;;       nil
;;       (pr-if (pr-zerop 2)
;;              (pr-if (g-typep 0 2)
;;                     (g-covering (g-arg 0 (pr-quote 0) 2) 1 (pr-quote 0))
;;                     (pr-if (g-typep 0 3)
;;                            (g-append (g-covering (g-arg 0 (pr-quote 0) 3) 1 (pr-quote 0))
;;                                      (g-covering (g-arg 0 (pr-quote 1) 3) 1 (pr-quote 0)))
;;                            (pr-if (g-typep 0 4)
;;                                   (pr-if (g-memb 1 (g-collect-free 0 (pr-quote 0)))
;;                                          (g-cons (g-arg 0 (pr-quote 0) 4)
;;                                                  (g-covering (g-arg 0 (pr-quote 1) 4)
;;                                                              1
;;                                                              (pr-quote 0)))
;;                                          (pr-quote (gcode nil)))
;;                                   (pr-if (g-typep 0 1)
;;                                          (g-covering (g-cdr 0) 1 (pr-quote 1))
;;                                          (pr-quote (gcode nil))))))
;;              (pr-if (g-typep 0 1)
;;                     (g-append (g-covering (g-car 0) 1 (pr-quote 0))
;;                               (g-covering (g-cdr 0) 1 (pr-quote 1)))
;;                     (pr-quote (gcode nil)))))
;; (toggle g1021 g-covering t)
;; ;; the e-definition of g-nil-intersect.
;; (defun g-nil-intersect (x y) (list 16 x y))
;; (toggle g1022 bool-fix t)
;; (defun g-nil-intersect-defn
;;       nil
;;       (pr-if (g-typep 0 1)
;;              (pr-and (pr-not (g-memb (g-car 0) 1)) (g-nil-intersect (g-cdr 0) 1))
;;              (pr-quote (bool-fix t))))
;; (toggle g1023 g-nil-intersect t)
;; ;; the e-definition of g-var-list.
;; (defun g-var-list (list len) (list 17 list len))
;; (defthm pr-sub1n-gcode (equal (pr-sub1n (gcode x)) (gcode (sub1 x))))
;; (toggle g1024 pr-sub1n t)
;; (defun g-var-list-defn
;;       nil
;;       (pr-if (pr-or (pr-zerop 1) (pr-not (g-typep 0 1)))
;;              (pr-and (pr-zerop 1) (pr-not (g-typep 0 1)))
;;              (pr-and (g-variable (g-car 0)) (g-var-list (g-cdr 0) (pr-sub1 1)))))
;; (toggle g1025 g-var-list t)
;; ;; the e-definition of g-termp.
;; (defun g-termp (exp flg symbols) (list 19 exp flg symbols))
;; (toggle g1026 pr-equaln t)
;; (defun g-symb
;;       (x symbols)
;;       (pr-or (pr-equal x
;;                        (g-cons (pr-quote (gcode 3))
;;                                (g-cons (pr-quote (gcode 0)) (pr-quote (gcode 2)))))
;;              (g-memb x symbols)))
;; (toggle g1027 g-symb t)
;; (defun g-length (x) (list 18 x))
;; (defun g-length-defun nil (pr-if (g-typep 0 1) (pr-add1 (g-length (g-cdr 0))) (pr-quote (gcode 0))))
;; (defun g-termp-defn
;;       nil
;;       (pr-if (pr-zerop 1)
;;              (pr-if (g-typep 0 1)
;;                     (pr-and (g-function (g-car 0))
;;                             (pr-and (g-symb (g-car 0) 2)
;;                                     (pr-and (g-termp (g-cdr 0) (pr-quote 1) 2)
;;                                             (pr-equal (g-length (g-cdr 0))
;;                                                       (g-fix (g-cdr (g-cdr (g-car 0))))))))
;;                     (g-variable 0))
;;              (pr-if (g-typep 0 1)
;;                     (pr-and (g-termp (g-car 0) (pr-quote 0) 2)
;;                             (g-termp (g-cdr 0) (pr-quote 1) 2))
;;                     (pr-quote (bool-fix t)))))
;; ;; the e-definition of g-subst.
;; (defun g-subst (exp var term flg) (list 20 exp var term flg))
;; (defun g-subst-defn
;;       nil
;;       (pr-if (pr-zerop 3)
;;              (pr-if (g-variable 0)
;;                     (pr-if (pr-equal 0 1) 2 0)
;;                     (pr-if (g-typep 0 2)
;;                            (g-f-not (g-subst (g-arg 0 (pr-quote 0) 2) 1 2 (pr-quote (gcode 0))))
;;                            (pr-if (g-typep 0 3)
;;                                   (g-f-or (g-subst (g-arg 0 (pr-quote 0) 3)
;;                                                    1
;;                                                    2
;;                                                    (pr-quote (gcode 0)))
;;                                           (g-subst (g-arg 0 (pr-quote 1) 3)
;;                                                    1
;;                                                    2
;;                                                    (pr-quote (gcode 0))))
;;                                   (pr-if (g-typep 0 4)
;;                                          (pr-if (pr-equal (g-arg 0 (pr-quote 0) 4) 1)
;;                                                 0
;;                                                 (g-forsome (g-arg 0 (pr-quote 0) 4)
;;                                                            (g-subst (g-arg 0 (pr-quote 1) 4)
;;                                                                     1
;;                                                                     2
;;                                                                     (pr-quote (gcode 0)))))
;;                                          (pr-if (g-typep 0 1)
;;                                                 (g-cons (g-car 0)
;;                                                         (g-subst (g-cdr 0)
;;                                                                  1
;;                                                                  2
;;                                                                  (pr-quote (gcode 1))))
;;                                                 0)))))
;;              (pr-if (g-typep 0 1)
;;                     (g-cons (g-subst (g-car 0) 1 2 (pr-quote (gcode 0)))
;;                             (g-subst (g-cdr 0) 1 2 (pr-quote (gcode 1))))
;;                     0)))
;; (defun g-sub (x y) (list 21 x y))
;; (defun g-sub-defn
;;       nil
;;       (pr-if (g-typep 0 1)
;;              (pr-and (g-memb (g-car 0) 1) (g-sub (g-cdr 0) 1))
;;              (pr-quote (bool-fix t))))
;; ;; the e-definition of g-formula.
;; (defun g-formula (exp symbols) (list 22 exp symbols))
;; (defun g-atomp
;;       (exp symbols)
;;       (pr-and (g-predicate (g-car exp))
;;               (pr-and (g-symb (g-car exp) symbols)
;;                       (pr-and (pr-equal (g-length (g-cdr exp))
;;                                         (g-fix (g-cdr (g-cdr (g-car exp)))))
;;                               (g-termp (g-cdr exp) (pr-quote 1) symbols)))))
;; (toggle g1028 g-atomp t)
;; (defun g-formula-defn
;;       nil
;;       (pr-if (g-typep 0 2)
;;              (g-formula (g-arg 0 (pr-quote 0) 2) 1)
;;              (pr-if (g-typep 0 3)
;;                     (pr-and (g-formula (g-arg 0 (pr-quote 0) 3) 1)
;;                             (g-formula (g-arg 0 (pr-quote 1) 3) 1))
;;                     (pr-if (g-typep 0 4) (g-formula (g-arg 0 (pr-quote 1) 4) 1) (g-atomp 0 1)))))
;; (defun g-pairequals (vars1 vars2 exp) (list 23 vars1 vars2 exp))
;; (defun g-f-and (x y) (g-f-not (g-f-or (g-f-not x) (g-f-not y))))
;; (defun g-f-andn (x y) (g-f-notn (g-f-orn (g-f-notn x) (g-f-notn y))))
;; (defthm g-f-and-eval

;;              (equal (ev 0 (g-f-and x y) va fa n) (g-f-andn (ev 0 x va fa n) (ev 0 y va fa n))))
;; (toggle g1098 f-and nil)
;; (defthm g-f-andn-gcode

;;              (equal (g-f-andn (gcode x) (gcode y)) (gcode (f-and x y)))
;;              ((disable gcode)))
;; (toggle g1099 f-and t)
;; (toggle g1100 g-f-and t)
;; (toggle g1101 g-f-andn t)
;; (defun g-f-implies (x y) (g-f-or (g-f-not x) y))
;; (defun g-f-impliesn (x y) (g-f-orn (g-f-notn x) y))
;; (defthm g-f-implies-eval

;;              (equal (ev 0 (g-f-implies x y) va fa n)
;;                     (g-f-impliesn (ev 0 x va fa n) (ev 0 y va fa n))))
;; (toggle g1102 f-implies nil)
;; (defthm g-f-impliesn-gcode

;;              (equal (g-f-impliesn (gcode x) (gcode y)) (gcode (f-implies x y))))
;; (toggle g1103 f-implies t)
;; (toggle g1104 g-f-implies t)
;; (toggle g1105 g-f-impliesn t)
;; (defun g-forall (var exp) (g-f-not (g-forsome var (g-f-not exp))))
;; (defun g-foralln (var exp) (g-f-notn (g-forsomen var (g-f-notn exp))))
;; (defthm g-forall-eval

;;              (equal (ev 0 (g-forall x y) va fa n) (g-foralln (ev 0 x va fa n) (ev 0 y va fa n))))
;; (toggle g1106 forall nil)
;; (defthm g-foralln-gcode

;;              (equal (g-foralln (gcode x) (gcode y)) (gcode (forall x y))))
;; (toggle g1107 forall t)
;; (toggle g1108 g-forall t)
;; (toggle g1109 g-foralln t)
;; (defun g-f-equal
;;       (x y)
;;       (g-cons (g-cons (pr-quote (gcode 3)) (g-cons (pr-quote (gcode 0)) (pr-quote (gcode 2))))
;;               (g-cons x (g-cons y (pr-quote (gcode nil))))))
;; (defun g-f-equaln
;;       (x y)
;;       (g-consn (g-consn (gcode 3) (g-consn (gcode 0) (gcode 2)))
;;                (g-consn x (g-consn y (gcode nil)))))
;; (defthm g-f-equal-eval

;;              (equal (ev 0 (g-f-equal x y) va fa n) (g-f-equaln (ev 0 x va fa n) (ev 0 y va fa n)))
;;              ((disable gcode)))
;; (toggle g1049 p nil)
;; (toggle g1050 f-equal nil)
;; (defthm g-f-equaln-gcode

;;              (equal (g-f-equaln (gcode x) (gcode y)) (gcode (f-equal x y)))
;;              ((disable gcode)))
;; (toggle g1051 p t)
;; (toggle g1052 f-equal t)
;; (toggle g1053 g-f-equal t)
;; (toggle g1054 g-f-equaln t)
;; ;; the e-definition of g-pairequals.
;; (defun g-pairequals-defn
;;       nil
;;       (pr-if (pr-and (g-typep 0 1) (g-typep 1 1))
;;              (g-f-implies (g-f-equal (g-car 0) (g-car 1)) (g-pairequals (g-cdr 0) (g-cdr 1) 2))
;;              2))
;; ;; the e-definition of g-set.
;; (defun g-set (x) (list 24 x))
;; (defun g-set-defn
;;       nil
;;       (pr-if (g-typep 0 1)
;;              (pr-and (pr-not (g-memb (g-car 0) (g-cdr 0))) (g-set (g-cdr 0)))
;;              (pr-quote (bool-fix t))))
;; (defun g-conc (pf flg) (list 25 pf flg))
;; (defun g-cadr (x) (g-car (g-cdr x)))
;; (defun g-caddr (x) (g-car (g-cdr (g-cdr x))))
;; (defun g-cadddr (x) (g-car (g-cdr (g-cdr (g-cdr x)))))
;; ;; the e-definition of g-conc.
;; (defun g-conc-defn
;;       nil
;;       (pr-if (pr-zerop 1)
;;              (g-caddr 0)
;;              (pr-if (g-typep 0 1)
;;                     (g-cons (g-conc (g-car 0) (pr-quote 0)) (g-conc (g-cdr 0) (pr-quote 1)))
;;                     (pr-quote (gcode nil)))))
;; ;; the e-definition of g-rest-of.
;; (defun g-rest-of (sym symbols) (list 26 sym symbols))
;; (defun g-rest-of-defn
;;       nil
;;       (pr-if (g-typep 1 1)
;;              (pr-if (pr-and (pr-equal (g-car 1) 0) (pr-not (g-memb 0 (g-cdr 1))))
;;                     (g-cdr 1)
;;                     (g-rest-of 0 (g-cdr 1)))
;;              (pr-quote (gcode nil))))
;; ;; the e-definition of g-assoc.
;; (defun g-assoc (x y) (list 27 x y))
;; (defun g-assoc-defn
;;       nil
;;       (pr-if (g-typep 1 1)
;;              (pr-if (pr-equal (g-car (g-car 1)) 0) (g-cdr (g-car 1)) (g-assoc 0 (g-cdr 1)))
;;              (pr-quote 0)))
;; (defun g-prf (pf given defns flg symbols) (list 28 pf given defns flg symbols))
;; (defun g-free-for
;;       (exp var term flg)
;;       (g-nil-intersect (g-covering exp var flg) (g-collect-free term (pr-quote 0))))
;; (toggle g1029 g-free-for t)
;; ;; the ev analogues of the fol axiom-checkers.
;; (defun g-subst-axiom-proof
;;       (conc hints symbols)
;;       (pr-and (g-formula (g-cadr hints) symbols)
;;               (pr-and (g-variable (g-caddr hints))
;;                       (pr-and (g-termp (g-cadddr hints) (pr-quote 0) symbols)
;;                               (pr-and (g-free-for (g-cadr hints)
;;                                                   (g-caddr hints)
;;                                                   (g-cadddr hints)
;;                                                   (pr-quote 0))
;;                                       (pr-equal conc
;;                                                 (g-f-implies (g-subst (g-cadr hints)
;;                                                                       (g-caddr hints)
;;                                                                       (g-cadddr hints)
;;                                                                       (pr-quote 0))
;;                                                              (g-forsome (g-caddr hints)
;;                                                                         (g-cadr hints)))))))))
;; (defun g-degree (x) (g-fix (g-cdr (g-cdr x))))
;; (defn
;;  g-fun-equal-axiom-proof
;;  (conc hints symbols)
;;  (pr-and
;;   (g-termp (g-caddr hints) (pr-quote 1) symbols)
;;   (pr-and
;;    (g-termp (g-cadddr hints) (pr-quote 1) symbols)
;;    (pr-and (g-function (g-cadr hints))
;;            (pr-and (pr-equal (g-length (g-caddr hints)) (g-degree (g-cadr hints)))
;;                    (pr-and (pr-equal (g-length (g-cadddr hints)) (g-degree (g-cadr hints)))
;;                            (pr-equal conc
;;                                      (g-pairequals (g-caddr hints)
;;                                                    (g-cadddr hints)
;;                                                    (g-f-equal (g-cons (g-cadr hints)
;;                                                                       (g-caddr hints))
;;                                                               (g-cons (g-cadr hints)
;;                                                                       (g-cadddr hints)))))))))))
;; (defn
;;  g-pred-equal-axiom-proof
;;  (conc hints symbols)
;;  (pr-and
;;   (g-termp (g-caddr hints) (pr-quote 1) symbols)
;;   (pr-and
;;    (g-termp (g-cadddr hints) (pr-quote 1) symbols)
;;    (pr-and (g-predicate (g-cadr hints))
;;            (pr-and (pr-equal (g-length (g-caddr hints)) (g-degree (g-cadr hints)))
;;                    (pr-and (pr-equal (g-length (g-cadddr hints)) (g-degree (g-cadr hints)))
;;                            (pr-equal conc
;;                                      (g-pairequals (g-caddr hints)
;;                                                    (g-cadddr hints)
;;                                                    (g-f-implies (g-cons (g-cadr hints)
;;                                                                         (g-caddr hints))
;;                                                                 (g-cons (g-cadr hints)
;;                                                                         (g-cadddr hints)))))))))))
;; ;; the ev analogue of fol-axiom-proof.
;; (defun g-fol-axiom-proof
;;       (conc hints symbols)
;;       (pr-if (pr-equal (g-car hints) (pr-quote 1))
;;              (pr-and (g-formula (g-cadr hints) symbols)
;;                      (pr-equal conc (g-f-or (g-f-not (g-cadr hints)) (g-cadr hints))))
;;              (pr-if (pr-equal (g-car hints) (pr-quote 2))
;;                     (g-subst-axiom-proof conc hints symbols)
;;                     (pr-if (pr-equal (g-car hints) (pr-quote 3))
;;                            (pr-and (g-termp (g-cadr hints) (pr-quote 0) symbols)
;;                                    (pr-equal conc (g-f-equal (g-cadr hints) (g-cadr hints))))
;;                            (pr-if (pr-equal (g-car hints) (pr-quote 4))
;;                                   (g-fun-equal-axiom-proof conc hints symbols)
;;                                   (pr-if (pr-equal (g-car hints) (pr-quote 5))
;;                                          (g-pred-equal-axiom-proof conc hints symbols)
;;                                          (pr-quote (bool-fix nil))))))))
;; ;; the ev analogues of the various fol rule-checkers.
;; (defun g-expan-rule
;;       (conc hints sub-goals symbols)
;;       (pr-and (g-formula (g-cadr hints) symbols)
;;               (pr-and (g-formula (g-car sub-goals) symbols)
;;                       (pr-equal conc (g-f-or (g-cadr hints) (g-car sub-goals))))))
;; (defun g-contrac-rule
;;       (conc hints sub-goals symbols)
;;       (pr-and (g-formula (g-cadr hints) symbols)
;;               (pr-and (pr-equal sub-goals
;;                                 (g-cons (g-f-or (g-cadr hints) (g-cadr hints))
;;                                         (pr-quote (gcode nil))))
;;                       (pr-equal conc (g-cadr hints)))))
;; (defun g-assoc-rule
;;       (conc hints sub-goals symbols)
;;       (pr-and (g-formula (g-cadr hints) symbols)
;;               (pr-and (g-formula (g-caddr hints) symbols)
;;                       (pr-and (g-formula (g-cadddr hints) symbols)
;;                               (pr-and (pr-equal sub-goals
;;                                                 (g-cons (g-f-or (g-cadr hints)
;;                                                                 (g-f-or (g-caddr hints)
;;                                                                         (g-cadddr hints)))
;;                                                         (pr-quote (gcode nil))))
;;                                       (pr-equal conc
;;                                                 (g-f-or (g-f-or (g-cadr hints)
;;                                                                 (g-caddr hints))
;;                                                         (g-cadddr hints))))))))
;; (defn
;;  g-cut-rule
;;  (conc hints sub-goals symbols)
;;  (pr-and (g-formula (g-cadr hints) symbols)
;;          (pr-and (g-formula (g-caddr hints) symbols)
;;                  (pr-and (g-formula (g-cadddr hints) symbols)
;;                          (pr-and (pr-equal sub-goals
;;                                            (g-cons (g-f-or (g-cadr hints) (g-caddr hints))
;;                                                    (g-cons (g-f-or (g-f-not (g-cadr hints))
;;                                                                    (g-cadddr hints))
;;                                                            (pr-quote (gcode nil)))))
;;                                  (pr-equal conc (g-f-or (g-caddr hints) (g-cadddr hints))))))))
;; (defn
;;  g-forsome-intro-rule
;;  (conc hints sub-goals symbols)
;;  (pr-and (g-variable (g-cadr hints))
;;          (pr-and (g-formula (g-caddr hints) symbols)
;;                  (pr-and (g-formula (g-cadddr hints) symbols)
;;                          (pr-and (pr-not (g-memb (g-cadr hints)
;;                                                  (g-collect-free (g-cadddr hints)
;;                                                                  (pr-quote 0))))
;;                                  (pr-and (pr-equal sub-goals
;;                                                    (g-cons (g-f-implies (g-caddr hints)
;;                                                                         (g-cadddr hints))
;;                                                            (pr-quote (gcode nil))))
;;                                          (pr-equal conc
;;                                                    (g-f-implies (g-forsome (g-cadr hints)
;;                                                                            (g-caddr hints))
;;                                                                 (g-cadddr hints)))))))))
;; ;; the ev analogue of g-fol-rules.
;; (defun g-fol-rules
;;       (conc hints sub-goals symbols)
;;       (pr-if (pr-equal (g-car hints) (pr-quote 1))
;;              (g-expan-rule conc hints sub-goals symbols)
;;              (pr-if (pr-equal (g-car hints) (pr-quote 2))
;;                     (g-contrac-rule conc hints sub-goals symbols)
;;                     (pr-if (pr-equal (g-car hints) (pr-quote 3))
;;                            (g-assoc-rule conc hints sub-goals symbols)
;;                            (pr-if (pr-equal (g-car hints) (pr-quote 4))
;;                                   (g-cut-rule conc hints sub-goals symbols)
;;                                   (pr-if (pr-equal (g-car hints) (pr-quote 5))
;;                                          (g-forsome-intro-rule conc hints sub-goals symbols)
;;                                          (pr-quote (bool-fix nil))))))))
;; ;; the ev analogues of the various set-theoretic operations.
;; (defun g-isin
;;       (x y)
;;       (g-cons (g-cons (pr-quote 3) (g-cons (pr-quote 1) (pr-quote 2)))
;;               (g-cons x (g-cons y (pr-quote (gcode nil))))))
;; (defun g-phi
;;       nil
;;       (g-cons (g-cons (pr-quote 2) (g-cons (pr-quote 0) (pr-quote 0))) (pr-quote (gcode nil))))
;; (defun g-z-pair
;;       (x y)
;;       (g-cons (g-cons (pr-quote 2) (g-cons (pr-quote 1) (pr-quote 2)))
;;               (g-cons x (g-cons y (pr-quote (gcode nil))))))
;; (defun g-z-union
;;       (x y)
;;       (g-cons (g-cons (pr-quote 2) (g-cons (pr-quote 2) (pr-quote 2)))
;;               (g-cons x (g-cons y (pr-quote (gcode nil))))))
;; (defun g-z-int
;;       (x)
;;       (g-cons (g-cons (pr-quote 3) (g-cons (pr-quote 2) (pr-quote 1)))
;;               (g-cons x (pr-quote (gcode nil)))))
;; (defun g-z-succ
;;       (x)
;;       (g-cons (g-cons (pr-quote 2) (g-cons (pr-quote 3) (pr-quote 1)))
;;               (g-cons x (pr-quote (gcode nil)))))
;; (defun g-f-iff (x y) (g-f-and (g-f-implies x y) (g-f-implies y x)))
;; ;; the ev analogue of z2-axioms.
;; (defn
;;  g-z2-axioms
;;  (conc hints symbols)
;;  (pr-if
;;   (pr-equal (g-car hints) (pr-quote 1))
;;   (pr-and
;;    (g-variable (g-cadddr hints))
;;    (pr-and
;;     (g-termp (g-cadr hints) (pr-quote 0) symbols)
;;     (pr-and
;;      (g-termp (g-caddr hints) (pr-quote 0) symbols)
;;      (pr-and (pr-not (g-memb (g-cadddr hints) (g-collect-free (g-cadr hints) (pr-quote 0))))
;;              (pr-and (pr-not (g-memb (g-cadddr hints)
;;                                      (g-collect-free (g-caddr hints) (pr-quote 0))))
;;                      (pr-equal conc
;;                                (g-f-iff (g-f-equal (g-cadr hints) (g-caddr hints))
;;                                         (g-forall (g-cadddr hints)
;;                                                   (g-f-iff (g-isin (g-cadddr hints)
;;                                                                    (g-cadr hints))
;;                                                            (g-isin (g-cadddr hints)
;;                                                                    (g-caddr hints)))))))))))
;;   (pr-if
;;    (pr-equal (g-car hints) (pr-quote 2))
;;    (pr-and (g-termp (g-cadr hints) (pr-quote 0) symbols)
;;            (pr-equal conc (g-f-not (g-isin (g-cadr hints) (g-phi)))))
;;    (pr-if
;;     (pr-equal (g-car hints) (pr-quote 3))
;;     (pr-and (g-termp (g-cons (g-cadr hints)
;;                              (g-cons (g-caddr hints)
;;                                      (g-cons (g-cadddr hints) (pr-quote (gcode nil)))))
;;                      (pr-quote 1)
;;                      symbols)
;;             (pr-equal conc
;;                       (g-f-iff (g-isin (g-cadddr hints)
;;                                        (g-z-pair (g-cadr hints) (g-caddr hints)))
;;                                (g-f-or (g-f-equal (g-cadddr hints) (g-cadr hints))
;;                                        (g-f-equal (g-cadddr hints) (g-caddr hints))))))
;;     (pr-if
;;      (pr-equal (g-car hints) (pr-quote 4))
;;      (pr-and (g-termp (g-cons (g-cadr hints)
;;                               (g-cons (g-caddr hints)
;;                                       (g-cons (g-cadddr hints) (pr-quote (gcode nil)))))
;;                       (pr-quote 1)
;;                       symbols)
;;              (pr-equal conc
;;                        (g-f-iff (g-isin (g-cadddr hints)
;;                                         (g-z-union (g-cadr hints) (g-caddr hints)))
;;                                 (g-f-or (g-isin (g-cadddr hints) (g-cadr hints))
;;                                         (g-isin (g-cadddr hints) (g-caddr hints))))))
;;      (pr-if
;;       (pr-equal (g-car hints) (pr-quote 5))
;;       (pr-and
;;        (g-variable (g-caddr hints))
;;        (pr-and
;;         (g-formula (g-cadr hints) symbols)
;;         (pr-equal
;;          conc
;;          (g-f-implies
;;           (g-f-and (g-subst (g-cadr hints) (g-caddr hints) (g-phi) (pr-quote 0))
;;                    (g-forall (g-caddr hints)
;;                              (g-f-implies (g-f-and (g-z-int (g-caddr hints))
;;                                                    (g-cadr hints))
;;                                           (g-subst (g-cadr hints)
;;                                                    (g-caddr hints)
;;                                                    (g-z-succ (g-caddr hints))
;;                                                    (pr-quote 0)))))
;;           (g-forall (g-caddr hints)
;;                     (g-f-implies (g-z-int (g-caddr hints)) (g-cadr hints)))))))
;;       (pr-quote (bool-fix nil))))))))
;; ;; the ev analogue of symb-defn-proof.
;; (defn
;;  g-symb-defn-proof
;;  (conc hints sub-goals defun symbols)
;;  (pr-if
;;   (g-predicate (g-car (g-car hints)))
;;   (pr-and (g-set (g-cdr (g-car hints)))
;;           (pr-and (g-var-list (g-cdr (g-car hints)) (g-degree (g-car (g-car hints))))
;;                   (pr-and (pr-equal conc (g-f-iff (g-car hints) defn))
;;                           (pr-and (g-sub (g-collect-free defun (pr-quote 0))
;;                                          (g-cdr (g-car hints)))
;;                                   (g-formula defun (g-rest-of (g-car (g-car hints)) symbols))))))
;;   (pr-if
;;    (g-function (g-car (g-car hints)))
;;    (pr-and
;;     (g-set (g-cons (g-cadddr hints) (g-cons (g-cadr hints) (g-cdr (g-car hints)))))
;;     (pr-and
;;      (g-var-list (g-cdr (g-car hints)) (g-degree (g-car (g-car hints))))
;;      (pr-and
;;       (g-variable (g-cadr hints))
;;       (pr-and
;;        (g-variable (g-cadddr hints))
;;        (pr-and
;;         (g-formula (g-caddr hints) (g-rest-of (g-car (g-car hints)) symbols))
;;         (pr-and
;;          (g-sub (g-collect-free (g-caddr hints) (pr-quote 0))
;;                 (g-cons (g-cadr hints) (g-cdr (g-car hints))))
;;          (pr-and
;;           (g-free-for (g-caddr hints) (g-cadr hints) (g-car hints) (pr-quote 0))
;;           (pr-and
;;            (g-free-for (g-caddr hints) (g-cadr hints) (g-cadddr hints) (pr-quote 0))
;;            (pr-and
;;             (pr-equal conc
;;                       (g-subst (g-caddr hints)
;;                                (g-cadr hints)
;;                                (g-car hints)
;;                                (pr-quote 0)))
;;             (pr-and
;;              (pr-equal conc defn)
;;              (pr-equal
;;               sub-goals
;;               (g-cons (g-forsome (g-cadr hints) (g-caddr hints))
;;                       (g-cons (g-f-implies (g-f-and (g-caddr hints)
;;                                                     (g-subst (g-caddr hints)
;;                                                              (g-cadr hints)
;;                                                              (g-cadddr hints)
;;                                                              (pr-quote 0)))
;;                                            (g-f-equal (g-cadr hints)
;;                                                       (g-cadddr hints)))
;;                               (pr-quote (gcode nil)))))))))))))))
;;    (pr-quote (bool-fix nil)))))
;; (toggle g1286 g-symb-defn-proof t)
;; (toggle g1287 g-z2-axioms t)
;; (toggle g1288 g-fol-rules t)
;; ;; the e-definition of g-prf.
;; (defn
;;  g-prf-defn
;;  (pf given defns flg symbols)
;;  (pr-if
;;   (pr-zerop flg)
;;   (pr-if
;;    (g-typep pf 1)
;;    (pr-if
;;     (pr-not (g-formula (g-conc pf (pr-quote 0)) symbols))
;;     (pr-quote (bool-fix nil))
;;     (pr-if
;;      (pr-equal (g-car pf) (pr-quote 1))
;;      (g-fol-axiom-proof (g-conc pf (pr-quote 0)) (g-cadr pf) symbols)
;;      (pr-if (pr-equal (g-car pf) (pr-quote 2))
;;             (pr-and (g-fol-rules (g-conc pf (pr-quote 0))
;;                                  (g-cadr pf)
;;                                  (g-conc (g-cadddr pf) (pr-quote 1))
;;                                  symbols)
;;                     (g-prf (g-cadddr pf) given defns (pr-quote 1) symbols))
;;             (pr-if (pr-equal (g-car pf) (pr-quote 3))
;;                    (g-z2-axioms (g-conc pf (pr-quote 0)) (g-cadr pf) symbols)
;;                    (pr-if (pr-equal (g-car pf) (pr-quote 4))
;;                           (pr-and (g-symb-defn-proof (g-conc pf (pr-quote 0))
;;                                                      (g-cadr pf)
;;                                                      (g-conc (g-cadddr pf) (pr-quote 1))
;;                                                      (g-assoc (g-car (g-car (g-cadr pf)))
;;                                                               defns)
;;                                                      symbols)
;;                                   (pr-if (g-function (g-car (g-car (g-cadr pf))))
;;                                          (g-prf (g-cadddr pf)
;;                                                 given
;;                                                 defns
;;                                                 (pr-quote 1)
;;                                                 (g-rest-of (g-car (g-car (g-cadr pf)))
;;                                                            symbols))
;;                                          (pr-quote (bool-fix t))))
;;                           (pr-if (pr-equal (g-car pf) (pr-quote 5))
;;                                  (g-memb (g-conc pf (pr-quote 0)) given)
;;                                  (pr-quote (bool-fix nil))))))))
;;    (pr-quote (bool-fix nil)))
;;   (pr-if (g-typep pf 1)
;;          (pr-and (g-prf (g-car pf) given defns (pr-quote 0) symbols)
;;                  (g-prf (g-cdr pf) given defns (pr-quote 1) symbols))
;;          (pr-quote (bool-fix t)))))
;; ;; so far we have presented the e-definitions leading to the ev analogue
;; ;; of the proof-checker prf.  we need a few more e-definitions in order to
;; ;; construct the undecidable sentence.
;; ;; below is the e-definition for g-numeral.
;; (defun g-numeral (x) (list 29 x))
;; (defun g-numeral-defun nil (pr-if (pr-zerop 0) (g-phi) (g-z-succ (g-numeral (pr-sub1 0)))))
;; (defun g-z-sing (x) (g-z-pair x x))
;; (defun g-z-opair (x y) (g-z-pair (g-z-sing x) (g-z-pair x y)))
;; ;; the e-definition for g-plus (addition).
;; (defun g-plus (x y) (list 30 x y))
;; (defun g-plus-defun nil (pr-if (pr-zerop 0) (g-fix 1) (pr-add1 (g-plus (pr-sub1 0) 1))))
;; ;; the e-definition for g-times (multiplication).
;; (defun g-times (x y) (list 31 x y))
;; (defun g-times-defn
;;       nil
;;       (pr-if (pr-zerop 0) (pr-quote (gcode 0)) (g-plus 1 (g-times (pr-sub1 0) 1))))
;; ;; the e-definition for g-exp (exponentiation).
;; (defun g-exp (x y) (list 32 x y))
;; (defun g-exp-defun nil (pr-if (pr-zerop 1) (pr-quote (gcode 1)) (g-times 0 (g-exp 0 (pr-sub1 1)))))
;; ;; the e-definition for g-halve (integer division by 2).
;; (defun g-halve (x) (list 33 x))
;; (defun g-halve-defn
;;       nil
;;       (pr-if (pr-zerop 0)
;;              (pr-quote (gcode 0))
;;              (pr-if (pr-zerop (pr-sub1 0))
;;                     (pr-quote (gcode 0))
;;                     (pr-add1 (g-halve (pr-sub1 (pr-sub1 0)))))))
;; ;; the e-definition for g-<.
;; (defun g-< (x y) (list 34 x y))
;; (defun g-<-defn
;;       nil
;;       (pr-if (pr-zerop 1)
;;              (pr-quote (bool-fix nil))
;;              (pr-if (pr-zerop 0) (pr-quote (bool-fix t)) (g-< (pr-sub1 0) (pr-sub1 1)))))
;; ;; with plus, times, and exp, we can cipher num-trees as numbers, and with these
;; ;; and the halve function, we can decipher back the num-trees from the numbers
;; ;; by a yet-to-be-defined function decipher1.  the e-definition for g-decipher1 is
;; ;; shown below.
;; (defun g-decipher1 (x y z) (list 35 x y z))
;; (defun g-decipher1-defn
;;       nil
;;       (pr-if (pr-zerop 1)
;;              (g-halve (pr-sub1 0))
;;              (pr-if (pr-zerop 2)
;;                     (g-decipher1 0 (pr-sub1 1) 0)
;;                     (pr-if (pr-and (g-< 1 0) (g-< 2 0))
;;                            (pr-if (pr-equal 0
;;                                             (g-times (g-exp (pr-quote (gcode 2)) 1)
;;                                                      (g-exp (pr-quote (gcode 3)) 2)))
;;                                   (pr-cons (g-decipher1 1 (pr-sub1 1) (pr-sub1 1))
;;                                            (g-decipher1 2 (pr-sub1 2) (pr-sub1 2)))
;;                                   (g-decipher1 0 1 (pr-sub1 2)))
;;                            (g-decipher1 0 1 (pr-sub1 2))))))
;; (defun g-proves
;;       (pf exp given defns symbols)
;;       (pr-and (pr-equal (g-conc pf (pr-quote 0)) exp)
;;               (pr-and (g-formula exp symbols) (g-prf pf given defns (pr-quote 0) symbols))))
;; (toggle g1035 g-proves t)
;; (defun g-decipher (x) (g-decipher1 x (pr-sub1 x) (pr-sub1 x)))
;; ;; g-inv-code is the ev analogue of a function inv-code which is the inverse for gcode.
;; ;; at first sight, g-inv-code might seem like an identity mapping but that is only
;; ;; true when its argument is a gcode and as we shall see, this is not always the case.
;; (defun g-inv-code (x) (list 36 x))
;; (defun g-inv-code-defn
;;       nil
;;       (pr-if (pr-consp 0)
;;              (pr-if (pr-equal (pr-car 0) (pr-quote 1))
;;                     (g-cons (g-inv-code (pr-car (pr-cdr 0))) (g-inv-code (pr-cdr (pr-cdr 0))))
;;                     (pr-if (pr-equal (pr-car 0) (pr-quote 2))
;;                            (g-f-not (g-inv-code (pr-car (pr-cdr 0))))
;;                            (pr-if (pr-equal (pr-car 0) (pr-quote 3))
;;                                   (g-f-or (g-inv-code (pr-car (pr-cdr 0)))
;;                                           (g-inv-code (pr-cdr (pr-cdr 0))))
;;                                   (pr-if (pr-equal (pr-car 0) (pr-quote 4))
;;                                          (g-forsome (g-inv-code (pr-car (pr-cdr 0)))
;;                                                     (g-inv-code (pr-cdr (pr-cdr 0))))
;;                                          (pr-if (pr-equal (pr-car 0) (pr-quote 5))
;;                                                 (pr-quote (gcode t))
;;                                                 (pr-if (pr-equal (pr-car 0) (pr-quote 6))
;;                                                        (pr-quote (gcode nil))
;;                                                        (pr-quote (gcode nil))))))))
;;              (g-fix 0)))
;; ;; g-isthm is the ev analogue of the `theorem-checker' isthm which will be described
;; ;; later.  the e-definition is presented below.
;; (defun g-isthm (pfn exp given defns symbols) (list 37 pfn exp given defns symbols))
;; (defun g-isthm-defn
;;       nil
;;       (pr-if (g-proves (g-inv-code (g-decipher 0)) 1 2 3 4)
;;              (pr-quote (bool-fix t))
;;              (pr-if (g-proves (g-inv-code (g-decipher 0)) (g-f-not 1) 2 3 4)
;;                     (pr-quote (bool-fix nil))
;;                     (g-isthm (pr-add1 0) 1 2 3 4))))
;; ;; the last e-definition is that of gc-ncode which is the ev analogue of ncode.
;; (defun gc-ncode (x) (list 38 x))
;; (defun gc-ncode-defn
;;       nil
;;       (pr-if (pr-consp 0) (g-z-opair (gc-ncode (pr-car 0)) (gc-ncode (pr-cdr 0))) (g-numeral 0)))
;; ;; for the time being, we disable all the e-definitions.
;; (toggle g1036 g-append-defun t)
;; (toggle g1037 g-del-defun t)
;; (toggle g1038 g-memb-defun t)
;; (toggle g1039 g-collect-free-defun t)
;; (toggle g1040 g-covering-defun t)
;; (toggle g1041 g-nil-intersect-defun t)
;; (toggle g1042 g-var-list-defun t)
;; (toggle g1043 g-length-defun t)
;; (toggle g1044 g-termp-defun t)
;; (toggle g1045 g-subst-defun t)
;; (toggle g1046 g-sub-defun t)
;; (toggle g1047 g-formula-defun t)
;; (toggle g1048 g-pairequals-defun t)
;; (toggle g1055 g-set-defun t)
;; (toggle g1056 g-conc-defun t)
;; (toggle g1057 g-rest-of-defun t)
;; (toggle g1058 g-assoc-defun t)
;; (toggle g1059 g-prf-defun t)
;; (toggle g1060 g-numeral-defun t)
;; (toggle g1061 g-plus-defun t)
;; (toggle g1062 g-times-defun t)
;; (toggle g1063 g-exp-defun t)
;; (toggle g1064 g-halve-defun t)
;; (toggle g1065 g-<-defun t)
;; (toggle g1066 g-decipher1-defun t)
;; (toggle g1067 g-inv-code-defun t)
;; (toggle g1068 g-isthm-defun t)
;; (toggle g1069 gc-ncode-defun t)
;; (toggle g1070 sub1-n nil)
;; ;; the function fa below is the big list of e-definitions.
;; (defun fa
;;       nil
;;       (list (g-append-defn)
;;             (g-del-defn)
;;             (g-memb-defn)
;;             (g-collect-free-defn)
;;             (g-covering-defn)
;;             (g-nil-intersect-defn)
;;             (g-var-list-defn)
;;             (g-length-defn)
;;             (g-termp-defn)
;;             (g-subst-defn)
;;             (g-sub-defn)
;;             (g-formula-defn)
;;             (g-pairequals-defn)
;;             (g-set-defn)
;;             (g-conc-defn)
;;             (g-rest-of-defn)
;;             (g-assoc-defn)
;;             (g-prf-defun 0 1 2 3 4)
;;             (g-numeral-defn)
;;             (g-plus-defn)
;;             (g-times-defn)
;;             (g-exp-defn)
;;             (g-halve-defn)
;;             (g-<-defn)
;;             (g-decipher1-defn)
;;             (g-inv-code-defn)
;;             (g-isthm-defn)
;;             (gc-ncode-defn)))
;; (toggle g1072 sub1-n nil)
;; (defthm difference-< (implies (leq x y) (equal (difference x y) 0)))
;; (defthm difference-sub1-n

;;              (implies (acl2-numberp x) (equal (sub1-n x y) (difference x y))))
;; (toggle g1073 sub1-n t)
;; ;; we prove that get of the e-function symbol (minus 11) on (fa) yields the
;; ;; appropriate e-definition for each of the defined e-function symbols.
;; (defthm get-g-append-defun (equal (get (sub1-n 11 11) (fa)) (g-append-defn)))
;; (defthm get-sub1-n-nzerop (equal (get (add1 x) list) (get x (cdr list))))
;; (defthm difference-<2

;;              (implies (leq y x) (equal (difference (add1 x) y) (add1 (difference x y)))))

;; (defthm get-g-del-defun (equal (get (sub1-n 12 11) (fa)) (g-del-defn)))
;; (defthm get-g-memb-defun (equal (get (sub1-n 13 11) (fa)) (g-memb-defn)))
;; (defthm get-g-collect-free-defn

;;              (equal (get (sub1-n 14 11) (fa)) (g-collect-free-defn)))
;; (defthm get-g-covering-defun (equal (get (sub1-n 15 11) (fa)) (g-covering-defn)))
;; (defthm get-g-nil-intersect-defn

;;              (equal (get (sub1-n 16 11) (fa)) (g-nil-intersect-defn)))
;; (defthm get-g-var-list-defun (equal (get (sub1-n 17 11) (fa)) (g-var-list-defn)))
;; (defthm get-g-length-defun (equal (get (sub1-n 18 11) (fa)) (g-length-defn)))
;; (defthm get-g-termp-defun (equal (get (sub1-n 19 11) (fa)) (g-termp-defn)))
;; (defthm get-g-subst-defun (equal (get (sub1-n 20 11) (fa)) (g-subst-defn)))
;; (defthm get-g-sub-defun (equal (get (sub1-n 21 11) (fa)) (g-sub-defn)))
;; (defthm get-g-pairequals-defun (equal (get (sub1-n 23 11) (fa)) (g-pairequals-defn)))
;; (defthm get-g-set-defun (equal (get (sub1-n 24 11) (fa)) (g-set-defn)))
;; (defthm get-g-conc-defun (equal (get (sub1-n 25 11) (fa)) (g-conc-defn)))
;; (defthm get-g-rest-of-defun (equal (get (sub1-n 26 11) (fa)) (g-rest-of-defn)))
;; (defthm get-g-assoc-defun (equal (get (sub1-n 27 11) (fa)) (g-assoc-defn)))
;; (defthm get-g-prf-defun (equal (get (sub1-n 28 11) (fa)) (g-prf-defun 0 1 2 3 4)))
;; (defthm get-g-numeral-defun (equal (get (sub1-n 29 11) (fa)) (g-numeral-defn)))
;; (defthm get-g-plus-defun (equal (get (sub1-n 30 11) (fa)) (g-plus-defn)))
;; (defthm get-g-times-defun (equal (get (sub1-n 31 11) (fa)) (g-times-defn)))
;; (defthm get-g-exp-defun (equal (get (sub1-n 32 11) (fa)) (g-exp-defn)))
;; (defthm get-g-halve-defun (equal (get (sub1-n 33 11) (fa)) (g-halve-defn)))
;; (defthm get-g-<-defun (equal (get (sub1-n 34 11) (fa)) (g-<-defn)))
;; (defthm get-g-decipher1-defun (equal (get (sub1-n 35 11) (fa)) (g-decipher1-defn)))
;; (defthm get-g-inv-code-defun (equal (get (sub1-n 36 11) (fa)) (g-inv-code-defn)))
;; (defthm get-g-isthm-defun (equal (get (sub1-n 37 11) (fa)) (g-isthm-defn)))
;; (defthm get-gc-ncode-defun (equal (get (sub1-n 38 11) (fa)) (gc-ncode-defn)))
;; (toggle g1074 fa t)
;; (toggle g1075 difference-sub1-n t)
;; (toggle g1076 difference-< t)
;; (toggle g1077 difference-<2 t)
;; ;; in the next series of events, we prove that the e-functions defined correspond
;; ;; to their lisp analogues.  this involves two steps, in the first step we show,
;; ;; for example, that g-append when evaluated corresponds to g-appendn.  this is done
;; ;; in eval-g-append.  in the
;; ;; second step we show that g-appendn when given a large enough stack bound n
;; ;; corresponds to append.  this is done in g-appendn-gcode.
;; ;; we do the same thing for each of the e-functions.
;; ;; g-append-ind is the induction scheme for eval-g-append, and is quite subtle
;; ;; and could not have been guessed by the theorem-prover.
;; (defun g-append-ind
;;       (x y va n)
;;       (if (zerop n) t (g-append-ind (g-cdr 0) 1 (ev 1 (list x y) va (fa) n) (sub1 n))))
;; ;; g-appendn is the lisp analogue of g-append with n.
;; (defun g-appendn
;;       (x y n)
;;       (if (or (zerop n)
;;               (btmp x)
;;               (btmp y))
;;           (btm)
;;           (pr-ifn (g-typepn x 1) (g-consn (g-carn x) (g-appendn (g-cdrn x) y (sub1 n))) y)))
;; (toggle g1078 g-append nil)
;; (toggle g1079 g-append-defun nil)
;; ;; ev of g-append applied to arguments is g-appendn of the ev of the arguments.
;; (defthm eval-g-append

;;              (equal (ev 0 (g-append x y) va (fa) n)
;;                     (g-appendn (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-append-ind x y va n)) (disable eval-fun2)))
;; ;; appendn-ind is the induction scheme for g-appendn-gcode.
;; (defun appendn-ind (x y n) (if (consp x) (appendn-ind (cdr x) y (sub1 n)) t))
;; ;; for a sufficiently large n, g-appendn of the gcode of the arguments is
;; ;; the gcode of the append of the arguments.
;; (defthm g-appendn-gcode

;;              (implies (< (length x) n)
;;                       (equal (g-appendn (gcode x) (gcode y) n) (gcode (g-append x y))))
;;              ((disable bool-fix gcode) (induct (appendn-ind x y n))))
;; (toggle g1080 g-appendn t)
;; (toggle g1081 g-append t)
;; (toggle g1082 g-append-defun t)
;; (toggle g1083 eval-fun2 t)
;; ;; correspondence between g-del and g-deln, and g-deln and del.
;; (defun g-deln
;;       (x y n)
;;       (if (or (zerop n)
;;               (btmp x)
;;               (btmp y))
;;           (btm)
;;           (pr-ifn (g-typepn y 1)
;;                   (pr-ifn (pr-equaln x (g-carn y))
;;                           (g-deln x (g-cdrn y) (sub1 n))
;;                           (g-consn (g-carn y) (g-deln x (g-cdrn y) (sub1 n))))
;;                   y)))
;; (defun g-del-ind
;;       (x y va n)
;;       (if (zerop n) t (g-del-ind 0 (g-cdr 1) (ev 1 (list x y) va (fa) n) (sub1 n))))
;; (toggle g1084 g-del nil)
;; (toggle g1085 g-del-defun nil)
;; (defthm eval-g-del

;;              (equal (ev 0 (g-del x y) va (fa) n) (g-deln (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-del-ind x y va n))))
;; (defthm ncode-equal-reflex (ncode-equal x x))
;; (defthm acl2-numberp-ncode-equal

;;              (implies (and (acl2-numberp x)
;;                            (acl2-numberp y))
;;                       (equal (ncode-equal x y) (equal x y))))
;; (defthm ncode-gcode-equal

;;              (equal (ncode-equal (gcode x) (gcode y)) (g-eql x y))
;;              ((disable eql-gcode-equal)))
;; (toggle g1086 acl2-numberp-ncode-equal t)
;; (toggle g1087 pr-equaln nil)
;; (defthm g-deln-gcode

;;              (implies (< (length y) n)
;;                       (equal (g-deln (gcode x) (gcode y) n) (gcode (del x y))))
;;              ((disable bool-fix gcode) (induct (appendn-ind y x n))))
;; (toggle g1088 g-deln t)
;; (toggle g1089 g-del t)
;; (toggle g1090 g-del-defun t)
;; ;; correspondence between g-memb, g-membn, and memb.
;; (defun g-membn
;;       (x y n)
;;       (if (or (zerop n)
;;               (btmp x)
;;               (btmp y))
;;           (btm)
;;           (pr-ifn (g-typepn y 1)
;;                   (pr-ifn (pr-equaln x (g-carn y)) 1 (g-membn x (g-cdrn y) (sub1 n)))
;;                   0)))
;; (toggle g1091 g-memb nil)
;; (toggle g1092 g-memb-defun nil)
;; (defun g-memb-ind
;;       (x y va n)
;;       (if (zerop n) t (g-memb-ind 0 (g-cdr 1) (ev 1 (list x y) va (fa) n) (sub1 n))))
;; (defthm g-memb-eval

;;              (equal (ev 0 (g-memb x y) va (fa) n)
;;                     (g-membn (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-memb-ind x y va n))))
;; (defthm g-membn-gcode

;;              (implies (< (length y) n)
;;                       (equal (g-membn (gcode x) (gcode y) n) (if (memb x y) 1 0)))
;;              ((disable bool-fix gcode) (induct (appendn-ind y x n))))
;; (toggle g1093 g-memb t)
;; (toggle g1094 g-membn t)
;; (toggle g1095 g-memb-defun t)
;; ;; correspondence between g-collect-free, g-collect-freen, and collect-free.
;; (defun g-collect-freen
;;       (exp flg n)
;;       (if (or (zerop n)
;;               (btmp exp)
;;               (btmp flg))
;;           (btm)
;;           (pr-ifn (pr-zeropn flg)
;;                   (pr-ifn (g-variablen exp)
;;                           (g-consn exp (gcode nil))
;;                           (pr-ifn (g-typepn exp 2)
;;                                   (g-collect-freen (g-argn exp 0 2) 0 (sub1 n))
;;                                   (pr-ifn (g-typepn exp 3)
;;                                           (g-appendn (g-collect-freen (g-argn exp 0 3)
;;                                                                       0
;;                                                                       (sub1 n))
;;                                                      (g-collect-freen (g-argn exp 1 3)
;;                                                                       0
;;                                                                       (sub1 n))
;;                                                      (sub1 n))
;;                                           (pr-ifn (g-typepn exp 4)
;;                                                   (g-deln (g-argn exp 0 4)
;;                                                           (g-collect-freen (g-argn exp 1 4)
;;                                                                            0
;;                                                                            (sub1 n))
;;                                                           (sub1 n))
;;                                                   (pr-ifn (g-typepn exp 1)
;;                                                           (g-collect-freen (g-cdrn exp)
;;                                                                            1
;;                                                                            (sub1 n))
;;                                                           (gcode nil))))))
;;                   (pr-ifn (g-typepn exp 1)
;;                           (g-appendn (g-collect-freen (g-carn exp) 0 (sub1 n))
;;                                      (g-collect-freen (g-cdrn exp) 1 (sub1 n))
;;                                      (sub1 n))
;;                           (gcode nil)))))
;; (toggle g1096 g-collect-free nil)
;; (toggle g1097 g-collect-free-defun nil)
;; (defun g-collect-free-ind
;;       (exp flg va n)
;;       (if (zerop n)
;;           t
;;           (and (g-collect-free-ind (g-arg 0 (pr-quote 0) 2)
;;                                    (pr-quote 0)
;;                                    (ev 1 (list exp flg) va (fa) n)
;;                                    (sub1 n))
;;                (g-collect-free-ind (g-arg 0 (pr-quote 0) 3)
;;                                    (pr-quote 0)
;;                                    (ev 1 (list exp flg) va (fa) n)
;;                                    (sub1 n))
;;                (g-collect-free-ind (g-arg 0 (pr-quote 1) 3)
;;                                    (pr-quote 0)
;;                                    (ev 1 (list exp flg) va (fa) n)
;;                                    (sub1 n))
;;                (g-collect-free-ind (g-arg 0 (pr-quote 1) 4)
;;                                    (pr-quote 0)
;;                                    (ev 1 (list exp flg) va (fa) n)
;;                                    (sub1 n))
;;                (g-collect-free-ind (g-cdr 0)
;;                                    (pr-quote 1)
;;                                    (ev 1 (list exp flg) va (fa) n)
;;                                    (sub1 n))
;;                (g-collect-free-ind (g-car 0)
;;                                    (pr-quote 0)
;;                                    (ev 1 (list exp flg) va (fa) n)
;;                                    (sub1 n)))))
;; (defthm g-collect-free-eval

;;              (equal (ev 0 (g-collect-free exp flg) va (fa) n)
;;                     (g-collect-freen (ev 0 exp va (fa) n) (ev 0 flg va (fa) n) n))
;;              ((induct (g-collect-free-ind exp flg va n))))
;; (defun exp-count
;;       (exp)
;;       (if (consp exp)
;;           (add1 (plus (exp-count (car exp)) (exp-count (cdr exp))))
;;           (if (f-notp exp)
;;               (add1 (exp-count (arg exp)))
;;               (if (f-orp exp)
;;                   (add1 (plus (exp-count (arg1 exp)) (exp-count (arg2 exp))))
;;                   (if (forsomep exp) (add1 (exp-count (g-body exp))) 1)))))
;; (defthm exp-count-append

;;              (< (exp-count (g-append x y)) (plus (exp-count x) (exp-count y))))
;; (defthm exp-count-del (< (exp-count (del x y)) (add1 (exp-count y))))
;; (defthm length-exp-count (< (length x) (add1 (exp-count x))))
;; (defthm length-append (equal (length (g-append x y)) (plus (length x) (length y))))
;; (defthm length-del (< (length (del x y)) (add1 (length y))))
;; (defthm collect-free-count

;;              (< (length (collect-free exp flg)) (add1 (exp-count exp)))
;;              ((induct (collect-free exp flg))))
;; (defun collect-freen-ind
;;       (exp flg n)
;;       (if (zerop flg)
;;           (if (g-variable exp)
;;               nil
;;               (if (f-notp exp)
;;                   (collect-freen-ind (arg exp) 0 (sub1 n))
;;                   (if (f-orp exp)
;;                       (and (collect-freen-ind (arg1 exp) 0 (sub1 n))
;;                            (collect-freen-ind (arg2 exp) 0 (sub1 n)))
;;                       (if (forsomep exp)
;;                           (collect-freen-ind (g-body exp) 0 (sub1 n))
;;                           (if (consp exp) (collect-freen-ind (cdr exp) 1 (sub1 n)) nil)))))
;;           (if (consp exp)
;;               (and (collect-freen-ind (car exp) 0 (sub1 n))
;;                    (collect-freen-ind (cdr exp) 1 (sub1 n)))
;;               nil)))
;; (defthm g-collect-freen-gcode

;;              (implies (and (not (btmp flg))
;;                            (< (exp-count exp) n))
;;                       (equal (g-collect-freen (gcode exp) flg n) (gcode (collect-free exp flg))))
;;              ((disable bool-fix gcode) (induct (collect-freen-ind exp flg n))))
;; (defthm acl2-numberp-gcode (equal (acl2-numberp (gcode exp)) (acl2-numberp exp)))
;; (defthm collect-free-gcode-flg

;;              (equal (collect-free exp (gcode flg)) (collect-free exp flg)))
;; (toggle g1110 g-collect-free t)
;; (toggle g1111 g-collect-freen t)
;; (toggle g1112 g-collect-free-defun t)
;; (toggle g1113 pr-andn t)
;; ;; correspondence between g-covering, g-coveringn, and covering.
;; (defun g-coveringn
;;       (exp var flg n)
;;       (if (or (zerop n)
;;               (btmp exp)
;;               (btmp var)
;;               (btmp flg))
;;           (btm)
;;           (pr-ifn (pr-zeropn flg)
;;                   (pr-ifn (g-typepn exp 2)
;;                           (g-coveringn (g-argn exp 0 2) var (gcode 0) (sub1 n))
;;                           (pr-ifn (g-typepn exp 3)
;;                                   (g-appendn (g-coveringn (g-argn exp 0 3)
;;                                                           var
;;                                                           (gcode 0)
;;                                                           (sub1 n))
;;                                              (g-coveringn (g-argn exp 1 3)
;;                                                           var
;;                                                           (gcode 0)
;;                                                           (sub1 n))
;;                                              (sub1 n))
;;                                   (pr-ifn (g-typepn exp 4)
;;                                           (pr-ifn (g-membn var
;;                                                            (g-collect-freen exp
;;                                                                             (gcode 0)
;;                                                                             (sub1 n))
;;                                                            (sub1 n))
;;                                                   (g-consn (g-argn exp 0 4)
;;                                                            (g-coveringn (g-argn exp 1 4)
;;                                                                         var
;;                                                                         (gcode 0)
;;                                                                         (sub1 n)))
;;                                                   (gcode nil))
;;                                           (pr-ifn (g-typepn exp 1)
;;                                                   (g-coveringn (g-cdrn exp)
;;                                                                var
;;                                                                (gcode 1)
;;                                                                (sub1 n))
;;                                                   (gcode nil)))))
;;                   (pr-ifn (g-typepn exp 1)
;;                           (g-appendn (g-coveringn (g-carn exp) var (gcode 0) (sub1 n))
;;                                      (g-coveringn (g-cdrn exp) var (gcode 1) (sub1 n))
;;                                      (sub1 n))
;;                           (gcode nil)))))
;; (toggle g1114 g-covering nil)
;; (toggle g1115 g-covering-defun nil)
;; (defun g-covering-ind
;;       (exp var flg va n)
;;       (if (zerop n)
;;           t
;;           (and (g-covering-ind (g-arg 0 (pr-quote 0) 2)
;;                                1
;;                                (pr-quote 0)
;;                                (ev 1 (list exp var flg) va (fa) n)
;;                                (sub1 n))
;;                (g-covering-ind (g-arg 0 (pr-quote 0) 3)
;;                                1
;;                                (pr-quote 0)
;;                                (ev 1 (list exp var flg) va (fa) n)
;;                                (sub1 n))
;;                (g-covering-ind (g-arg 0 (pr-quote 1) 3)
;;                                1
;;                                (pr-quote 0)
;;                                (ev 1 (list exp var flg) va (fa) n)
;;                                (sub1 n))
;;                (g-covering-ind (g-arg 0 (pr-quote 1) 4)
;;                                1
;;                                (pr-quote 0)
;;                                (ev 1 (list exp var flg) va (fa) n)
;;                                (sub1 n))
;;                (g-covering-ind (g-cdr 0)
;;                                1
;;                                (pr-quote 1)
;;                                (ev 1 (list exp var flg) va (fa) n)
;;                                (sub1 n))
;;                (g-covering-ind (g-car 0)
;;                                1
;;                                (pr-quote 0)
;;                                (ev 1 (list exp var flg) va (fa) n)
;;                                (sub1 n)))))
;; (defthm g-covering-eval

;;              (equal (ev 0 (g-covering exp var flg) va (fa) n)
;;                     (g-coveringn (ev 0 exp va (fa) n) (ev 0 var va (fa) n) (ev 0 flg va (fa) n) n))
;;              ((induct (g-covering-ind exp var flg va n))))
;; (defthm covering-count (< (length (covering exp var flg)) (exp-count exp)))
;; (defthm pr-zeropn-gcode (equal (pr-zeropn (gcode x)) (bool-fix (zerop x))))
;; (toggle g1116 pr-zeropn t)
;; (toggle g1117 bool-fix nil)
;; (defthm g-membn-gcode-again

;;              (implies (< (length y) n)
;;                       (equal (g-membn (gcode x) (gcode y) n) (bool-fix (memb x y))))
;;              ((disable g-membn gcode)))
;; (toggle g1118 bool-fix t)
;; (toggle g1119 g-membn-gcode t)
;; (defun coveringn-ind
;;       (exp var flg n)
;;       (if (zerop flg)
;;           (if (f-notp exp)
;;               (coveringn-ind (arg exp) var 0 (sub1 n))
;;               (if (f-orp exp)
;;                   (and (coveringn-ind (arg1 exp) var 0 (sub1 n))
;;                        (coveringn-ind (arg2 exp) var 0 (sub1 n)))
;;                   (if (forsomep exp)
;;                       (if (memb var (collect-free exp 0))
;;                           (coveringn-ind (g-body exp) var 0 (sub1 n))
;;                           nil)
;;                       (if (consp exp)
;;                           (coveringn-ind (cdr exp) var 1 (sub1 n))
;;                           (if (acl2-numberp exp) nil nil)))))
;;           (if (consp exp)
;;               (and (coveringn-ind (car exp) var 0 (sub1 n))
;;                    (coveringn-ind (cdr exp) var 1 (sub1 n)))
;;               nil)))
;; (defthm g-coveringn-gcode

;;              (implies (< (add1 (exp-count exp)) n)
;;                       (equal (g-coveringn (gcode exp) (gcode var) (gcode flg) n)
;;                              (gcode (covering exp var flg))))
;;              ((disable bool-fix gcode) (induct (coveringn-ind exp var flg n))))
;; (toggle g1120 g-coveringn t)
;; (toggle g1121 g-covering t)
;; (toggle g1122 g-covering-defun t)
;; ;; correspondence between g-nil-intersect, g-nil-intersectn, and nil-intersect.
;; (defun g-nil-intersectn
;;       (x y n)
;;       (if (or (btmp x)
;;               (btmp y)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-typepn x 1)
;;                   (pr-andn (pr-notn (g-membn (g-carn x) y (sub1 n)))
;;                            (g-nil-intersectn (g-cdrn x) y (sub1 n)))
;;                   (bool-fix t))))
;; (toggle g1123 g-nil-intersect-defun nil)
;; (toggle g1124 g-nil-intersect nil)
;; (defthm g-nil-intersect-eval

;;              (equal (ev 0 (g-nil-intersect x y) va (fa) n)
;;                     (g-nil-intersectn (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-append-ind x y va n))))
;; (toggle g1125 pr-notn t)
;; (defun nil-intersect-ind
;;       (x y n)
;;       (if (zerop n) t (if (consp x) (nil-intersect-ind (cdr x) y (sub1 n)) t)))
;; (defthm g-nil-intersectn-gcode

;;              (implies (< (plus (length x) (length y)) n)
;;                       (equal (g-nil-intersectn (gcode x) (gcode y) n)
;;                              (bool-fix (nil-intersect x y))))
;;              ((disable gcode bool-fix) (induct (nil-intersect-ind x y n))))
;; (toggle g1126 g-nil-intersect t)
;; (toggle g1127 g-nil-intersectn t)
;; (toggle g1128 g-nil-intersect-defun t)
;; (toggle g1129 g-free-for nil)
;; ;; correspondence between g-free-for, g-free-forn, and free-for.
;; (defun g-free-forn
;;       (exp var term flg n)
;;       (g-nil-intersectn (g-coveringn exp var flg n) (g-collect-freen term (gcode 0) n) n))
;; (defthm eval-g-free-for

;;              (equal (ev 0 (g-free-for exp var term flg) va (fa) n)
;;                     (g-free-forn (ev 0 exp va (fa) n)
;;                                  (ev 0 var va (fa) n)
;;                                  (ev 0 term va (fa) n)
;;                                  (ev 0 flg va (fa) n)
;;                                  n)))
;; (toggle g1130 free-for nil)
;; (defthm g-free-forn-gcode

;;              (implies (< (add1 (plus (exp-count exp) (exp-count term))) n)
;;                       (equal (g-free-forn (gcode exp) (gcode var) (gcode term) (gcode flg) n)
;;                              (bool-fix (free-for exp var term flg)))))
;; (toggle g1131 g-free-for t)
;; (toggle g1132 g-free-forn t)
;; (toggle g1133 free-for t)
;; ;; correspondence between g-var-list, g-var-listn, and var-list.
;; (defun g-var-listn
;;       (list len n)
;;       (if (or (zerop n)
;;               (btmp list)
;;               (btmp len))
;;           (btm)
;;           (pr-ifn (pr-orn (pr-zeropn len) (pr-notn (g-typepn list 1)))
;;                   (pr-andn (pr-zeropn len) (pr-notn (g-typepn list 1)))
;;                   (pr-andn (g-variablen (g-carn list))
;;                            (g-var-listn (g-cdrn list) (pr-sub1n len) (sub1 n))))))
;; (toggle g1139 g-var-list nil)
;; (toggle g1140 g-var-list-defun nil)
;; (defun g-var-list-ind
;;       (list len va n)
;;       (if (zerop n)
;;           t
;;           (g-var-list-ind (g-cdr 0) (pr-sub1 1) (ev 1 (list list len) va (fa) n) (sub1 n))))
;; (defthm g-var-list-eval

;;              (equal (ev 0 (g-var-list list len) va (fa) n)
;;                     (g-var-listn (ev 0 list va (fa) n) (ev 0 len va (fa) n) n))
;;              ((induct (g-var-list-ind list len va n))))
;; (defun var-listn-ind
;;       (list len n)
;;       (if (zerop n)
;;           t
;;           (if (or (zerop len)
;;                   (atom list))
;;               t
;;               (var-listn-ind (cdr list) (sub1 len) (sub1 n)))))
;; (defthm g-var-listn-gcode

;;              (implies (< len n)
;;                       (equal (g-var-listn (gcode list) (gcode len) n)
;;                              (bool-fix (var-list list len))))
;;              ((disable gcode bool-fix) (induct (var-listn-ind list len n))))
;; (toggle g1141 g-var-listn t)
;; (toggle g1142 g-var-list t)
;; (toggle g1143 g-var-list-defun t)
;; (defthm pr-equaln-reduc

;;              (equal (pr-equaln (gcode x) (gcode y)) (bool-fix (g-eql x y))))
;; (toggle g1147 pr-equaln t)
;; (toggle g1150 pr-orn t)
;; ;; correspondence between g-symb, g-symbn, and symb.
;; (defun g-symbn
;;       (x symbols n)
;;       (pr-orn (pr-equaln x (g-consn (gcode 3) (g-consn (gcode 0) (gcode 2))))
;;               (g-membn x symbols n)))
;; (toggle g1151 g-symb nil)
;; (defthm g-symb-eval

;;              (equal (ev 0 (g-symb x symbols) va (fa) n)
;;                     (g-symbn (ev 0 x va (fa) n) (ev 0 symbols va (fa) n) n)))
;; (toggle g1152 p nil)
;; (toggle g1153 bool-fix nil)
;; (defthm gcode-p

;;              (equal (bool-fix (equal x (cons 3 (cons 0 2))))
;;                     (bool-fix (equal (gcode x) (gcode (cons 3 (cons 0 2)))))))
;; (toggle g1154 bool-fix t)
;; (defthm g-symbn-gcode

;;              (implies (< (length symbols) n)
;;                       (equal (g-symbn (gcode x) (gcode symbols) n) (bool-fix (symb x symbols))))
;;              ((disable gcode bool-fix)))
;; (toggle g1155 p t)
;; (toggle g1156 g-symb t)
;; (toggle g1157 g-symbn t)
;; ;; correspondence between g-length, g-lengthn, and length.
;; (defun g-lengthn
;;       (x n)
;;       (if (or (btmp x)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-typepn x 1) (pr-add1n (g-lengthn (g-cdrn x) (sub1 n))) (gcode 0))))
;; (toggle g1158 g-length-defun nil)
;; (toggle g1159 g-length nil)
;; (defun g-length-ind
;;       (x va n)
;;       (if (zerop n) t (g-length-ind (g-cdr 0) (ev 1 (list x) va (fa) n) (sub1 n))))
;; (defthm eval-g-length

;;              (equal (ev 0 (g-length x) va (fa) n) (g-lengthn (ev 0 x va (fa) n) n))
;;              ((induct (g-length-ind x va n))))
;; (defthm add1-gcode (equal (add1 (gcode x)) (gcode (add1 x))))
;; (defthm g-lengthn-gcode

;;              (implies (< (length x) n) (equal (g-lengthn (gcode x) n) (gcode (length x))))
;;              ((disable gcode bool-fix) (induct (var-list x n))))
;; (toggle g1160 g-length t)
;; (toggle g1161 g-lengthn t)
;; (toggle g1162 g-length-defun t)
;; ;; correspondence between g-termp, g-termpn, and termp.
;; (defn
;;  g-termpn
;;  (exp flg symbols n)
;;  (if
;;   (or (btmp exp)
;;       (btmp flg)
;;       (btmp symbols)
;;       (zerop n))
;;   (btm)
;;   (pr-ifn
;;    (pr-zeropn flg)
;;    (pr-ifn (g-typepn exp 1)
;;            (pr-andn (g-functionn (g-carn exp))
;;                     (pr-andn (g-symbn (g-carn exp) symbols (sub1 n))
;;                              (pr-andn (g-termpn (g-cdrn exp) (gcode 1) symbols (sub1 n))
;;                                       (pr-equaln (g-lengthn (g-cdrn exp) (sub1 n))
;;                                                  (g-fixn (g-cdrn (g-cdrn (g-carn exp))))))))
;;            (g-variablen exp))
;;    (pr-ifn (g-typepn exp 1)
;;            (pr-andn (g-termpn (g-carn exp) (gcode 0) symbols (sub1 n))
;;                     (g-termpn (g-cdrn exp) (gcode 1) symbols (sub1 n)))
;;            (bool-fix t)))))
;; (toggle g1163 g-termp nil)
;; (toggle g1164 g-termp-defun nil)
;; (defun g-termp-ind
;;       (exp flg symbols va n)
;;       (if (zerop n)
;;           t
;;           (and (g-termp-ind (g-cdr 0)
;;                             (pr-quote 1)
;;                             2
;;                             (ev 1 (list exp flg symbols) va (fa) n)
;;                             (sub1 n))
;;                (g-termp-ind (g-car 0)
;;                             (pr-quote 0)
;;                             2
;;                             (ev 1 (list exp flg symbols) va (fa) n)
;;                             (sub1 n)))))
;; (defthm g-termp-eval

;;              (equal (ev 0 (g-termp exp flg symbols) va (fa) n)
;;                     (g-termpn (ev 0 exp va (fa) n)
;;                               (ev 0 flg va (fa) n)
;;                               (ev 0 symbols va (fa) n)
;;                               n))
;;              ((induct (g-termp-ind exp flg symbols va n))))
;; (defun termp-ind
;;       (exp flg symbols n)
;;       (if (zerop n)
;;           t
;;           (if (zerop flg)
;;               (if (consp exp) (termp-ind (cdr exp) 1 symbols (sub1 n)) t)
;;               (if (consp exp)
;;                   (and (termp-ind (car exp) 0 symbols (sub1 n))
;;                        (termp-ind (cdr exp) 1 symbols (sub1 n)))
;;                   t))))
;; (defthm length-consp-cdr (implies (consp x) (< (length (cdr x)) (length x))))
;; (defthm not-length-cdr (not (< (length x) (length (cdr x)))))
;; (defun termp-cnt
;;       (exp flg symbols)
;;       (if (zerop flg)
;;           (if (consp exp) (add1 (termp-cnt (cdr exp) 1 symbols)) (add1 (add1 (length symbols))))
;;           (if (consp exp)
;;               (add1 (plus (termp-cnt (car exp) 0 symbols) (termp-cnt (cdr exp) 1 symbols)))
;;               (add1 (add1 (length symbols))))))
;; (defthm <-symbols-termp-cnt

;;              (< (length symbols) (sub1 (termp-cnt exp flg symbols))))
;; (defthm <-length-termp-cnt (< (length exp) (termp-cnt exp flg symbols)))
;; (toggle g1165 degree nil)
;; (defthm acl2-numberp-gcode-equal

;;              (implies (or (acl2-numberp x)
;;                           (acl2-numberp y))
;;                       (equal (equal (gcode x) (gcode y)) (equal x y))))
;; (defthm g-termpn-gcode

;;              (implies (< (termp-cnt exp flg symbols) n)
;;                       (equal (g-termpn (gcode exp) (gcode flg) (gcode symbols) n)
;;                              (bool-fix (g-termp exp flg symbols))))
;;              ((induct (termp-ind exp flg symbols n)) (disable gcode variable length symb-equals)))
;; (toggle g1166 g-termp t)
;; (toggle g1167 g-termpn t)
;; (toggle g1168 g-termp-defun t)
;; (toggle g1169 termp-cnt t)
;; ;; correspondence between g-atomp, g-atompn, and atomp.
;; (defun g-atompn
;;       (exp symbols n)
;;       (pr-andn (g-predicaten (g-carn exp))
;;                (pr-andn (g-symbn (g-carn exp) symbols n)
;;                         (pr-andn (pr-equaln (g-lengthn (g-cdrn exp) n)
;;                                             (g-fixn (g-cdrn (g-cdrn (g-carn exp)))))
;;                                  (g-termpn (g-cdrn exp) (gcode 1) symbols n)))))
;; (toggle g1170 g-atomp nil)
;; (defthm g-atomp-eval

;;              (equal (ev 0 (g-atomp exp symbols) va (fa) n)
;;                     (g-atompn (ev 0 exp va (fa) n) (ev 0 symbols va (fa) n) n)))
;; (toggle g1171 pr-andn nil)
;; (toggle g1172 bool-fix nil)
;; (defthm lazy-pr-andn-reduc (equal (pr-andn (bool-fix nil) y) (bool-fix nil)))
;; (defthm lazy-pr-andn-reduc2

;;              (equal (pr-andn (bool-fix t) (bool-fix y)) (bool-fix y)))
;; (toggle g1173 pr-andn t)
;; (toggle g1174 bool-fix t)
;; (defthm g-atompn-gcode

;;              (implies (< (termp-cnt (cdr exp) 1 symbols) n)
;;                       (equal (g-atompn (gcode exp) (gcode symbols) n)
;;                              (bool-fix (g-atomp exp symbols))))
;;              ((disable gcode length symb-equals)))
;; (toggle g1175 g-atomp t)
;; (toggle g1176 g-atompn t)
;; ;; correspondence between g-subst, g-substn, and subst.
;; (defun g-substn
;;       (exp var term flg n)
;;       (if (or (btmp exp)
;;               (btmp var)
;;               (btmp term)
;;               (btmp flg)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-zeropn flg)
;;                   (pr-ifn (g-variablen exp)
;;                           (pr-ifn (pr-equaln exp var) term exp)
;;                           (pr-ifn (g-typepn exp 2)
;;                                   (g-f-notn (g-substn (g-argn exp 0 2)
;;                                                       var
;;                                                       term
;;                                                       (gcode 0)
;;                                                       (sub1 n)))
;;                                   (pr-ifn (g-typepn exp 3)
;;                                           (g-f-orn (g-substn (g-argn exp 0 3)
;;                                                              var
;;                                                              term
;;                                                              (gcode 0)
;;                                                              (sub1 n))
;;                                                    (g-substn (g-argn exp 1 3)
;;                                                              var
;;                                                              term
;;                                                              (gcode 0)
;;                                                              (sub1 n)))
;;                                           (pr-ifn (g-typepn exp 4)
;;                                                   (pr-ifn (pr-equaln (g-argn exp 0 4) var)
;;                                                           exp
;;                                                           (g-forsomen (g-argn exp 0 4)
;;                                                                       (g-substn (g-argn exp
;;                                                                                         1
;;                                                                                         4)
;;                                                                                 var
;;                                                                                 term
;;                                                                                 (gcode 0)
;;                                                                                 (sub1 n))))
;;                                                   (pr-ifn (g-typepn exp 1)
;;                                                           (g-consn (g-carn exp)
;;                                                                    (g-substn (g-cdrn exp)
;;                                                                              var
;;                                                                              term
;;                                                                              (gcode 1)
;;                                                                              (sub1 n)))
;;                                                           exp)))))
;;                   (pr-ifn (g-typepn exp 1)
;;                           (g-consn (g-substn (g-carn exp) var term (gcode 0) (sub1 n))
;;                                    (g-substn (g-cdrn exp) var term (gcode 1) (sub1 n)))
;;                           exp))))
;; (toggle g1177 g-subst nil)
;; (toggle g1178 g-subst-defun nil)
;; (defun g-subst-ind
;;       (exp var term flg va n)
;;       (if (zerop n)
;;           t
;;           (and (g-subst-ind (g-arg 0 (pr-quote 0) 2)
;;                             1
;;                             2
;;                             (pr-quote (gcode 0))
;;                             (ev 1 (list exp var term flg) va (fa) n)
;;                             (sub1 n))
;;                (g-subst-ind (g-arg 0 (pr-quote 0) 3)
;;                             1
;;                             2
;;                             (pr-quote (gcode 0))
;;                             (ev 1 (list exp var term flg) va (fa) n)
;;                             (sub1 n))
;;                (g-subst-ind (g-arg 0 (pr-quote 1) 3)
;;                             1
;;                             2
;;                             (pr-quote (gcode 0))
;;                             (ev 1 (list exp var term flg) va (fa) n)
;;                             (sub1 n))
;;                (g-subst-ind (g-arg 0 (pr-quote 1) 4)
;;                             1
;;                             2
;;                             (pr-quote (gcode 0))
;;                             (ev 1 (list exp var term flg) va (fa) n)
;;                             (sub1 n))
;;                (g-subst-ind (g-arg 0 (pr-quote 1) 1)
;;                             1
;;                             2
;;                             (pr-quote (gcode 1))
;;                             (ev 1 (list exp var term flg) va (fa) n)
;;                             (sub1 n))
;;                (g-subst-ind (g-arg 0 (pr-quote 0) 1)
;;                             1
;;                             2
;;                             (pr-quote (gcode 0))
;;                             (ev 1 (list exp var term flg) va (fa) n)
;;                             (sub1 n)))))
;; (defthm g-subst-eval

;;              (equal (ev 0 (g-subst exp var term flg) va (fa) n)
;;                     (g-substn (ev 0 exp va (fa) n)
;;                               (ev 0 var va (fa) n)
;;                               (ev 0 term va (fa) n)
;;                               (ev 0 flg va (fa) n)
;;                               n))
;;              ((induct (g-subst-ind exp var term flg va n))))
;; (defun subst-ind
;;       (exp var term flg n)
;;       (if (zerop flg)
;;           (if (g-variable exp)
;;               t
;;               (if (f-notp exp)
;;                   (subst-ind (arg exp) var term 0 (sub1 n))
;;                   (if (f-orp exp)
;;                       (and (subst-ind (arg1 exp) var term 0 (sub1 n))
;;                            (subst-ind (arg2 exp) var term 0 (sub1 n)))
;;                       (if (forsomep exp)
;;                           (subst-ind (g-body exp) var term 0 (sub1 n))
;;                           (if (consp exp) (subst-ind (cdr exp) var term 1 (sub1 n)) t)))))
;;           (if (consp exp)
;;               (and (subst-ind (car exp) var term 0 (sub1 n))
;;                    (subst-ind (cdr exp) var term 1 (sub1 n)))
;;               t)))
;; (defthm g-substn-gcode

;;              (implies (< (exp-count exp) n)
;;                       (equal (g-substn (gcode exp) (gcode var) (gcode term) (gcode flg) n)
;;                              (gcode (g-subst exp var term flg))))
;;              ((disable gcode) (induct (subst-ind exp var term flg n))))
;; (toggle g1179 g-subst t)
;; (toggle g1180 g-substn t)
;; (toggle g1181 g-subst-defun t)
;; ;; correspondence between g-sub, g-subn, and sub.
;; (defun g-subn
;;       (x y n)
;;       (if (or (btmp x)
;;               (btmp y)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-typepn x 1)
;;                   (pr-andn (g-membn (g-carn x) y (sub1 n)) (g-subn (g-cdrn x) y (sub1 n)))
;;                   (bool-fix t))))
;; (toggle g1182 g-sub nil)
;; (toggle g1183 g-sub-defun nil)
;; (defun g-sub-ind
;;       (x y va n)
;;       (if (zerop n) t (g-sub-ind (g-cdr 0) 1 (ev 1 (list x y) va (fa) n) (sub1 n))))
;; (defthm g-sub-eval

;;              (equal (ev 0 (g-sub x y) va (fa) n) (g-subn (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-sub-ind x y va n))))
;; (defthm g-subn-gcode

;;              (implies (< (plus (length x) (length y)) n)
;;                       (equal (g-subn (gcode x) (gcode y) n) (bool-fix (sub x y))))
;;              ((induct (appendn-ind x y n))))
;; (toggle g1184 g-sub t)
;; (toggle g1185 g-subn t)
;; (toggle g1186 g-sub-defun t)
;; ;; correspondence between g-formula, g-formulan, and formula.
;; (defun g-formulan
;;       (exp symbols n)
;;       (if (or (btmp exp)
;;               (btmp symbols)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-typepn exp 2)
;;                   (g-formulan (g-argn exp 0 2) symbols (sub1 n))
;;                   (pr-ifn (g-typepn exp 3)
;;                           (pr-andn (g-formulan (g-argn exp 0 3) symbols (sub1 n))
;;                                    (g-formulan (g-argn exp 1 3) symbols (sub1 n)))
;;                           (pr-ifn (g-typepn exp 4)
;;                                   (g-formulan (g-argn exp 1 4) symbols (sub1 n))
;;                                   (g-atompn exp symbols (sub1 n)))))))
;; (toggle g1187 g-formula nil)
;; (toggle g1188 g-formula-defun nil)
;; (defun g-formula-ind
;;       (exp symbols va n)
;;       (if (zerop n)
;;           t
;;           (and (g-formula-ind (g-arg 0 (pr-quote 0) 2)
;;                               1
;;                               (ev 1 (list exp symbols) va (fa) n)
;;                               (sub1 n))
;;                (g-formula-ind (g-arg 0 (pr-quote 0) 3)
;;                               1
;;                               (ev 1 (list exp symbols) va (fa) n)
;;                               (sub1 n))
;;                (g-formula-ind (g-arg 0 (pr-quote 1) 3)
;;                               1
;;                               (ev 1 (list exp symbols) va (fa) n)
;;                               (sub1 n))
;;                (g-formula-ind (g-arg 0 (pr-quote 1) 4)
;;                               1
;;                               (ev 1 (list exp symbols) va (fa) n)
;;                               (sub1 n)))))
;; (toggle g1189 difference-sub1-n nil)
;; (toggle g1190 difference-<2 nil)
;; (toggle g1191 fa nil)
;; (toggle g1192 get-sub1-n-nzerop nil)
;; (toggle g1193 difference-< nil)
;; (defthm get-g-formula-defun (equal (get (sub1-n 22 11) (fa)) (g-formula-defn)))
;; (toggle g1194 difference-sub1-n t)
;; (toggle g1195 difference-<2 t)
;; (toggle g1196 fa t)
;; (toggle g1197 get-sub1-n-nzerop t)
;; (toggle g1198 difference-< t)
;; (defthm g-formula-eval

;;              (equal (ev 0 (g-formula exp symbols) va (fa) n)
;;                     (g-formulan (ev 0 exp va (fa) n) (ev 0 symbols va (fa) n) n))
;;              ((induct (g-formula-ind exp symbols va n))))
;; (defun formula-ind
;;       (exp symbols n)
;;       (if (zerop n)
;;           t
;;           (if (f-notp exp)
;;               (formula-ind (arg exp) symbols (sub1 n))
;;               (if (f-orp exp)
;;                   (and (formula-ind (arg1 exp) symbols (sub1 n))
;;                        (formula-ind (arg2 exp) symbols (sub1 n)))
;;                   (if (forsomep exp) (formula-ind (g-body exp) symbols (sub1 n)) t)))))
;; (defun formula-cnt
;;       (exp symbols)
;;       (if (f-notp exp)
;;           (add1 (formula-cnt (arg exp) symbols))
;;           (if (f-orp exp)
;;               (add1 (plus (formula-cnt (arg1 exp) symbols) (formula-cnt (arg2 exp) symbols)))
;;               (if (forsomep exp)
;;                   (add1 (formula-cnt (g-body exp) symbols))
;;                   (add1 (termp-cnt (cdr exp) 1 symbols))))))
;; (defthm g-formulan-gcode

;;              (implies (< (formula-cnt exp symbols) n)
;;                       (equal (g-formulan (gcode exp) (gcode symbols) n)
;;                              (bool-fix (g-formula exp symbols))))
;;              ((disable gcode atomp atomp-reduc) (induct (formula-ind exp symbols n))))
;; (toggle g1199 g-formula t)
;; (toggle g1200 g-formulan t)
;; (toggle g1201 g-formula-defun t)
;; (toggle g1202 formula-cnt t)
;; ;; correspondence between g-pairequals, g-pairequalsn, and pairequals.
;; (defun g-pairequalsn
;;       (vars1 vars2 exp n)
;;       (if (or (btmp vars1)
;;               (btmp vars2)
;;               (btmp exp)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-andn (g-typepn vars1 1) (g-typepn vars2 1))
;;                   (g-f-impliesn (g-f-equaln (g-carn vars1) (g-carn vars2))
;;                                 (g-pairequalsn (g-cdrn vars1) (g-cdrn vars2) exp (sub1 n)))
;;                   exp)))
;; (toggle g1203 g-pairequals nil)
;; (toggle g1204 g-pairequals-defun nil)
;; (defun g-pairequals-ind
;;       (vars1 vars2 exp va n)
;;       (if (zerop n)
;;           t
;;           (g-pairequals-ind (g-cdr 0)
;;                             (g-cdr 1)
;;                             2
;;                             (ev 1 (list vars1 vars2 exp) va (fa) n)
;;                             (sub1 n))))
;; (defthm g-pairequals-eval

;;              (equal (ev 0 (g-pairequals vars1 vars2 exp) va (fa) n)
;;                     (g-pairequalsn (ev 0 vars1 va (fa) n)
;;                                    (ev 0 vars2 va (fa) n)
;;                                    (ev 0 exp va (fa) n)
;;                                    n))
;;              ((induct (g-pairequals-ind vars1 vars2 exp va n))))
;; (toggle g1205 pairequals-reduc t)
;; (defun pairequals-ind
;;       (vars1 vars2 exp n)
;;       (if (zerop n)
;;           t
;;           (if (and (consp vars1)
;;                    (consp vars2))
;;               (pairequals-ind (cdr vars1) (cdr vars2) exp (sub1 n))
;;               t)))
;; (defthm g-pairequalsn-gcode

;;              (implies (< (length vars1) n)
;;                       (equal (g-pairequalsn (gcode vars1) (gcode vars2) (gcode exp) n)
;;                              (gcode (pairequals vars1 vars2 exp))))
;;              ((disable gcode) (induct (pairequals-ind vars1 vars2 exp n))))
;; (toggle g1206 g-pairequals t)
;; (toggle g1207 g-pairequalsn t)
;; (toggle g1208 g-pairequals-defun t)
;; (defun g-cadrn (x) (g-carn (g-cdrn x)))
;; (defun g-caddrn (x) (g-carn (g-cdrn (g-cdrn x))))
;; (defun g-cadddrn (x) (g-carn (g-cdrn (g-cdrn (g-cdrn x)))))
;; ;; subst-axiom correspondence.
;; (defn
;;  g-subst-axiom-proofn
;;  (conc hints symbols n)
;;  (pr-andn (g-formulan (g-cadrn hints) symbols n)
;;           (pr-andn (g-variablen (g-caddrn hints))
;;                    (pr-andn (g-termpn (g-cadddrn hints) (gcode 0) symbols n)
;;                             (pr-andn (g-free-forn (g-cadrn hints)
;;                                                   (g-caddrn hints)
;;                                                   (g-cadddrn hints)
;;                                                   (gcode 0)
;;                                                   n)
;;                                      (pr-equaln conc
;;                                                 (g-f-impliesn (g-substn (g-cadrn hints)
;;                                                                         (g-caddrn hints)
;;                                                                         (g-cadddrn hints)
;;                                                                         (gcode 0)
;;                                                                         n)
;;                                                               (g-forsomen (g-caddrn hints)
;;                                                                           (g-cadrn hints)))))))))
;; (defun g-degreen (x) (g-fixn (g-cdrn (g-cdrn x))))
;; ;; function equality axiom correspondence.
;; (defn
;;  g-fun-equal-axiom-proofn
;;  (conc hints symbols n)
;;  (pr-andn
;;   (g-termpn (g-caddrn hints) (gcode 1) symbols n)
;;   (pr-andn
;;    (g-termpn (g-cadddrn hints) (gcode 1) symbols n)
;;    (pr-andn
;;     (g-functionn (g-cadrn hints))
;;     (pr-andn (pr-equaln (g-lengthn (g-caddrn hints) n) (g-degreen (g-cadrn hints)))
;;              (pr-andn (pr-equaln (g-lengthn (g-cadddrn hints) n) (g-degreen (g-cadrn hints)))
;;                       (pr-equaln conc
;;                                  (g-pairequalsn (g-caddrn hints)
;;                                                 (g-cadddrn hints)
;;                                                 (g-f-equaln (g-consn (g-cadrn hints)
;;                                                                      (g-caddrn hints))
;;                                                             (g-consn (g-cadrn hints)
;;                                                                      (g-cadddrn hints)))
;;                                                 n))))))))
;; ;; predicate equality axiom correspondence.
;; (defn
;;  g-pred-equal-axiom-proofn
;;  (conc hints symbols n)
;;  (pr-andn
;;   (g-termpn (g-caddrn hints) (gcode 1) symbols n)
;;   (pr-andn
;;    (g-termpn (g-cadddrn hints) (gcode 1) symbols n)
;;    (pr-andn
;;     (g-predicaten (g-cadrn hints))
;;     (pr-andn (pr-equaln (g-lengthn (g-caddrn hints) n) (g-degreen (g-cadrn hints)))
;;              (pr-andn (pr-equaln (g-lengthn (g-cadddrn hints) n) (g-degreen (g-cadrn hints)))
;;                       (pr-equaln conc
;;                                  (g-pairequalsn (g-caddrn hints)
;;                                                 (g-cadddrn hints)
;;                                                 (g-f-impliesn (g-consn (g-cadrn hints)
;;                                                                        (g-caddrn hints))
;;                                                               (g-consn (g-cadrn hints)
;;                                                                        (g-cadddrn hints)))
;;                                                 n))))))))
;; ;; correspondence for fol-axiom-proof.
;; (defun g-fol-axiom-proofn
;;       (conc hints symbols n)
;;       (pr-ifn (pr-equaln (g-carn hints) (gcode 1))
;;               (pr-andn (g-formulan (g-cadrn hints) symbols n)
;;                        (pr-equaln conc (g-f-orn (g-f-notn (g-cadrn hints)) (g-cadrn hints))))
;;               (pr-ifn (pr-equaln (g-carn hints) (gcode 2))
;;                       (g-subst-axiom-proofn conc hints symbols n)
;;                       (pr-ifn (pr-equaln (g-carn hints) (gcode 3))
;;                               (pr-andn (g-termpn (g-cadrn hints) (gcode 0) symbols n)
;;                                        (pr-equaln conc
;;                                                   (g-f-equaln (g-cadrn hints) (g-cadrn hints))))
;;                               (pr-ifn (pr-equaln (g-carn hints) (gcode 4))
;;                                       (g-fun-equal-axiom-proofn conc hints symbols n)
;;                                       (pr-ifn (pr-equaln (g-carn hints) (gcode 5))
;;                                               (g-pred-equal-axiom-proofn conc hints symbols n)
;;                                               (bool-fix nil)))))))
;; (defthm g-fol-axiom-proof-eval

;;              (equal (ev 0 (g-fol-axiom-proof conc hints symbols) va (fa) n)
;;                     (g-fol-axiom-proofn (ev 0 conc va (fa) n)
;;                                         (ev 0 hints va (fa) n)
;;                                         (ev 0 symbols va (fa) n)
;;                                         n)))
;; (defun fol-axiom-cnt
;;       (hints symbols)
;;       (add1 (plus (formula-cnt (second hints) symbols)
;;                   (termp-cnt (fourth hints) 0 symbols)
;;                   (exp-count (second hints))
;;                   (exp-count (fourth hints))
;;                   (termp-cnt (second hints) 0 symbols)
;;                   (termp-cnt (third hints) 1 symbols)
;;                   (termp-cnt (fourth hints) 1 symbols)
;;                   (length (third hints))
;;                   (length (fourth hints)))))
;; (toggle g1213 fol-axiom-proof nil)
;; (defthm g-fol-axiom-proofn-gcode

;;              (implies (< (fol-axiom-cnt hints symbols) n)
;;                       (equal (g-fol-axiom-proofn (gcode conc) (gcode hints) (gcode symbols) n)
;;                              (bool-fix (fol-axiom-proof conc hints symbols))))
;;              ((disable gcode free-for)))
;; (toggle g1214 g-fol-axiom-proof t)
;; (toggle g1215 g-fol-axiom-proofn t)
;; (toggle g1216 fol-axiom-proof t)
;; (defun g-expan-rulen
;;       (conc hints sub-goals symbols n)
;;       (pr-andn (g-formulan (g-cadrn hints) symbols n)
;;                (pr-andn (g-formulan (g-carn sub-goals) symbols n)
;;                         (pr-equaln conc (g-f-orn (g-cadrn hints) (g-carn sub-goals))))))
;; (defun g-contrac-rulen
;;       (conc hints sub-goals symbols n)
;;       (pr-andn (g-formulan (g-cadrn hints) symbols n)
;;                (pr-andn (pr-equaln sub-goals
;;                                    (g-consn (g-f-orn (g-cadrn hints) (g-cadrn hints))
;;                                             (gcode nil)))
;;                         (pr-equaln conc (g-cadrn hints)))))
;; (defn
;;  g-assoc-rulen
;;  (conc hints sub-goals symbols n)
;;  (pr-andn (g-formulan (g-cadrn hints) symbols n)
;;           (pr-andn (g-formulan (g-caddrn hints) symbols n)
;;                    (pr-andn (g-formulan (g-cadddrn hints) symbols n)
;;                             (pr-andn (pr-equaln sub-goals
;;                                                 (g-consn (g-f-orn (g-cadrn hints)
;;                                                                   (g-f-orn (g-caddrn hints)
;;                                                                            (g-cadddrn hints)))
;;                                                          (gcode nil)))
;;                                      (pr-equaln conc
;;                                                 (g-f-orn (g-f-orn (g-cadrn hints)
;;                                                                   (g-caddrn hints))
;;                                                          (g-cadddrn hints))))))))
;; (defn
;;  g-cut-rulen
;;  (conc hints sub-goals symbols n)
;;  (pr-andn
;;   (g-formulan (g-cadrn hints) symbols n)
;;   (pr-andn (g-formulan (g-caddrn hints) symbols n)
;;            (pr-andn (g-formulan (g-cadddrn hints) symbols n)
;;                     (pr-andn (pr-equaln sub-goals
;;                                         (g-consn (g-f-orn (g-cadrn hints) (g-caddrn hints))
;;                                                  (g-consn (g-f-orn (g-f-notn (g-cadrn hints))
;;                                                                    (g-cadddrn hints))
;;                                                           (gcode nil))))
;;                              (pr-equaln conc (g-f-orn (g-caddrn hints) (g-cadddrn hints))))))))
;; (defn
;;  g-forsome-intro-rulen
;;  (conc hints sub-goals symbols n)
;;  (pr-andn
;;   (g-variablen (g-cadrn hints))
;;   (pr-andn (g-formulan (g-caddrn hints) symbols n)
;;            (pr-andn (g-formulan (g-cadddrn hints) symbols n)
;;                     (pr-andn (pr-notn (g-membn (g-cadrn hints)
;;                                                (g-collect-freen (g-cadddrn hints) (gcode 0) n)
;;                                                n))
;;                              (pr-andn (pr-equaln sub-goals
;;                                                  (g-consn (g-f-impliesn (g-caddrn hints)
;;                                                                         (g-cadddrn hints))
;;                                                           (gcode nil)))
;;                                       (pr-equaln conc
;;                                                  (g-f-impliesn (g-forsomen (g-cadrn hints)
;;                                                                            (g-caddrn hints))
;;                                                                (g-cadddrn hints)))))))))
;; ;; correspondence for fol-rules.
;; (defun g-fol-rulesn
;;       (conc hints sub-goals symbols n)
;;       (pr-ifn (pr-equaln (g-carn hints) (gcode 1))
;;               (g-expan-rulen conc hints sub-goals symbols n)
;;               (pr-ifn (pr-equaln (g-carn hints) (gcode 2))
;;                       (g-contrac-rulen conc hints sub-goals symbols n)
;;                       (pr-ifn (pr-equaln (g-carn hints) (gcode 3))
;;                               (g-assoc-rulen conc hints sub-goals symbols n)
;;                               (pr-ifn (pr-equaln (g-carn hints) (gcode 4))
;;                                       (g-cut-rulen conc hints sub-goals symbols n)
;;                                       (pr-ifn (pr-equaln (g-carn hints) (gcode 5))
;;                                               (g-forsome-intro-rulen conc
;;                                                                      hints
;;                                                                      sub-goals
;;                                                                      symbols
;;                                                                      n)
;;                                               (bool-fix nil)))))))
;; (toggle g1217 g-fol-rules nil)
;; (defthm g-fol-rules-eval

;;              (equal (ev 0 (g-fol-rules conc hints sub-goals symbols) va (fa) n)
;;                     (g-fol-rulesn (ev 0 conc va (fa) n)
;;                                   (ev 0 hints va (fa) n)
;;                                   (ev 0 sub-goals va (fa) n)
;;                                   (ev 0 symbols va (fa) n)
;;                                   n)))
;; (toggle g1218 g-fol-rules t)
;; (toggle g1219 fol-rules nil)
;; (defthm g-fol-rulesn-gcode

;;              (implies (< (plus (formula-cnt (second hints) symbols)
;;                                    (formula-cnt (third hints) symbols)
;;                                    (formula-cnt (fourth hints) symbols)
;;                                    (formula-cnt (car sub-goals) symbols)
;;                                    (exp-count (fourth hints)))
;;                              n)
;;                       (equal (g-fol-rulesn (gcode conc)
;;                                            (gcode hints)
;;                                            (gcode sub-goals)
;;                                            (gcode symbols)
;;                                            n)
;;                              (bool-fix (fol-rules conc hints sub-goals symbols))))
;;              ((disable gcode)))
;; (toggle g1220 fol-rules t)
;; (toggle g1221 g-fol-rules t)
;; (toggle g1222 g-fol-rulesn t)
;; (defun g-isinn
;;       (x y)
;;       (g-consn (g-consn (gcode 3) (g-consn (gcode 1) (gcode 2)))
;;                (g-consn x (g-consn y (gcode nil)))))
;; (defun g-phin nil (g-consn (g-consn (gcode 2) (g-consn (gcode 0) (gcode 0))) (gcode nil)))
;; (defun g-z-pairn
;;       (x y)
;;       (g-consn (g-consn (gcode 2) (g-consn (gcode 1) (gcode 2)))
;;                (g-consn x (g-consn y (gcode nil)))))
;; (defun g-z-unionn
;;       (x y)
;;       (g-consn (g-consn (gcode 2) (g-consn (gcode 2) (gcode 2)))
;;                (g-consn x (g-consn y (gcode nil)))))
;; (defun g-z-intn
;;       (x)
;;       (g-consn (g-consn (gcode 3) (g-consn (gcode 2) (gcode 1))) (g-consn x (gcode nil))))
;; (defun g-z-succn
;;       (x)
;;       (g-consn (g-consn (gcode 2) (g-consn (gcode 3) (gcode 1))) (g-consn x (gcode nil))))
;; (defun g-f-iffn (x y) (g-f-andn (g-f-impliesn x y) (g-f-impliesn y x)))
;; (defthm g-f-iff-eval

;;              (equal (ev 0 (g-f-iff x y) va fa n) (g-f-iffn (ev 0 x va fa n) (ev 0 y va fa n))))
;; (toggle g1223 f-iff nil)
;; (defthm g-f-iffn-gcode

;;              (equal (g-f-iffn (gcode x) (gcode y)) (gcode (f-iff x y)))
;;              ((disable gcode)))
;; (toggle g1224 f-iff t)
;; (toggle g1225 g-f-iff t)
;; (toggle g1226 g-f-iffn t)
;; ;; correspondence for z2-axioms.
;; (defn
;;  g-z2-axiomsn
;;  (conc hints symbols n)
;;  (pr-ifn
;;   (pr-equaln (g-carn hints) (gcode 1))
;;   (pr-andn
;;    (g-variablen (g-cadddrn hints))
;;    (pr-andn
;;     (g-termpn (g-cadrn hints) (gcode 0) symbols n)
;;     (pr-andn
;;      (g-termpn (g-caddrn hints) (gcode 0) symbols n)
;;      (pr-andn
;;       (pr-notn (g-membn (g-cadddrn hints) (g-collect-freen (g-cadrn hints) (gcode 0) n) n))
;;       (pr-andn (pr-notn (g-membn (g-cadddrn hints)
;;                                  (g-collect-freen (g-caddrn hints) (gcode 0) n)
;;                                  n))
;;                (pr-equaln conc
;;                           (g-f-iffn (g-f-equaln (g-cadrn hints) (g-caddrn hints))
;;                                     (g-foralln (g-cadddrn hints)
;;                                                (g-f-iffn (g-isinn (g-cadddrn hints)
;;                                                                   (g-cadrn hints))
;;                                                          (g-isinn (g-cadddrn hints)
;;                                                                   (g-caddrn hints)))))))))))
;;   (pr-ifn
;;    (pr-equaln (g-carn hints) (gcode 2))
;;    (pr-andn (g-termpn (g-cadrn hints) (gcode 0) symbols n)
;;             (pr-equaln conc (g-f-notn (g-isinn (g-cadrn hints) (g-phin)))))
;;    (pr-ifn
;;     (pr-equaln (g-carn hints) (gcode 3))
;;     (pr-andn (g-termpn (g-consn (g-cadrn hints)
;;                                 (g-consn (g-caddrn hints)
;;                                          (g-consn (g-cadddrn hints) (gcode nil))))
;;                        (gcode 1)
;;                        symbols
;;                        n)
;;              (pr-equaln conc
;;                         (g-f-iffn (g-isinn (g-cadddrn hints)
;;                                            (g-z-pairn (g-cadrn hints) (g-caddrn hints)))
;;                                   (g-f-orn (g-f-equaln (g-cadddrn hints) (g-cadrn hints))
;;                                            (g-f-equaln (g-cadddrn hints) (g-caddrn hints))))))
;;     (pr-ifn
;;      (pr-equaln (g-carn hints) (gcode 4))
;;      (pr-andn (g-termpn (g-consn (g-cadrn hints)
;;                                  (g-consn (g-caddrn hints)
;;                                           (g-consn (g-cadddrn hints) (gcode nil))))
;;                         (gcode 1)
;;                         symbols
;;                         n)
;;               (pr-equaln conc
;;                          (g-f-iffn (g-isinn (g-cadddrn hints)
;;                                             (g-z-unionn (g-cadrn hints) (g-caddrn hints)))
;;                                    (g-f-orn (g-isinn (g-cadddrn hints) (g-cadrn hints))
;;                                             (g-isinn (g-cadddrn hints) (g-caddrn hints))))))
;;      (pr-ifn
;;       (pr-equaln (g-carn hints) (gcode 5))
;;       (pr-andn
;;        (g-variablen (g-caddrn hints))
;;        (pr-andn
;;         (g-formulan (g-cadrn hints) symbols n)
;;         (pr-equaln
;;          conc
;;          (g-f-impliesn
;;           (g-f-andn (g-substn (g-cadrn hints) (g-caddrn hints) (g-phin) (gcode 0) n)
;;                     (g-foralln (g-caddrn hints)
;;                                (g-f-impliesn (g-f-andn (g-z-intn (g-caddrn hints))
;;                                                        (g-cadrn hints))
;;                                              (g-substn (g-cadrn hints)
;;                                                        (g-caddrn hints)
;;                                                        (g-z-succn (g-caddrn hints))
;;                                                        (gcode 0)
;;                                                        n))))
;;           (g-foralln (g-caddrn hints)
;;                      (g-f-impliesn (g-z-intn (g-caddrn hints)) (g-cadrn hints)))))))
;;       (bool-fix nil)))))))
;; (toggle g1238 g-z2-axioms nil)
;; (defthm g-z2-axioms-eval

;;              (equal (ev 0 (g-z2-axioms conc hints symbols) va (fa) n)
;;                     (g-z2-axiomsn (ev 0 conc va (fa) n)
;;                                   (ev 0 hints va (fa) n)
;;                                   (ev 0 symbols va (fa) n)
;;                                   n)))
;; (toggle g1239 p nil)
;; (toggle g1240 fn nil)
;; (toggle g1241 isin nil)
;; (toggle g1242 phi nil)
;; (toggle g1243 z-pair nil)
;; (toggle g1244 z-union nil)
;; (toggle g1245 z-int nil)
;; (toggle g1246 z-succ nil)
;; (toggle g1247 g-z2-axioms t)
;; (defun z2-axioms-cnt
;;       (hints symbols)
;;       (plus (termp-cnt (second hints) 0 symbols)
;;             (termp-cnt (third hints) 0 symbols)
;;             (exp-count (second hints))
;;             (exp-count (third hints))
;;             (termp-cnt (list (second hints) (third hints) (fourth hints)) 1 symbols)
;;             (formula-cnt (second hints) symbols)))
;; (defthm g-z2-axiomsn-gcode

;;              (implies (< (plus (termp-cnt (second hints) 0 symbols)
;;                                    (termp-cnt (third hints) 0 symbols)
;;                                    (exp-count (second hints))
;;                                    (exp-count (third hints))
;;                                    (termp-cnt (list (second hints) (third hints) (fourth hints))
;;                                               1
;;                                               symbols)
;;                                    (formula-cnt (second hints) symbols))
;;                              n)
;;                       (equal (g-z2-axiomsn (gcode conc) (gcode hints) (gcode symbols) n)
;;                              (bool-fix (z2-axioms conc hints symbols))))
;;              ((disable gcode)))
;; (toggle g1248 fn t)
;; (toggle g1249 isin t)
;; (toggle g1250 phi t)
;; (toggle g1251 z-pair t)
;; (toggle g1252 z-union t)
;; (toggle g1253 z-int t)
;; (toggle g1254 z-succ t)
;; (toggle g1255 g-z2-axioms t)
;; (toggle g1256 g-z2-axiomsn t)
;; (toggle g1257 z2-axioms t)
;; ;; correspondence for set.
;; (defun g-setn
;;       (x n)
;;       (if (or (btmp x)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-typepn x 1)
;;                   (pr-andn (pr-notn (g-membn (g-carn x) (g-cdrn x) (sub1 n)))
;;                            (g-setn (g-cdrn x) (sub1 n)))
;;                   (bool-fix t))))
;; (toggle g1258 g-set nil)
;; (toggle g1259 g-set-defun nil)
;; (defun g-set-ind (x va n) (if (zerop n) t (g-set-ind (g-cdr 0) (ev 1 (list x) va (fa) n) (sub1 n))))
;; (defthm g-set-eval

;;              (equal (ev 0 (g-set x) va (fa) n) (g-setn (ev 0 x va (fa) n) n))
;;              ((induct (g-set-ind x va n))))
;; (defthm g-setn-gcode

;;              (implies (< (length x) n) (equal (g-setn (gcode x) n) (bool-fix (g-set x))))
;;              ((disable gcode) (induct (appendn-ind x y n))))
;; (toggle g1260 g-set t)
;; (toggle g1261 g-setn t)
;; (toggle g1262 g-set-defun t)
;; ;; correspondence for assoc.
;; (defun g-assocn
;;       (x y n)
;;       (if (or (btmp x)
;;               (btmp y)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-typepn y 1)
;;                   (pr-ifn (pr-equaln (g-carn (g-carn y)) x)
;;                           (g-cdrn (g-carn y))
;;                           (g-assocn x (g-cdrn y) (sub1 n)))
;;                   (gcode 0))))
;; (toggle g1265 g-assoc-defun nil)
;; (defun g-assoc-ind
;;       (x y va n)
;;       (if (zerop n) t (g-assoc-ind 0 (g-cdr 1) (ev 1 (list x y) va (fa) n) (sub1 n))))
;; (defthm g-assoc-eval

;;              (equal (ev 0 (g-assoc x y) va (fa) n)
;;                     (g-assocn (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-assoc-ind x y va n))))
;; (defthm g-assocn-gcode

;;              (implies (< (length y) n)
;;                       (equal (g-assocn (gcode x) (gcode y) n) (gcode (assoc x y))))
;;              ((induct (appendn-ind y x n))))
;; (toggle g1266 g-assoc t)
;; (toggle g1267 g-assocn t)
;; (toggle g1268 g-assoc-defun t)
;; ;; correspondence for conc.
;; (defun g-concn
;;       (pf flg n)
;;       (if (or (btmp pf)
;;               (btmp flg)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-zeropn flg)
;;                   (g-caddrn pf)
;;                   (pr-ifn (g-typepn pf 1)
;;                           (g-consn (g-concn (g-carn pf) (gcode 0) (sub1 n))
;;                                    (g-concn (g-cdrn pf) (gcode 1) (sub1 n)))
;;                           (gcode nil)))))
;; (toggle g1269 g-conc nil)
;; (toggle g1270 g-conc-defun nil)
;; (defun g-conc-ind
;;       (pf flg va n)
;;       (if (zerop n)
;;           t
;;           (and (g-conc-ind (g-car 0) (pr-quote 0) (ev 1 (list pf flg) va (fa) n) (sub1 n))
;;                (g-conc-ind (g-cdr 0) (pr-quote 1) (ev 1 (list pf flg) va (fa) n) (sub1 n)))))
;; (defthm g-conc-eval

;;              (equal (ev 0 (g-conc pf flg) va (fa) n)
;;                     (g-concn (ev 0 pf va (fa) n) (ev 0 flg va (fa) n) n))
;;              ((induct (g-conc-ind pf flg va n))))
;; (defun conc-ind
;;       (pf flg n)
;;       (if (zerop n)
;;           t
;;           (if (zerop flg)
;;               t
;;               (and (conc-ind (car pf) 0 (sub1 n))
;;                    (conc-ind (cdr pf) 1 (sub1 n))))))
;; (defthm g-concn-gcode

;;              (implies (< (exp-count pf) n)
;;                       (equal (g-concn (gcode pf) (gcode flg) n) (gcode (conc pf flg))))
;;              ((disable gcode) (induct (conc-ind pf flg n))))
;; (toggle g1271 g-conc t)
;; (toggle g1272 g-concn t)
;; (toggle g1273 g-conc-defun t)
;; ;; correspondence for rest-of.
;; (defun g-rest-ofn
;;       (sym symbols n)
;;       (if (or (btmp sym)
;;               (btmp symbols)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-typepn symbols 1)
;;                   (pr-ifn (pr-andn (pr-equaln (g-carn symbols) sym)
;;                                    (pr-notn (g-membn sym (g-cdrn symbols) (sub1 n))))
;;                           (g-cdrn symbols)
;;                           (g-rest-ofn sym (g-cdrn symbols) (sub1 n)))
;;                   (gcode nil))))
;; (toggle g1274 g-rest-of nil)
;; (toggle g1275 g-rest-of-defun nil)
;; (defun g-rest-of-ind
;;       (sym symbols va n)
;;       (if (zerop n) t (g-rest-of-ind 0 (g-cdr 1) (ev 1 (list sym symbols) va (fa) n) (sub1 n))))
;; (defthm g-rest-of-eval

;;              (equal (ev 0 (g-rest-of sym symbols) va (fa) n)
;;                     (g-rest-ofn (ev 0 sym va (fa) n) (ev 0 symbols va (fa) n) n))
;;              ((induct (g-rest-of-ind sym symbols va n))))
;; (toggle g1276 rest-of nil)
;; (defthm g-rest-ofn-gcode

;;              (implies (< (add1 (length symbols)) n)
;;                       (equal (g-rest-ofn (gcode sym) (gcode symbols) n)
;;                              (gcode (rest-of sym symbols))))
;;              ((disable gcode) (induct (appendn-ind symbols sym n))))
;; (toggle g1277 rest-of t)
;; (toggle g1278 g-rest-of t)
;; (toggle g1279 g-rest-ofn t)
;; (toggle g1280 g-rest-of-defun t)
;; (toggle g1281 g-symb-defn-proof nil)
;; ;; correspondence for symb-defn-proof.
;; (defn
;;  g-symb-defn-proofn
;;  (conc hints sub-goals defun symbols n)
;;  (pr-ifn
;;   (g-predicaten (g-carn (g-carn hints)))
;;   (pr-andn (g-setn (g-cdrn (g-carn hints)) n)
;;            (pr-andn (g-var-listn (g-cdrn (g-carn hints)) (g-degreen (g-carn (g-carn hints))) n)
;;                     (pr-andn (pr-equaln conc (g-f-iffn (g-carn hints) defn))
;;                              (pr-andn (g-subn (g-collect-freen defun (gcode 0) n)
;;                                               (g-cdrn (g-carn hints))
;;                                               n)
;;                                       (g-formulan defn
;;                                                   (g-rest-ofn (g-carn (g-carn hints))
;;                                                               symbols
;;                                                               n)
;;                                                   n)))))
;;   (pr-ifn
;;    (g-functionn (g-carn (g-carn hints)))
;;    (pr-andn
;;     (g-setn (g-consn (g-cadddrn hints) (g-consn (g-cadrn hints) (g-cdrn (g-carn hints)))) n)
;;     (pr-andn
;;      (g-var-listn (g-cdrn (g-carn hints)) (g-degreen (g-carn (g-carn hints))) n)
;;      (pr-andn
;;       (g-variablen (g-cadrn hints))
;;       (pr-andn
;;        (g-variablen (g-cadddrn hints))
;;        (pr-andn
;;         (g-formulan (g-caddrn hints) (g-rest-ofn (g-carn (g-carn hints)) symbols n) n)
;;         (pr-andn
;;          (g-subn (g-collect-freen (g-caddrn hints) (gcode 0) n)
;;                  (g-consn (g-cadrn hints) (g-cdrn (g-carn hints)))
;;                  n)
;;          (pr-andn
;;           (g-free-forn (g-caddrn hints) (g-cadrn hints) (g-carn hints) (gcode 0) n)
;;           (pr-andn
;;            (g-free-forn (g-caddrn hints) (g-cadrn hints) (g-cadddrn hints) (gcode 0) n)
;;            (pr-andn
;;             (pr-equaln conc
;;                        (g-substn (g-caddrn hints)
;;                                  (g-cadrn hints)
;;                                  (g-carn hints)
;;                                  (gcode 0)
;;                                  n))
;;             (pr-andn
;;              (pr-equaln conc defn)
;;              (pr-equaln
;;               sub-goals
;;               (g-consn (g-forsomen (g-cadrn hints) (g-caddrn hints))
;;                        (g-consn (g-f-impliesn (g-f-andn (g-caddrn hints)
;;                                                         (g-substn (g-caddrn hints)
;;                                                                   (g-cadrn hints)
;;                                                                   (g-cadddrn hints)
;;                                                                   (gcode 0)
;;                                                                   n))
;;                                               (g-f-equaln (g-cadrn hints)
;;                                                           (g-cadddrn hints)))
;;                                 (gcode nil))))))))))))))
;;    (bool-fix nil))))
;; (defthm g-symb-defn-proof-eval

;;              (equal (ev 0 (g-symb-defn-proof conc hints sub-goals defun symbols) va (fa) n)
;;                     (g-symb-defn-proofn (ev 0 conc va (fa) n)
;;                                         (ev 0 hints va (fa) n)
;;                                         (ev 0 sub-goals va (fa) n)
;;                                         (ev 0 defun va (fa) n)
;;                                         (ev 0 symbols va (fa) n)
;;                                         n)))
;; (defthm lazy-pr-andn-reduc3

;;              (equal (pr-andn (bool-fix x) (bool-fix nil)) (bool-fix nil)))
;; (defun g-symb-count
;;       (hints defun symbols)
;;       (if (predicate (caar hints))
;;           (plus (length (cdar hints))
;;                 (cddaar hints)
;;                 (exp-count defn)
;;                 (add1 (length symbols))
;;                 (formula-cnt defun (rest-of (caar hints) symbols)))
;;           (plus (length (cons (fourth hints) (cons (second hints) (cdar hints))))
;;                 (add1 (length symbols))
;;                 (formula-cnt (third hints) (rest-of (caar hints) symbols))
;;                 (cddaar hints)
;;                 (add1 (exp-count (third hints)))
;;                 (add1 (exp-count (second hints)))
;;                 (add1 (exp-count (car hints)))
;;                 (add1 (exp-count (fourth hints))))))
;; (defthm g-symb-defn-proofn-gcode

;;              (implies (< (g-symb-count hints defun symbols) n)
;;                       (equal (g-symb-defn-proofn (gcode conc)
;;                                                  (gcode hints)
;;                                                  (gcode sub-goals)
;;                                                  (gcode defn)
;;                                                  (gcode symbols)
;;                                                  n)
;;                              (bool-fix (symb-defn-proof conc hints sub-goals defun symbols))))
;;              ((disable gcode)))
;; (toggle g1290 symb-defn-proof t)
;; (toggle g1291 g-symb-defn-proof t)
;; (toggle g1292 g-symb-defn-proofn t)
;; ;; correspondence for prf.
;; (defn
;;  g-prfn
;;  (pf given defns flg symbols n)
;;  (if
;;   (or (zerop n)
;;       (btmp pf)
;;       (btmp given)
;;       (btmp defns)
;;       (btmp flg)
;;       (btmp symbols))
;;   (btm)
;;   (pr-ifn
;;    (pr-zeropn flg)
;;    (pr-ifn
;;     (g-typepn pf 1)
;;     (pr-ifn
;;      (pr-notn (g-formulan (g-concn pf (gcode 0) (sub1 n)) symbols (sub1 n)))
;;      (bool-fix nil)
;;      (pr-ifn
;;       (pr-equaln (g-carn pf) (gcode 1))
;;       (g-fol-axiom-proofn (g-concn pf (gcode 0) (sub1 n)) (g-cadrn pf) symbols (sub1 n))
;;       (pr-ifn
;;        (pr-equaln (g-carn pf) (gcode 2))
;;        (pr-andn (g-fol-rulesn (g-concn pf (gcode 0) (sub1 n))
;;                               (g-cadrn pf)
;;                               (g-concn (g-cadddrn pf) (gcode 1) (sub1 n))
;;                               symbols
;;                               (sub1 n))
;;                 (g-prfn (g-cadddrn pf) given defns (gcode 1) symbols (sub1 n)))
;;        (pr-ifn (pr-equaln (g-carn pf) (gcode 3))
;;                (g-z2-axiomsn (g-concn pf (gcode 0) (sub1 n)) (g-cadrn pf) symbols (sub1 n))
;;                (pr-ifn (pr-equaln (g-carn pf) (gcode 4))
;;                        (pr-andn (g-symb-defn-proofn (g-concn pf (gcode 0) (sub1 n))
;;                                                     (g-cadrn pf)
;;                                                     (g-concn (g-cadddrn pf)
;;                                                              (gcode 1)
;;                                                              (sub1 n))
;;                                                     (g-assocn (g-carn (g-carn (g-cadrn pf)))
;;                                                               defns
;;                                                               (sub1 n))
;;                                                     symbols
;;                                                     (sub1 n))
;;                                 (pr-ifn (g-functionn (g-carn (g-carn (g-cadrn pf))))
;;                                         (g-prfn (g-cadddrn pf)
;;                                                 given
;;                                                 defns
;;                                                 (gcode 1)
;;                                                 (g-rest-ofn (g-carn (g-carn (g-cadrn pf)))
;;                                                             symbols
;;                                                             (sub1 n))
;;                                                 (sub1 n))
;;                                         (bool-fix t)))
;;                        (pr-ifn (pr-equaln (g-carn pf) (gcode 5))
;;                                (g-membn (g-concn pf (gcode 0) (sub1 n)) given (sub1 n))
;;                                (bool-fix nil)))))))
;;     (bool-fix nil))
;;    (pr-ifn (g-typepn pf 1)
;;            (pr-andn (g-prfn (g-carn pf) given defns (gcode 0) symbols (sub1 n))
;;                     (g-prfn (g-cdrn pf) given defns (gcode 1) symbols (sub1 n)))
;;            (bool-fix t)))))
;; (toggle g1293 g-prf-defun nil)
;; (defun g-prf-ind
;;       (pf given defns flg symbols va n)
;;       (if (zerop n)
;;           t
;;           (and (g-prf-ind (g-cadddr 0)
;;                           1
;;                           2
;;                           (pr-quote 1)
;;                           4
;;                           (ev 1 (list pf given defns flg symbols) va (fa) n)
;;                           (sub1 n))
;;                (g-prf-ind (g-cadddr 0)
;;                           1
;;                           2
;;                           (pr-quote 1)
;;                           (g-rest-of (g-car (g-car (g-cadr 0))) 4)
;;                           (ev 1 (list pf given defns flg symbols) va (fa) n)
;;                           (sub1 n))
;;                (g-prf-ind (g-car 0)
;;                           1
;;                           2
;;                           (pr-quote 0)
;;                           4
;;                           (ev 1 (list pf given defns flg symbols) va (fa) n)
;;                           (sub1 n))
;;                (g-prf-ind (g-cdr 0)
;;                           1
;;                           2
;;                           (pr-quote 1)
;;                           4
;;                           (ev 1 (list pf given defns flg symbols) va (fa) n)
;;                           (sub1 n)))))
;; (defthm g-prf-eval

;;              (equal (ev 0 (g-prf pf given defns flg symbols) va (fa) n)
;;                     (g-prfn (ev 0 pf va (fa) n)
;;                             (ev 0 given va (fa) n)
;;                             (ev 0 defns va (fa) n)
;;                             (ev 0 flg va (fa) n)
;;                             (ev 0 symbols va (fa) n)
;;                             n))
;;              ((induct (g-prf-ind pf given defns flg symbols va n))))
;; (toggle g1294 prf nil)
;; (toggle g1296 fol-axiom-cnt t)
;; (toggle g1297 fol-axiom-cnt t)
;; (defun fol-rules-cnt
;;       (hints sub-goals symbols)
;;       (plus (formula-cnt (second hints) symbols)
;;             (formula-cnt (third hints) symbols)
;;             (formula-cnt (fourth hints) symbols)
;;             (formula-cnt (car sub-goals) symbols)
;;             (exp-count (fourth hints))))
;; (defthm g-fol-rulesn-gcode1

;;              (implies (< (fol-rules-cnt hints sub-goals symbols) n)
;;                       (equal (g-fol-rulesn (gcode conc)
;;                                            (gcode hints)
;;                                            (gcode sub-goals)
;;                                            (gcode symbols)
;;                                            n)
;;                              (bool-fix (fol-rules conc hints sub-goals symbols))))
;;              ((disable gcode)))
;; (defun prf-cnt-part
;;       (pf symbols)
;;       (plus (add1 (formula-cnt (conc pf 0) symbols)) (add1 (exp-count pf))))
;; (toggle g1298 fol-rules-cnt t)
;; (defun prf-ind
;;       (pf given defns flg symbols n)
;;       (if (zerop n)
;;           t
;;           (if (zerop flg)
;;               (if (consp pf)
;;                   (if (not (g-formula (conc pf 0) symbols))
;;                       t
;;                       (if (equal (car pf) 1)
;;                           t
;;                           (if (equal (car pf) 2)
;;                               (prf-ind (cadddr pf) given defns 1 symbols (sub1 n))
;;                               (if (equal (car pf) 3)
;;                                   t
;;                                   (if (equal (car pf) 4)
;;                                       (prf-ind (cadddr pf)
;;                                                given
;;                                                defns
;;                                                1
;;                                                (rest-of (caar (cadr pf)) symbols)
;;                                                (sub1 n))
;;                                       t)))))
;;                   t)
;;               (if (consp pf)
;;                   (and (prf-ind (car pf) given defns 0 symbols (sub1 n))
;;                        (prf-ind (cdr pf) given defns 1 symbols (sub1 n)))
;;                   t))))
;; (toggle g1299 g-symb-count t)
;; (defthm g-z2-axiomsn-gcode1

;;              (implies (< (z2-axioms-cnt hints symbols) n)
;;                       (equal (g-z2-axiomsn (gcode conc) (gcode hints) (gcode symbols) n)
;;                              (bool-fix (z2-axioms conc hints symbols))))
;;              ((disable gcode)))
;; (toggle g1300 z2-axioms-cnt t)
;; (toggle g1301 g-z2-axiomsn-gcode t)
;; (toggle g1302 g-fol-rulesn-gcode t)
;; (defun prf-cnt
;;       (pf given defns flg symbols)
;;       (if (zerop flg)
;;           (if (consp pf)
;;               (if (not (g-formula (conc pf 0) symbols))
;;                   (prf-cnt-part pf symbols)
;;                   (if (equal (car pf) 1)
;;                       (plus (add1 (fol-axiom-cnt (second pf) symbols)) (prf-cnt-part pf symbols))
;;                       (if (equal (car pf) 2)
;;                           (plus (prf-cnt-part pf symbols)
;;                                 (add1 (fol-rules-cnt (second pf) (conc (cadddr pf) 1) symbols))
;;                                 (add1 (prf-cnt (cadddr pf) given defns 1 symbols)))
;;                           (if (equal (car pf) 3)
;;                               (plus (prf-cnt-part pf symbols)
;;                                     (add1 (z2-axioms-cnt (second pf) symbols)))
;;                               (if (equal (car pf) 4)
;;                                   (plus (prf-cnt-part pf symbols)
;;                                         (add1 (g-symb-count (second pf)
;;                                                             (assoc (caar (cadr pf)) defns)
;;                                                             symbols))
;;                                         (add1 (add1 (length symbols)))
;;                                         (add1 (length defns))
;;                                         (add1 (exp-count (fourth pf)))
;;                                         (add1 (prf-cnt (cadddr pf)
;;                                                        given
;;                                                        defns
;;                                                        1
;;                                                        (rest-of (caar (cadr pf)) symbols))))
;;                                   (plus (prf-cnt-part pf symbols) (add1 (length given))))))))
;;               (prf-cnt-part pf symbols))
;;           (if (consp pf)
;;               (add1 (plus (add1 (prf-cnt (car pf) given defns 0 symbols))
;;                           (add1 (prf-cnt (cdr pf) given defns 1 symbols))))
;;               (prf-cnt-part pf symbols))))
;; (defthm g-prfn-gcode

;;              (implies (< (prf-cnt pf given defns flg symbols) n)
;;                       (equal (g-prfn (gcode pf)
;;                                      (gcode given)
;;                                      (gcode defns)
;;                                      (gcode flg)
;;                                      (gcode symbols)
;;                                      n)
;;                              (bool-fix (prf pf given defns flg symbols))))
;;              ((disable gcode) (induct (prf-ind pf given defns flg symbols n))))
;; (toggle g1303 g-prf t)
;; (toggle g1304 g-prfn t)
;; (toggle g1305 g-prf-defun t)
;; (toggle g1306 prf-cnt t)
;; (toggle g1307 prf t)
;; ;; correspondence for proves.
;; (defun g-provesn
;;       (pf exp given defns symbols n)
;;       (pr-andn (pr-equaln (g-concn pf (gcode 0) n) exp)
;;                (pr-andn (g-formulan exp symbols n) (g-prfn pf given defns (gcode 0) symbols n))))
;; (toggle g1308 g-proves nil)
;; (defthm g-proves-eval

;;              (equal (ev 0 (g-proves pf exp given defns symbols) va (fa) n)
;;                     (g-provesn (ev 0 pf va (fa) n)
;;                                (ev 0 exp va (fa) n)
;;                                (ev 0 given va (fa) n)
;;                                (ev 0 defns va (fa) n)
;;                                (ev 0 symbols va (fa) n)
;;                                n)))
;; (toggle g1309 proves nil)
;; (defthm g-provesn-gcode

;;              (implies (< (plus (exp-count pf)
;;                                    (formula-cnt exp symbols)
;;                                    (prf-cnt pf given defns 0 symbols))
;;                              n)
;;                       (equal (g-provesn (gcode pf)
;;                                         (gcode exp)
;;                                         (gcode given)
;;                                         (gcode defns)
;;                                         (gcode symbols)
;;                                         n)
;;                              (bool-fix (proves pf exp given defns symbols))))
;;              ((disable gcode)))
;; (toggle g1310 proves t)
;; (toggle g1311 g-proves t)
;; (toggle g1312 g-provesn t)
;; ;; correspondence for numeral.
;; (defun g-numeraln
;;       (x n)
;;       (if (or (btmp x)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-zeropn x) (g-phin) (g-z-succn (g-numeraln (pr-sub1n x) (sub1 n))))))
;; (toggle g1313 g-numeral-defun nil)
;; (defun g-numeral-ind
;;       (x va n)
;;       (if (zerop n) t (g-numeral-ind (pr-sub1 0) (ev 1 (list x) va (fa) n) (sub1 n))))
;; (defthm g-numeral-eval

;;              (equal (ev 0 (g-numeral x) va (fa) n) (g-numeraln (ev 0 x va (fa) n) n))
;;              ((induct (g-numeral-ind x va n))))
;; (defun numeral-ind (x n) (if (zerop n) t (if (zerop x) t (numeral-ind (sub1 x) (sub1 n)))))
;; (toggle g1314 phi nil)
;; (toggle g1315 z-succ nil)
;; (toggle g1316 fn nil)
;; (defthm g-numeraln-gcode

;;              (implies (< x n) (equal (g-numeraln (gcode x) n) (gcode (numeral x))))
;;              ((disable gcode) (induct (numeral-ind x n))))
;; (toggle g1317 phi t)
;; (toggle g1318 z-succ t)
;; (toggle g1319 g-numeral t)
;; (toggle g1320 g-numeraln t)
;; (toggle g1321 g-numeral-defun t)
;; (defun g-z-singn (x) (g-z-pairn x x))
;; (defun g-z-opairn (x y) (g-z-pairn (g-z-singn x) (g-z-pairn x y)))
;; (prove-lemma
;;  a-ev-good-proof-proves-again

;;  (implies (and (ev-hyps given defns symbols)
;;                (g-variable trace)
;;                (not (member trace (list 6 7 8 9 10 11 12 15 16)))
;;                (not (btmp (ev flg exp va fa n)))
;;                (equal concl
;;                       (f-implies (a-ev (ncode flg) (ncode exp) (ncode va) (ncode fa) 10 trace)
;;                                  (f-equal 10 (ncode (ev flg exp va fa n))))))
;;           (proves (a-ev-good-proof flg exp va fa n trace) concl given defns symbols))
;;  ((disable z-list ncode-equal nil-intersect proves-is-formula-again subset ev-hyps)
;;   (use (a-ev-good-proof-proves))))
;; (defun a-ev1
;;       (flg-bar exp-bar va-bar fa-bar val-bar)
;;       (forsome 1 (a-ev flg-bar exp-bar va-bar fa-bar val-bar 1)))
;; (toggle g1323 a-ev t)
;; (defun a-ev1-ok-proof
;;       (flg exp va fa n)
;;       (eg-proof (a-ev (ncode flg)
;;                       (ncode exp)
;;                       (ncode va)
;;                       (ncode fa)
;;                       (ncode (ev flg exp va fa n))
;;                       1)
;;                 (list 1)
;;                 (list (graph-trans (ev-graph flg exp va fa n)))
;;                 (a-ev-ok-proof flg exp va fa n)))
;; (defthm formula-a-ev-defn-again

;;              (implies (and (g-variable trace)
;;                            (ev-hyps given defns symbols))
;;                       (g-formula (a-ev-defun trace) symbols))
;;              ((disable z-apply-subr-all-hyps)))
;; (toggle g1324 a-ev-defn-part1 nil)
;; (defthm parallel-subst-trace-a-ev-defn-part1

;;              (equal (parallel-subst (a-ev-defn-part1 6 7 8 9 10 1) (list 1) (list trace) 0)
;;                     (a-ev-defn-part1 6 7 8 9 10 trace)))
;; (toggle g1325 a-ev-defn-part1 t)
;; (toggle g1326 a-ev-defun nil)
;; (defthm parallel-subst-trace-a-ev-defn

;;              (equal (parallel-subst (a-ev-defun 1) (list 1) (list trace) 0) (a-ev-defun trace)))
;; (prove-lemma
;;  a-ev1-ok-proof-proves

;;  (implies (and (ev-hyps given defns symbols)
;;                (not (btmp (ev flg exp va fa n)))
;;                (equal concl
;;                       (a-ev1 (ncode flg)
;;                              (ncode exp)
;;                              (ncode va)
;;                              (ncode fa)
;;                              (ncode (ev flg exp va fa n)))))
;;           (proves (a-ev1-ok-proof flg exp va fa n) concl given defns symbols))
;;  ((disable z-apply-subr-all-hyps ev ev-hyps)
;;   (use (proves-is-formula (pf (a-ev-ok-proof flg exp va fa n))
;;                           (exp (a-ev (ncode flg)
;;                                      (ncode exp)
;;                                      (ncode va)
;;                                      (ncode fa)
;;                                      (ncode (ev flg exp va fa n))
;;                                      (graph-trans (ev-graph flg exp va fa n)))))
;;        (formula-a-ev-defn-again (trace 1)))))
;; (defun a-ev1-good-proof
;;       (flg exp va fa n)
;;       (forsome-intro-proof 1
;;                            (a-ev (ncode flg) (ncode exp) (ncode va) (ncode fa) 10 1)
;;                            (f-equal 10 (ncode (ev flg exp va fa n)))
;;                            (a-ev-good-proof flg exp va fa n 1)))
;; (defthm a-ev1-good-proof-proves

;;              (implies (and (ev-hyps given defns symbols)
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (f-implies (a-ev1 (ncode flg)
;;                                                     (ncode exp)
;;                                                     (ncode va)
;;                                                     (ncode fa)
;;                                                     10)
;;                                              (f-equal 10 (ncode (ev flg exp va fa n))))))
;;                       (proves (a-ev1-good-proof flg exp va fa n) concl given defns symbols))
;;              ((disable a-ev ev-hyps ev)))
;; (toggle g1327 a-ev1-ok-proof t)
;; (toggle g1328 a-ev1-good-proof t)
;; (toggle g1329 free-for t)
;; (defun a-ev1-not-good-proof
;;       (flg exp va fa n val)
;;       (tautconseq-proof (list (f-not (f-equal (ncode val) (ncode (ev flg exp va fa n))))
;;                               (f-implies (a-ev1 (ncode flg)
;;                                                 (ncode exp)
;;                                                 (ncode va)
;;                                                 (ncode fa)
;;                                                 (ncode val))
;;                                          (f-equal (ncode val) (ncode (ev flg exp va fa n)))))
;;                         (f-not (a-ev1 (ncode flg) (ncode exp) (ncode va) (ncode fa) (ncode val)))
;;                         (list (ncode-nequal-proof val (ev flg exp va fa n))
;;                               (subst-rule-proof (f-implies (a-ev1 (ncode flg)
;;                                                                   (ncode exp)
;;                                                                   (ncode va)
;;                                                                   (ncode fa)
;;                                                                   10)
;;                                                            (f-equal 10
;;                                                                     (ncode (ev flg
;;                                                                                exp
;;                                                                                va
;;                                                                                fa
;;                                                                                n))))
;;                                                 10
;;                                                 (ncode val)
;;                                                 (a-ev1-good-proof flg exp va fa n)))))
;; (defthm a-ev1-not-good-proof-proves

;;              (implies (and (ev-hyps given defns symbols)
;;                            (not (btmp (ev flg exp va fa n)))
;;                            (not (ncode-equal val (ev flg exp va fa n)))
;;                            (equal concl
;;                                   (f-not (a-ev1 (ncode flg)
;;                                                 (ncode exp)
;;                                                 (ncode va)
;;                                                 (ncode fa)
;;                                                 (ncode val)))))
;;                       (proves (a-ev1-not-good-proof flg exp va fa n val)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable z-subrp-hyps ev)))
;; (defun a-ev2
;;       (flg exp fa val)
;;       (forsome 1
;;                (f-and (isin (z-list (list (ncode val)
;;                                           (ncode flg)
;;                                           (ncode exp)
;;                                           (z-opair 6 (z-opair 7 (ncode (gcode nil))))
;;                                           (ncode fa)))
;;                             1)
;;                       (a-ev-defun 1))))
;; (defthm replace-va-a-ev2

;;              (equal (g-subst (g-subst (a-ev2 flg exp fa val) 7 (ncode va2) 0) 6 (ncode va1) 0)
;;                     (a-ev1 (ncode flg)
;;                            (ncode exp)
;;                            (z-opair (ncode va1) (z-opair (ncode va2) (ncode (gcode nil))))
;;                            (ncode fa)
;;                            (ncode val))))
;; (defthm replace-va-forall-a-ev2

;;              (equal (g-subst (forall 6 (a-ev2 flg exp fa val)) 7 (ncode va2) 0)
;;                     (forall 6
;;                             (a-ev1 (ncode flg)
;;                                    (ncode exp)
;;                                    (z-opair 6 (z-opair (ncode va2) (ncode (gcode nil))))
;;                                    (ncode fa)
;;                                    (ncode val)))))
;; (defthm replace-va1-a-ev2

;;              (equal (g-subst (a-ev1 (ncode flg)
;;                                   (ncode exp)
;;                                   (z-opair 6 (z-opair (ncode va2) (ncode (gcode nil))))
;;                                   (ncode fa)
;;                                   (ncode val))
;;                            6
;;                            (ncode va1)
;;                            0)
;;                     (a-ev1 (ncode flg)
;;                            (ncode exp)
;;                            (z-opair (ncode va1) (z-opair (ncode va2) (ncode (gcode nil))))
;;                            (ncode fa)
;;                            (ncode val))))
;; (toggle g1330 a-ev1 t)
;; (toggle g1331 a-ev-defun t)
;; (toggle g1332 a-ev t)
;; (defn
;;  a-ev2-inst-proof
;;  (flg exp fa val va1 va2 pf)
;;  (subst-rule-proof (a-ev1 (ncode flg)
;;                           (ncode exp)
;;                           (z-opair 6 (z-opair (ncode va2) (ncode (gcode nil))))
;;                           (ncode fa)
;;                           (ncode val))
;;                    6
;;                    (ncode va1)
;;                    (detach-proof (forall 6
;;                                          (a-ev1 (ncode flg)
;;                                                 (ncode exp)
;;                                                 (z-opair 6
;;                                                          (z-opair (ncode va2)
;;                                                                   (ncode (gcode nil))))
;;                                                 (ncode fa)
;;                                                 (ncode val)))
;;                                  (a-ev1 (ncode flg)
;;                                         (ncode exp)
;;                                         (z-opair 6 (z-opair (ncode va2) (ncode (gcode nil))))
;;                                         (ncode fa)
;;                                         (ncode val))
;;                                  pf
;;                                  (all-elim-proof 6
;;                                                  (a-ev1 (ncode flg)
;;                                                         (ncode exp)
;;                                                         (z-opair 6
;;                                                                  (z-opair (ncode va2)
;;                                                                           (ncode (gcode nil))))
;;                                                         (ncode fa)
;;                                                         (ncode val))))))
;; (prove-lemma
;;  a-ev2-inst-proof-proves

;;  (implies (and (ev-hyps given defns symbols)
;;                (proves pf
;;                        (forall 6
;;                                (a-ev1 (ncode flg)
;;                                       (ncode exp)
;;                                       (z-opair 6 (z-opair (ncode va2) (ncode (gcode nil))))
;;                                       (ncode fa)
;;                                       (ncode val)))
;;                        given
;;                        defns
;;                        symbols)
;;                (equal concl
;;                       (a-ev1 (ncode flg)
;;                              (ncode exp)
;;                              (z-opair (ncode va1) (z-opair (ncode va2) (ncode (gcode nil))))
;;                              (ncode fa)
;;                              (ncode val))))
;;           (proves (a-ev2-inst-proof flg exp fa val va1 va2 pf) concl given defns symbols))
;;  ((use (proves-is-formula (exp (forall 6
;;                                        (a-ev1 (ncode flg)
;;                                               (ncode exp)
;;                                               (z-opair 6
;;                                                        (z-opair (ncode va2)
;;                                                                 (ncode (gcode nil))))
;;                                               (ncode fa)
;;                                               (ncode val))))))
;;   (disable gcode z-apply-subr-all-hyps)))
;; (toggle g1333 bool-fix nil)
;; (defthm ncode-nequal-bool-fix-t-f (not (ncode-equal (bool-fix nil) (bool-fix t))))
;; (toggle g1334 bool-fix t)
;; ;; exponentiation.
;; (defun exp (x y) (if (zerop y) 1 (times (exp x (sub1 y)) x)))
;; ;; remainder.
;; (defun rem (x y) (if (zerop y) (fix x) (if (< x y) (fix x) (rem (difference x y) y))))
;; ;; development of number theory leading to unique prime factorization theorem.
;; ;; taken from boyer-moore's "proveall".
;; (defthm plus-right-id2 (implies (not (acl2-numberp y)) (equal (plus x y) (fix x))))
;; (defthm plus-add1

;;              (equal (plus x (add1 y)) (if (acl2-numberp y) (add1 (plus x y)) (add1 x))))
;; (defthm commutativity2-of-plus (equal (plus x (plus y z)) (plus y (plus x z))))
;; (defthm commutativity-of-plus (equal (plus x y) (plus y x)))
;; (defthm associativity-of-plus (equal (plus (plus x y) z) (plus x (plus y z))))
;; (defthm plus-equal-0

;;              (equal (equal (plus a b) 0)
;;                     (and (zerop a)
;;                          (zerop b))))
;; (defthm difference-x-x (equal (difference x x) 0))
;; (defthm difference-plus

;;              (and (equal (difference (plus x y) x) (fix y))
;;                   (equal (difference (plus y x) x) (fix y))))
;; (defthm plus-cancellation

;;              (equal (equal (plus a b) (plus a c)) (equal (fix b) (fix c))))
;; (defthm difference-0 (implies (not (< y x)) (equal (difference x y) 0)))
;; (defthm equal-difference-0 (equal (equal 0 (difference x y)) (not (< y x))))
;; (defthm difference-cancellation-0

;;              (equal (equal x (difference x y))
;;                     (and (acl2-numberp x)
;;                          (or (equal x 0)
;;                              (zerop y)))))
;; (defthm difference-cancellation-1

;;              (equal (equal (difference x y) (difference z y))
;;                     (if (< x y)
;;                         (not (< y z))
;;                         (if (< z y) (not (< y x)) (equal (fix x) (fix z))))))
;; (defthm times-zero2 (implies (not (acl2-numberp y)) (equal (times x y) 0)))
;; (defthm distributivity-of-times-over-plus

;;              (equal (times x (plus y z)) (plus (times x y) (times x z))))
;; (defthm times-add1

;;              (equal (times x (add1 y)) (if (acl2-numberp y) (plus x (times x y)) (fix x))))
;; (defthm commutativity-of-times (equal (times x y) (times y x)))
;; (defthm commutativity2-of-times (equal (times x (times y z)) (times y (times x z))))
;; (defthm associativity-of-times (equal (times (times x y) z) (times x (times y z))))
;; (defthm equal-times-0

;;              (equal (equal (times x y) 0)
;;                     (or (zerop x)
;;                         (zerop y))))
;; (defthm equal-<

;;              (equal (equal (< x y) z) (if (< x y) (equal t z) (equal nil z))))
;; (defthm difference-elim
;;              (elim)
;;              (implies (and (acl2-numberp y)
;;                            (not (< y x)))
;;                       (equal (plus x (difference y x)) y)))
;; (defthm rem-quotient (equal (plus (rem x y) (times y (quotient x y))) (fix x)))
;; (defthm rem-wrt-1 (equal (rem y 1) 0))
;; (defthm rem-wrt-12 (implies (not (acl2-numberp x)) (equal (rem y x) (fix y))))
;; (defthm <-rem2 (rewrite generalize) (equal (< (rem x y) y) (not (zerop y))))
;; (defthm rem-x-x (equal (rem x x) 0))
;; (defthm rem-quotient-elim
;;              (elim)
;;              (implies (and (not (zerop y))
;;                            (acl2-numberp x))
;;                       (equal (plus (rem x y) (times y (quotient x y))) x)))
;; (defthm <-times-1 (implies (not (zerop i)) (not (< (times i j) j))))
;; (defthm <-times-2 (implies (not (zerop i)) (not (< (times j i) j))))
;; (defthm <-quotient1

;;              (equal (< (quotient i j) i)
;;                     (and (not (zerop i))
;;                          (or (zerop j)
;;                              (not (equal j 1))))))
;; (defthm <-rem1

;;              (equal (< (rem x y) x)
;;                     (and (not (zerop y))
;;                          (not (zerop x))
;;                          (not (< x y)))))
;; (defun gcd
;;       (x y)
;;       (if (zerop x)
;;           (fix y)
;;           (if (zerop y) x (if (< x y) (gcd x (difference y x)) (gcd (difference x y) y))))
;;       ((lex2 (list (acl2-count x) (acl2-count y)))))
;; (defthm acl2-numberp-gcd (acl2-numberp (gcd x y)))
;; (defthm gcd-equal-0

;;              (equal (equal (gcd x y) 0)
;;                     (and (zerop x)
;;                          (zerop y))))
;; (defthm gcd-0 (equal (gcd 0 y) (fix y)))
;; (defthm commutativity-of-gcd (equal (gcd x y) (gcd y x)))
;; (defthm difference-plus1 (equal (difference (plus x y) x) (fix y)))
;; (defthm difference-plus2 (equal (difference (plus y x) x) (fix y)))
;; (defthm difference-plus-cancelation

;;              (equal (difference (plus x y) (plus x z)) (difference y z)))
;; (defthm times-difference

;;              (equal (times x (difference c w)) (difference (times c x) (times w x))))
;; (defun divides (x y) (zerop (rem y x)))
;; (defthm divides-times (equal (rem (times x z) z) 0))
;; (defthm difference-plus3 (equal (difference (plus b (plus a c)) a) (plus b c)))
;; (defthm difference-add1-cancellation

;;              (equal (difference (add1 (plus y z)) z) (add1 y)))
;; (defthm rem-add1

;;              (implies (and (not (zerop y))
;;                            (not (equal y 1)))
;;                       (not (equal (rem (add1 (times x y)) y) 0))))
;; (defthm divides-plus-rewrite1

;;              (implies (and (equal (rem x z) 0)
;;                            (equal (rem y z) 0))
;;                       (equal (rem (plus x y) z) 0)))
;; (defthm divides-plus-rewrite2

;;              (implies (and (equal (rem x z) 0)
;;                            (not (equal (rem y z) 0)))
;;                       (not (equal (rem (plus x y) z) 0))))
;; (defthm divides-plus-rewrite

;;              (implies (equal (rem x z) 0)
;;                       (equal (equal (rem (plus x y) z) 0) (equal (rem y z) 0))))
;; (defthm <-plus-cancelation (equal (< (plus x y) (plus x z)) (< y z)))
;; (defthm divides-plus-rewrite-commuted

;;              (implies (equal (rem x z) 0)
;;                       (equal (equal (rem (plus y x) z) 0) (equal (rem y z) 0))))
;; (defthm euclid

;;              (implies (equal (rem x z) 0)
;;                       (equal (equal (rem (difference y x) z) 0)
;;                              (if (< x y) (equal (rem y z) 0) t))))
;; (defthm <-times-cancellation

;;              (equal (< (times x z) (times y z))
;;                     (and (not (zerop z))
;;                          (< x y))))
;; (defthm <-plus-cancellation3 (equal (< y (plus x y)) (not (zerop x))))
;; (defthm distributivity-of-times-over-gcd

;;              (equal (gcd (times x z) (times y z)) (times z (gcd x y))))
;; (defthm gcd-divides-both

;;              (and (equal (rem x (gcd x y)) 0)
;;                   (equal (rem y (gcd x y)) 0)))
;; (defthm gcd-is-the-greatest
;;              nil
;;              (implies (and (not (zerop x))
;;                            (not (zerop y))
;;                            (divides z x)
;;                            (divides z y))
;;                       (leq z (gcd x y))))
;; (defun prime1
;;       (x y)
;;       (if (zerop y)
;;           nil
;;           (if (equal y 1)
;;               t
;;               (and (not (divides y x))
;;                    (prime1 x (sub1 y))))))
;; (defun prime
;;       (x)
;;       (and (not (zerop x))
;;            (not (equal x 1))
;;            (prime1 x (sub1 x))))
;; (defun greatest-factor
;;       (x y)
;;       (if (or (zerop y)
;;               (equal y 1))
;;           x
;;           (if (divides y x) y (greatest-factor x (sub1 y)))))
;; (defthm greatest-factor-<

;;              (implies (and (< y x)
;;                            (not (prime1 x y))
;;                            (not (zerop x))
;;                            (not (equal (sub1 x) 0))
;;                            (not (zerop y)))
;;                       (< (greatest-factor x y) x)))
;; (defthm greatest-factor-divides

;;              (implies (and (< y x)
;;                            (not (prime1 x y))
;;                            (not (zerop x))
;;                            (not (equal x 1))
;;                            (not (zerop y)))
;;                       (equal (rem x (greatest-factor x y)) 0)))
;; (defthm greatest-factor-0

;;              (equal (equal (greatest-factor x y) 0)
;;                     (and (or (zerop y)
;;                              (equal y 1))
;;                          (equal x 0))))
;; (defthm rem-0-crock (equal (rem 0 y) 0))
;; (defthm greatest-factor-1 (equal (equal (greatest-factor x y) 1) (equal x 1)))
;; (defthm acl2-numberp-greatest-factor

;;              (equal (acl2-numberp (greatest-factor x y))
;;                     (not (and (or (zerop y)
;;                                   (equal y 1))
;;                               (not (acl2-numberp x))))))
;; (defun prime-factors
;;       (x)
;;       (if (or (zerop x)
;;               (equal (sub1 x) 0))
;;           nil
;;           (if (prime1 x (sub1 x))
;;               (cons x nil)
;;               (g-append (prime-factors (greatest-factor x (sub1 x)))
;;                       (prime-factors (quotient x (greatest-factor x (sub1 x))))))))
;; (defun prime-list
;;       (l)
;;       (if (atom l)
;;           t
;;           (and (prime (car l))
;;                (prime-list (cdr l)))))
;; (defun times-list (l) (if (atom l) 1 (times (car l) (times-list (cdr l)))))
;; (defthm times-list-append

;;              (equal (times-list (g-append x y)) (times (times-list x) (times-list y))))
;; (defthm prime-list-append

;;              (equal (prime-list (g-append x y))
;;                     (and (prime-list x)
;;                          (prime-list y))))
;; (defthm prime-list-prime-factors (prime-list (prime-factors x)))
;; (defthm quotient-times1

;;              (implies (and (acl2-numberp y)
;;                            (acl2-numberp x)
;;                            (not (equal x 0))
;;                            (divides x y))
;;                       (equal (times x (quotient y x)) y)))
;; (defthm quotient-<

;;              (implies (and (not (zerop x))
;;                            (< x y))
;;                       (not (equal (quotient y x) 0))))
;; (defthm enough-factors

;;              (implies (not (zerop x)) (equal (times-list (prime-factors x)) x)))
;; (defthm prime-factorization-existence
;;              nil
;;              (implies (not (zerop x))
;;                       (and (equal (times-list (prime-factors x)) x)
;;                            (prime-list (prime-factors x)))))
;; (defun greatereqpr (w z) (if (zerop w) (zerop z) (if (equal w z) t (greatereqpr (sub1 w) z))))
;; (defthm times-id-iff-1

;;              (equal (equal z (times w z))
;;                     (and (acl2-numberp z)
;;                          (or (equal z 0)
;;                              (equal w 1)))))
;; (defthm prime1-basic

;;              (implies (and (not (equal z 1))
;;                            (not (equal z 0))
;;                            (acl2-numberp z)
;;                            (greatereqpr u z))
;;                       (not (prime1 (times w z) u))))
;; (defthm greatereqpr-< (equal (greatereqpr x y) (not (< x y))))
;; (defthm greatereqpr-rem

;;              (implies (and (not (equal z (add1 v)))
;;                            (divides z (add1 v)))
;;                       (greatereqpr v z)))
;; (defthm prime-basic

;;              (implies (and (not (equal z 1))
;;                            (not (equal z x))
;;                            (not (zerop x))
;;                            (not (equal x 1))
;;                            (divides z x))
;;                       (not (prime1 x (sub1 x)))))
;; (defthm rem-gcd (implies (equal (gcd b x) y) (equal (rem b y) 0)))
;; (defthm rem-gcd-1 (implies (not (equal (rem b x) 0)) (not (equal (gcd b x) x))))
;; (defthm divides-times1 (implies (equal a (times z y)) (equal (rem a z) 0)))
;; (defthm times-identity1

;;              (implies (and (acl2-numberp y)
;;                            (not (equal y 1))
;;                            (not (equal y 0))
;;                            (not (equal x 0)))
;;                       (not (equal x (times x y)))))
;; (defthm times-identity

;;              (equal (equal x (times x y))
;;                     (or (equal x 0)
;;                         (and (acl2-numberp x)
;;                              (equal y 1)))))
;; (defthm kludge-bridge

;;              (implies (equal y (times k x)) (equal (gcd y (times a x)) (times x (gcd a k)))))
;; (defthm hack1

;;              (implies (and (not (divides x a))
;;                            (equal a (gcd (times x a) (times b a))))
;;                       (not (equal (times k x) (times b a)))))
;; (defthm prime-gcd

;;              (implies (and (not (divides x b))
;;                            (not (zerop x))
;;                            (not (equal (sub1 x) 0))
;;                            (prime1 x (sub1 x)))
;;                       (equal (equal (gcd b x) 1) t)))
;; (defthm gcd-distributes-over-an-opened-up-times

;;              (implies (and (acl2-numberp x)
;;                            (not (equal x 0))
;;                            (equal free (times x z)))
;;                       (equal (gcd (times b z) free) (times z (gcd b x)))))
;; (defthm prime-key

;;              (implies (and (acl2-numberp z)
;;                            (prime x)
;;                            (not (divides x z))
;;                            (not (divides x b)))
;;                       (not (equal (times x k) (times b z)))))
;; (defthm quotient-divides

;;              (implies (and (acl2-numberp y)
;;                            (not (equal (times x (quotient y x)) y)))
;;                       (not (equal (rem y x) 0))))
;; (defthm little-step

;;              (implies (and (prime x)
;;                            (not (equal y 1))
;;                            (not (equal x y)))
;;                       (not (equal (rem x y) 0))))
;; (defun delete
;;       (x y)
;;       (if (consp y) (if (equal x (car y)) (cdr y) (cons (car y) (delete x (cdr y)))) y))
;; (defthm delete-non-member (implies (not (member x y)) (equal (delete x y) y)))
;; (defthm member-delete (implies (member x (delete u v)) (member x v)))
;; (defthm <-count-delete

;;              (implies (member n l) (< (acl2-count (delete n l)) (acl2-count l))))
;; (defun perm
;;       (a b)
;;       (if (atom a) (atom b) (if (member (car a) b) (perm (cdr a) (delete (car a) b)) nil)))
;; (defthm rem-times (equal (rem (times y x) y) 0))
;; (defthm prime-list-delete (implies (prime-list l2) (prime-list (delete x l2))))
;; (defthm divides-times-list

;;              (implies (and (not (zerop c))
;;                            (member c l))
;;                       (equal (rem (times-list l) c) 0)))
;; (defthm quotient-times (equal (quotient (times y x) y) (if (zerop y) 0 (fix x))))
;; (defthm distributivity-of-divides

;;              (implies (and (not (zerop a))
;;                            (divides a w))
;;                       (equal (times c (quotient w a)) (quotient (times c w) a))))
;; (defthm times-list-delete

;;              (implies (and (not (zerop c))
;;                            (member c l))
;;                       (equal (times-list (delete c l)) (quotient (times-list l) c))))
;; (defthm prime-list-times-list

;;              (implies (and (prime c)
;;                            (prime-list l2)
;;                            (not (member c l2)))
;;                       (not (equal (rem (times-list l2) c) 0))))
;; (defthm if-times-then-divides

;;              (implies (and (not (zerop c))
;;                            (not (divides c x)))
;;                       (not (equal (times c y) x))))
;; (defthm times-equal-1

;;              (equal (equal (times a b) 1)
;;                     (and (not (equal a 0))
;;                          (not (equal b 0))
;;                          (acl2-numberp a)
;;                          (acl2-numberp b)
;;                          (equal (sub1 a) 0)
;;                          (equal (sub1 b) 0))))
;; (defthm prime-member

;;              (implies (and (equal (times c (times-list l1)) (times-list l2))
;;                            (prime c)
;;                            (prime-list l2))
;;                       (member c l2))
;;              ((disable times)))
;; (defthm divides-implies-times

;;              (implies (and (not (zerop a))
;;                            (acl2-numberp c)
;;                            (equal (times a c) b))
;;                       (equal (equal c (quotient b a)) t)))
;; ;; two prime factorizations with the same product are permutations of one another.
;; (defthm prime-factorization-uniqueness
;;              nil
;;              (implies (and (prime-list l1)
;;                            (prime-list l2)
;;                            (equal (times-list l1) (times-list l2)))
;;                       (perm l1 l2)))
;; ;; num-treep checks if x is constructed from numbers using cons.
;; (defun num-treep
;;       (x)
;;       (if (consp x)
;;           (and (num-treep (car x))
;;                (num-treep (cdr x)))
;;           (acl2-numberp x)))
;; ;; double multiplies x by 2.  the recursive definition is there to provide an induction
;; ;; scheme.
;; (defun double (x) (if (zerop x) 0 (add1 (add1 (double (sub1 x))))))
;; ;; halve integer-divides x by 2.
;; (defun halve (x) (if (zerop x) 0 (if (zerop (sub1 x)) 0 (add1 (halve (sub1 (sub1 x)))))))
;; (defthm odd-rem-two (equal (rem (add1 (double x)) 2) 1))
;; ;; numcode is a one-to-one mapping from num-trees to numbers.  a number n is mapped
;; ;; to the odd number (2n + 1).  the list (cons x y) is mapped to ((x**2)(y**3)),
;; ;; if x is mapped to x, and y to y.  the unique prime factorization theorem is
;; ;; needed to decipher the num-tree back from a numcode.
;; (defun numcode
;;       (x)
;;       (if (consp x) (times (exp 2 (numcode (car x))) (exp 3 (numcode (cdr x)))) (add1 (double x))))
;; (defun y-x-list (x y) (if (zerop y) nil (cons x (y-x-list x (sub1 y)))))
;; (defthm exp-times-list-y-x-list (equal (times-list (y-x-list x y)) (exp x y)))
;; (defun perm-y-x-ind (y z) (if (zerop y) t (if (zerop z) t (perm-y-x-ind (sub1 y) (sub1 z)))))
;; (defthm perm-y-x-list-append

;;              (equal (perm (g-append (y-x-list x y) list1) (g-append (y-x-list x z) list2))
;;                     (if (< y z)
;;                         (perm list1 (g-append (y-x-list x (difference z y)) list2))
;;                         (perm (g-append (y-x-list x (difference y z)) list1) list2)))
;;              ((induct (perm-y-x-ind y z))))
;; (defthm not-member-y-x-list

;;              (implies (not (equal x x1)) (not (member x (y-x-list x1 y1)))))
;; (defthm nequal-perm-y-x-list

;;              (implies (and (not (equal x x1))
;;                            (not (zerop y)))
;;                       (not (perm (g-append (y-x-list x y) list1) (y-x-list x1 y1)))))
;; (defthm nequal-perm-y-x-step

;;              (implies (and (consp y)
;;                            (not (member (car y) x)))
;;                       (not (perm x y))))
;; (defthm nequal-perm-y-x-list-another

;;              (implies (and (not (equal x x1))
;;                            (not (zerop y1)))
;;                       (not (perm (y-x-list x y) (g-append (y-x-list x1 y1) list1))))
;;              ((use (nequal-perm-y-x-step (y (g-append (y-x-list x1 y1) list1)) (x (y-x-list x y))))))
;; (defthm not-perm-numcode

;;              (implies (and (not (zerop x))
;;                            (not (equal x x1)))
;;                       (not (perm (g-append (y-x-list 2 x) (y-x-list 3 y))
;;                                  (g-append (y-x-list 2 x1) (y-x-list 3 y1))))))
;; (defthm prime-list-y-x-list (implies (prime x) (prime-list (y-x-list x y))))
;; (defthm rem-rec-reduc

;;              (implies (and (not (zerop y))
;;                            (< y x))
;;                       (equal (rem x y) (rem (difference x y) y))))
;; (defthm rem32 (equal (rem 3 2) 1))
;; (defthm prime1-3-2 (equal (prime1 3 2) (not (divides 2 3))))
;; (defthm prime-3 (prime 3))
;; (defthm prime-2 (prime 2))
;; (defthm times-list-append23-numcode

;;              (equal (times (exp 2 x) (exp 3 y))
;;                     (times-list (g-append (y-x-list 2 x) (y-x-list 3 y)))))
;; ;; the numcodes of two lists are distinct, if the numcodes of the their first elements are.
;; (prove-lemma
;;  numcode-uniqueness1

;;  (implies (and (not (equal x x1))
;;                (not (zerop x)))
;;           (not (equal (times (exp 2 x) (exp 3 y)) (times (exp 2 x1) (exp 3 y1)))))
;;  ((disable times exp exp-times-list-y-x-list prime perm)
;;   (use (prime-factorization-uniqueness (l1 (g-append (y-x-list 2 x) (y-x-list 3 y)))
;;                                        (l2 (g-append (y-x-list 2 x1) (y-x-list 3 y1))))
;;        (not-perm-numcode))))
;; (toggle g1335 times-list-append23-numcode t)
;; (defthm perm-append-x-x (equal (perm (g-append x y) (g-append x y1)) (perm y y1)))
;; (defthm length-delete

;;              (equal (length (delete x y)) (if (member x y) (sub1 (length y)) (length y))))
;; (defthm member-length (implies (zerop (length y)) (not (member x y))))
;; (defthm perm-length (implies (not (equal (length x) (length y))) (not (perm x y))))
;; (defthm length-y-x-list (equal (length (y-x-list x y)) (fix y)))
;; (defthm not-perm-nequal

;;              (implies (and (not (equal y y1))
;;                            (not (zerop y)))
;;                       (not (perm (y-x-list x y) (y-x-list x y1))))
;;              ((use (perm-length (x (y-x-list x y)) (y (y-x-list x y1))))))
;; ;; the numcodes of two lists are distinct, if the numcodes of their second elements are.
;; (prove-lemma
;;  numcode-uniqueness2

;;  (implies (and (equal x x1)
;;                (not (zerop y))
;;                (not (equal y y1)))
;;           (not (equal (times (exp 2 x) (exp 3 y)) (times (exp 2 x1) (exp 3 y1)))))
;;  ((disable times exp exp-times-list-y-x-list prime perm)
;;   (use (prime-factorization-uniqueness (l1 (g-append (y-x-list 2 x) (y-x-list 3 y)))
;;                                        (l2 (g-append (y-x-list 2 x1) (y-x-list 3 y1))))
;;        (times-list-append23-numcode)
;;        (times-list-append23-numcode (x x1) (y y1)))))
;; (defun double-ind (x y) (if (zerop x) t (if (zerop y) t (double-ind (sub1 x) (sub1 y)))))
;; (defthm double-nequal-add1-double

;;              (not (equal (double x) (add1 (double y))))
;;              ((induct (double-ind x y))))
;; (defthm times-2-double (equal (times 2 x) (double x)))
;; (defthm plus-double (equal (plus (double x) (double y)) (double (plus x y))))
;; (defthm times-double (equal (times x (double y)) (double (times x y))))
;; (defthm numcode-reduc

;;              (implies (not (zerop y))
;;                       (equal (times (exp 2 y) z) (double (times (exp 2 (sub1 y)) z)))))
;; (defthm numcode-nequal

;;              (implies (not (zerop x1)) (not (equal (add1 (double x)) (times (exp 2 x1) y)))))
;; (toggle g1336 numcode-reduc t)
;; (toggle g1337 times-2-double t)
;; (toggle g1338 times-double t)
;; ;; decipher1 is the function that deciphers the num-tree back from a numcode.
;; ;; it essentially starts from y and z, and works its way down lexicographically
;; ;; until it has decomposed x into a pair of numcodes, which it recursively deciphers.
;; ;; in the base case, when x is not the numcode of any pair, it halves (sub1 x).
;; (defun decipher1
;;       (x y z)
;;       (if (zerop y)
;;           (halve (sub1 x))
;;           (if (zerop z)
;;               (decipher1 x (sub1 y) x)
;;               (if (and (< y x)
;;                        (< z x))
;;                   (if (equal x (times (exp 2 y) (exp 3 z)))
;;                       (cons (decipher1 y (sub1 y) (sub1 y)) (decipher1 z (sub1 z) (sub1 z)))
;;                       (decipher1 x y (sub1 z)))
;;                   (decipher1 x y (sub1 z)))))
;;       ((lex3 (list (acl2-count x) (acl2-count y) (acl2-count z)))))
;; (defthm <-exp

;;              (implies (and (not (zerop y))
;;                            (< 1 x))
;;                       (< y (exp x y))))
;; (defthm <-times

;;              (implies (and (< 1 x)
;;                            (< 1 y))
;;                       (and (< x (times x y))
;;                            (< y (times x y)))))
;; (defthm <-numcode1

;;              (implies (and (not (zerop x))
;;                            (not (zerop y)))
;;                       (and (< x (times (exp 2 x) (exp 3 y)))
;;                            (< y (times (exp 2 x) (exp 3 y))))))
;; (toggle g1339 times t)
;; (toggle g1340 exp t)
;; (defthm decipher-consp

;;              (implies (and (not (zerop x))
;;                            (not (zerop y)))
;;                       (equal (decipher1 (times (exp 2 x) (exp 3 y)) x y)
;;                              (cons (decipher1 x (sub1 x) (sub1 x))
;;                                    (decipher1 y (sub1 y) (sub1 y)))))
;;              ((disable commutativity-of-times)))
;; (defun decipher-ind
;;       (x y x1 y1)
;;       (if (zerop x1)
;;           t
;;           (if (zerop y1)
;;               (decipher-ind x y (sub1 x1) (times (exp 2 x) (exp 3 y)))
;;               (if (< x x1)
;;                   (decipher-ind x y x1 (sub1 y1))
;;                   (if (equal y y1) t (decipher-ind x y x1 (sub1 y1))))))
;;       ((lex2 (list (acl2-count x1) (acl2-count y1)))))
;; (defthm decipher1-consp-reduc

;;              (implies (and (not (zerop x))
;;                            (not (zerop y))
;;                            (leq x x1)
;;                            (if (equal x x1) (leq y y1) t))
;;                       (equal (decipher1 (times (exp 2 x) (exp 3 y)) x1 y1)
;;                              (decipher1 (times (exp 2 x) (exp 3 y)) x y)))
;;              ((induct (decipher-ind x y x1 y1)) (disable commutativity-of-times
;;                                                          rem
;;                                                          rem-rec-reduc
;;                                                          prime
;;                                                          prime-key
;;                                                          hack1)))
;; (defthm halve-double (equal (halve (double x)) (fix x)))
;; (defthm <-numcode (< 0 (numcode x)))
;; ;; numtreep is the same as num-treep.
;; (defun numtreep
;;       (x)
;;       (if (consp x)
;;           (and (numtreep (car x))
;;                (numtreep (cdr x)))
;;           (acl2-numberp x)))
;; (defthm <-sub1-numcode

;;              (implies (and (not (zerop x))
;;                            (not (zerop y)))
;;                       (and (not (< (sub1 (times (exp 2 x) (exp 3 y))) x))
;;                            (not (< (sub1 (times (exp 2 x) (exp 3 y))) y)))))
;; (defthm <-numcode-again (not (equal (numcode x) 0)))
;; (defthm <-numcode-case

;;              (implies (and (not (zerop x))
;;                            (not (zerop y)))
;;                       (not (equal x (sub1 (times (exp 2 x) (exp 3 y)))))))
;; (defun decipher-ind2
;;       (x y z)
;;       (if (zerop y)
;;           t
;;           (if (zerop z) (decipher-ind2 x (sub1 y) (add1 (double x))) (decipher-ind2 x y (sub1 z))))
;;       ((lex2 (list (acl2-count y) (acl2-count z)))))
;; (defthm decipher1-atom

;;              (equal (decipher1 (add1 (double x)) y z) (fix x))
;;              ((induct (decipher-ind2 x y z))))
;; ;; this is the main lemma relating decipher1 and numcode.  it asserts that
;; ;; decipher1 applied to (numcode x) (with appropriate values for the y, z, arguments)
;; ;; returns x.
;; (defthm decipher1-numcode

;;              (implies (numtreep x)
;;                       (equal (decipher1 (numcode x) (sub1 (numcode x)) (sub1 (numcode x))) x))
;;              ((disable commutativity-of-times rem rem-rec-reduc prime prime-key hack1)))
;; ;; correspondence proofs for plus.
;; (defun g-plusn
;;       (x y n)
;;       (if (or (btmp x)
;;               (btmp y)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-zeropn x) (g-fixn y) (pr-add1n (g-plusn (pr-sub1n x) y (sub1 n))))))
;; (toggle g1341 g-plus nil)
;; (toggle g1342 g-plus-defun nil)
;; (defun g-plus-ind
;;       (x y va n)
;;       (if (zerop n) t (g-plus-ind (pr-sub1 0) 1 (ev 1 (list x y) va (fa) n) (sub1 n))))
;; (defthm g-plus-eval

;;              (equal (ev 0 (g-plus x y) va (fa) n)
;;                     (g-plusn (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-plus-ind x y va n)) (disable pr-add1n)))
;; (defthm pr-add1n-gcode (equal (pr-add1n (gcode x)) (gcode (add1 x))))
;; (toggle g1343 pr-add1n t)
;; (defun plusn-ind (x y n) (if (zerop n) t (if (zerop x) t (plusn-ind (sub1 x) y (sub1 n)))))
;; (defthm g-plusn-gcode

;;              (implies (< x n) (equal (g-plusn (gcode x) (gcode y) n) (gcode (plus x y))))
;;              ((disable gcode) (induct (plusn-ind x y n))))
;; (toggle g1344 g-plus t)
;; (toggle g1345 g-plusn t)
;; (toggle g1346 g-plus-ind t)
;; ;; correspondence proofs for times.
;; (defun g-timesn
;;       (x y n)
;;       (if (or (btmp x)
;;               (btmp y)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-zeropn x)
;;                   (gcode 0)
;;                   (g-plusn y (g-timesn (pr-sub1n x) y (sub1 n)) (sub1 n)))))
;; (toggle g1347 g-times nil)
;; (toggle g1348 g-times-defun nil)
;; (defthm g-times-eval

;;              (equal (ev 0 (g-times x y) va (fa) n)
;;                     (g-timesn (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-plus-ind x y va n))))
;; (defthm g-timesn-gcode

;;              (implies (< (add1 (plus x y)) n)
;;                       (equal (g-timesn (gcode x) (gcode y) n) (gcode (times x y))))
;;              ((disable gcode) (induct (plusn-ind x y n))))
;; (toggle g1349 g-times t)
;; (toggle g1350 g-timesn t)
;; (toggle g1351 g-times-defun t)
;; ;; correspondence proofs for exp.
;; (defun g-expn
;;       (x y n)
;;       (if (or (btmp x)
;;               (btmp y)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-zeropn y) (gcode 1) (g-timesn x (g-expn x (pr-sub1n y) (sub1 n)) (sub1 n)))))
;; (toggle g1373 g-exp nil)
;; (toggle g1374 g-exp-defun nil)
;; (defun g-exp-ind
;;       (x y va n)
;;       (if (zerop n) t (g-exp-ind 0 (pr-sub1 1) (ev 1 (list x y) va (fa) n) (sub1 n))))
;; (defthm g-exp-eval

;;              (equal (ev 0 (g-exp x y) va (fa) n) (g-expn (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-exp-ind x y va n))))
;; (toggle g1375 exp nil)
;; (toggle g1376 times nil)
;; (defthm g-expn-gcode

;;              (implies (and (not (zerop x))
;;                            (< (add1 (plus x y (exp x y))) n))
;;                       (equal (g-expn (gcode x) (gcode y) n) (gcode (exp x y))))
;;              ((disable gcode) (induct (plusn-ind y x n))))
;; (toggle g1377 g-exp t)
;; (toggle g1378 g-expn t)
;; (toggle g1379 g-exp-defun t)
;; (toggle g1380 times t)
;; (toggle g1381 exp t)
;; ;; correspondence proofs for halve.
;; (defun g-halven
;;       (x n)
;;       (if (or (btmp x)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-zeropn x)
;;                   (gcode 0)
;;                   (pr-ifn (pr-zeropn (pr-sub1n x))
;;                           (gcode 0)
;;                           (pr-add1n (g-halven (pr-sub1n (pr-sub1n x)) (sub1 n)))))))
;; (toggle g1382 g-halve nil)
;; (toggle g1383 g-halve-defun nil)
;; (defun g-halve-ind
;;       (x va n)
;;       (if (zerop n) t (g-halve-ind (pr-sub1 (pr-sub1 0)) (ev 1 (list x) va (fa) n) (sub1 n))))
;; (defthm g-halve-eval

;;              (equal (ev 0 (g-halve x) va (fa) n) (g-halven (ev 0 x va (fa) n) n))
;;              ((induct (g-halve-ind x va n))))
;; (defun halven-ind (x n) (if (zerop n) t (if (zerop x) t (halven-ind (sub1 (sub1 x)) (sub1 n)))))
;; (defthm g-halven-gcode

;;              (implies (< x n) (equal (g-halven (gcode x) n) (gcode (halve x))))
;;              ((disable gcode) (induct (halven-ind x n))))
;; (toggle g1384 g-halve t)
;; (toggle g1385 g-halven t)
;; (toggle g1386 g-halve-defun t)
;; ;; correspondence proofs for <.
;; (defun g-<n
;;       (x y n)
;;       (if (or (btmp x)
;;               (btmp y)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-zeropn y)
;;                   (bool-fix nil)
;;                   (pr-ifn (pr-zeropn x)
;;                           (bool-fix t)
;;                           (g-<n (pr-sub1n x) (pr-sub1n y) (sub1 n))))))
;; (toggle g1387 g-< nil)
;; (toggle g1388 g-<-defun nil)
;; (defun g-<-ind
;;       (x y va n)
;;       (if (zerop n) t (g-<-ind (pr-sub1 0) (pr-sub1 1) (ev 1 (list x y) va (fa) n) (sub1 n))))
;; (defthm g-<-eval

;;              (equal (ev 0 (g-< x y) va (fa) n)
;;                     (g-<n (ev 0 x va (fa) n) (ev 0 y va (fa) n) n))
;;              ((induct (g-<-ind x y va n))))
;; (defun <n-ind
;;       (x y n)
;;       (if (zerop n) t (if (zerop y) t (if (zerop x) t (<n-ind (sub1 x) (sub1 y) (sub1 n))))))
;; (defthm g-<n-gcode

;;              (implies (< (plus x y) n)
;;                       (equal (g-<n (gcode x) (gcode y) n) (bool-fix (< x y))))
;;              ((disable gcode) (induct (<n-ind x y n))))
;; (toggle g1389 g-< t)
;; (toggle g1390 g-<n t)
;; (toggle g1391 g-<-defun t)
;; ;; correspondence proofs for decipher1.
;; (defun g-decipher1n
;;       (x y z n)
;;       (if (or (btmp x)
;;               (btmp y)
;;               (btmp z)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-zeropn y)
;;                   (g-halven (pr-sub1n x) (sub1 n))
;;                   (pr-ifn (pr-zeropn z)
;;                           (g-decipher1n x (pr-sub1n y) x (sub1 n))
;;                           (pr-ifn (pr-andn (g-<n y x (sub1 n)) (g-<n z x (sub1 n)))
;;                                   (pr-ifn (pr-equaln x
;;                                                      (g-timesn (g-expn (gcode 2) y (sub1 n))
;;                                                                (g-expn (gcode 3) z (sub1 n))
;;                                                                (sub1 n)))
;;                                           (pr-consn (g-decipher1n y
;;                                                                   (pr-sub1n y)
;;                                                                   (pr-sub1n y)
;;                                                                   (sub1 n))
;;                                                     (g-decipher1n z
;;                                                                   (pr-sub1n z)
;;                                                                   (pr-sub1n z)
;;                                                                   (sub1 n)))
;;                                           (g-decipher1n x y (pr-sub1n z) (sub1 n)))
;;                                   (g-decipher1n x y (pr-sub1n z) (sub1 n)))))))
;; (toggle g1392 g-decipher1 nil)
;; (toggle g1393 g-decipher1-defun nil)
;; (defun g-decipher1-ind
;;       (x y z va n)
;;       (if (zerop n)
;;           t
;;           (and (g-decipher1-ind 0 (pr-sub1 1) 0 (ev 1 (list x y z) va (fa) n) (sub1 n))
;;                (g-decipher1-ind 0 1 (pr-sub1 2) (ev 1 (list x y z) va (fa) n) (sub1 n))
;;                (g-decipher1-ind 1 (pr-sub1 1) (pr-sub1 1) (ev 1 (list x y z) va (fa) n) (sub1 n))
;;                (g-decipher1-ind 2
;;                                 (pr-sub1 2)
;;                                 (pr-sub1 2)
;;                                 (ev 1 (list x y z) va (fa) n)
;;                                 (sub1 n)))))
;; (defthm g-decipher1-eval

;;              (equal (ev 0 (g-decipher1 x y z) va (fa) n)
;;                     (g-decipher1n (ev 0 x va (fa) n) (ev 0 y va (fa) n) (ev 0 z va (fa) n) n))
;;              ((induct (g-decipher1-ind x y z va n)) (disable pr-consn)))
;; (defun dec-count
;;       (x y z)
;;       (if (zerop y)
;;           (add1 x)
;;           (if (zerop z)
;;               (add1 (dec-count x (sub1 y) x))
;;               (if (and (< y x)
;;                        (< z x))
;;                   (if (equal x (times (exp 2 y) (exp 3 z)))
;;                       (add1 (add1 (plus x
;;                                         y
;;                                         z
;;                                         (exp 2 y)
;;                                         (exp 3 z)
;;                                         (dec-count y (sub1 y) (sub1 y))
;;                                         (dec-count z (sub1 z) (sub1 z)))))
;;                       (add1 (add1 (plus x y z (exp 2 y) (exp 3 z) (dec-count x y (sub1 z))))))
;;                   (add1 (add1 (plus x y z (exp 2 y) (exp 3 z) (dec-count x y (sub1 z))))))))
;;       ((lex3 (list (acl2-count x) (acl2-count y) (acl2-count z)))))
;; (defthm gcode-halve (equal (gcode (halve x)) (halve x)))
;; (defun decipher1n-ind
;;       (x y z n)
;;       (if (zerop n)
;;           t
;;           (if (zerop y)
;;               t
;;               (if (zerop z)
;;                   (decipher1n-ind x (sub1 y) x (sub1 n))
;;                   (if (and (< y x)
;;                            (< z x))
;;                       (if (equal x (times (exp 2 y) (exp 3 z)))
;;                           (and (decipher1n-ind y (sub1 y) (sub1 y) (sub1 n))
;;                                (decipher1n-ind z (sub1 z) (sub1 z) (sub1 n)))
;;                           (decipher1n-ind x y (sub1 z) (sub1 n)))
;;                       (decipher1n-ind x y (sub1 z) (sub1 n)))))))
;; (defthm g-decipher1n-gcode

;;              (implies (< (dec-count x y z) n)
;;                       (equal (g-decipher1n (gcode x) (gcode y) (gcode z) n) (decipher1 x y z)))
;;              ((induct (decipher1n-ind x y z n)) (disable gcode halve)))
;; (toggle g1394 g-decipher1 t)
;; (toggle g1395 g-decipher1n t)
;; (toggle g1396 g-decipher1-defun t)
;; (defthm num-treep-gcode (num-treep (gcode x)))
;; (defun g-deciphern (x n) (g-decipher1n x (pr-sub1n x) (pr-sub1n x) n))
;; ;; correspondence proofs for inv-code.
;; (defn
;;  g-inv-coden
;;  (x n)
;;  (if (or (btmp x)
;;          (zerop n))
;;      (btm)
;;      (pr-ifn (pr-conspn x)
;;              (pr-ifn (pr-equaln (pr-carn x) 1)
;;                      (g-consn (g-inv-coden (pr-carn (pr-cdrn x)) (sub1 n))
;;                               (g-inv-coden (pr-cdrn (pr-cdrn x)) (sub1 n)))
;;                      (pr-ifn (pr-equaln (pr-carn x) 2)
;;                              (g-f-notn (g-inv-coden (pr-carn (pr-cdrn x)) (sub1 n)))
;;                              (pr-ifn (pr-equaln (pr-carn x) 3)
;;                                      (g-f-orn (g-inv-coden (pr-carn (pr-cdrn x)) (sub1 n))
;;                                               (g-inv-coden (pr-cdrn (pr-cdrn x)) (sub1 n)))
;;                                      (pr-ifn (pr-equaln (pr-carn x) 4)
;;                                              (g-forsomen (g-inv-coden (pr-carn (pr-cdrn x))
;;                                                                       (sub1 n))
;;                                                          (g-inv-coden (pr-cdrn (pr-cdrn x))
;;                                                                       (sub1 n)))
;;                                              (pr-ifn (pr-equaln (pr-carn x) 5)
;;                                                      (gcode t)
;;                                                      (pr-ifn (pr-equaln (pr-carn x) 6)
;;                                                              (gcode nil)
;;                                                              (gcode nil)))))))
;;              (g-fixn x))))
;; (toggle g1398 g-inv-code nil)
;; (toggle g1399 g-inv-code-defun nil)
;; (defun g-inv-code-ind
;;       (x va n)
;;       (if (zerop n)
;;           t
;;           (and (g-inv-code-ind (pr-car (pr-cdr 0)) (ev 1 (list x) va (fa) n) (sub1 n))
;;                (g-inv-code-ind (pr-cdr (pr-cdr 0)) (ev 1 (list x) va (fa) n) (sub1 n)))))
;; (defthm g-inv-code-eval

;;              (equal (ev 0 (g-inv-code x) va (fa) n) (g-inv-coden (ev 0 x va (fa) n) n))
;;              ((induct (g-inv-code-ind x va n)) (disable pr-carn pr-cdrn pr-conspn pr-consn)))
;; (defthm pr-carn-reduc1 (implies (acl2-numberp x) (equal (pr-carn x) 0)))
;; (defthm pr-carn-reduc2 (equal (pr-carn (cons x y)) x))
;; (defthm pr-cdrn-reduc1 (implies (acl2-numberp x) (equal (pr-cdrn x) 0)))
;; (defthm pr-cdrn-reduc (equal (pr-cdrn (cons x y)) y))
;; (defthm pr-consp-reduc1 (implies (acl2-numberp x) (equal (pr-conspn x) (bool-fix nil))))
;; (defthm pr-consp-reduc2 (equal (pr-conspn (cons x y)) (bool-fix t)))
;; (defun inv-code
;;       (x)
;;       (if (consp x)
;;           (if (equal (car x) 1)
;;               (cons (inv-code (cadr x)) (inv-code (cddr x)))
;;               (if (equal (car x) 2)
;;                   (f-not (inv-code (cadr x)))
;;                   (if (equal (car x) 3)
;;                       (f-or (inv-code (cadr x)) (inv-code (cddr x)))
;;                       (if (equal (car x) 4)
;;                           (forsome (inv-code (cadr x)) (inv-code (cddr x)))
;;                           (if (equal (car x) 5) t (if (equal (car x) 6) nil nil))))))
;;           (fix x)))
;; (defun inv-coden-ind
;;       (x n)
;;       (if (zerop n)
;;           t
;;           (if (consp x)
;;               (if (equal (car x) 1)
;;                   (and (inv-coden-ind (cadr x) (sub1 n))
;;                        (inv-coden-ind (cddr x) (sub1 n)))
;;                   (if (equal (car x) 2)
;;                       (inv-coden-ind (cadr x) (sub1 n))
;;                       (if (equal (car x) 3)
;;                           (and (inv-coden-ind (cadr x) (sub1 n))
;;                                (inv-coden-ind (cddr x) (sub1 n)))
;;                           (if (equal (car x) 4)
;;                               (and (inv-coden-ind (cadr x) (sub1 n))
;;                                    (inv-coden-ind (cddr x) (sub1 n)))
;;                               t))))
;;               t)))
;; (toggle g1400 g-fixn nil)
;; (defthm g-fixn-reduc (implies (acl2-numberp x) (equal (g-fixn x) (gcode x))))
;; (toggle g1401 g-fixn t)
;; (toggle g1402 pr-equaln nil)
;; (defthm pr-equaln-reduc2

;;              (implies (and (not (btmp x))
;;                            (not (btmp y)))
;;                       (equal (pr-equaln x y) (bool-fix (ncode-equal x y)))))
;; (toggle g1403 pr-equaln t)
;; (toggle g1404 g-consn nil)
;; (toggle g1405 g-f-notn nil)
;; (toggle g1406 g-f-orn nil)
;; (toggle g1407 g-forsomen nil)
;; (defthm g-consn-acl2-numberp

;;              (implies (and (acl2-numberp x)
;;                            (acl2-numberp y))
;;                       (equal (g-consn x y) (gcode (cons x y)))))
;; (defthm g-f-notn-acl2-numberp

;;              (implies (acl2-numberp x) (equal (g-f-notn x) (gcode (f-not x)))))
;; (defthm g-f-orn-acl2-numberp

;;              (implies (and (acl2-numberp x)
;;                            (acl2-numberp y))
;;                       (equal (g-f-orn x y) (gcode (f-or x y)))))
;; (defthm g-forsomen-acl2-numberp

;;              (implies (and (acl2-numberp x)
;;                            (acl2-numberp y))
;;                       (equal (g-forsomen x y) (gcode (forsome x y)))))
;; (toggle g1408 g-consn t)
;; (toggle g1409 g-f-notn t)
;; (toggle g1410 g-f-orn t)
;; (defthm pr-equaln-reduc3

;;              (implies (and (num-treep x)
;;                            (num-treep y))
;;                       (equal (pr-equaln x y) (bool-fix (ncode-equal x y)))))
;; (defthm g-forsomen-acl2-numberp2

;;              (implies (acl2-numberp x) (equal (g-forsomen x (gcode y)) (gcode (forsome x y)))))
;; (toggle g1411 g-forsomen t)
;; (defthm g-inv-coden-gcode

;;              (implies (and (num-treep x)
;;                            (< (exp-count x) n))
;;                       (equal (g-inv-coden x n) (gcode (inv-code x))))
;;              ((induct (inv-coden-ind x n)) (disable pr-carn pr-cdrn pr-conspn)))
;; (defthm inv-code-gcode (equal (gcode (inv-code (gcode x))) (gcode x)))
;; (toggle g1412 g-inv-code t)
;; (toggle g1413 g-inv-coden t)
;; (toggle g1414 g-inv-code-defun t)
;; ;; correspondence proofs for the "theorem-checker".  there is no lisp function
;; ;; isthm (pronounced "is theorem") because it would have to search upwards
;; ;; along the enumeration of proofs given by (numcode (gcode pf)), until it found a
;; ;; a proof or a disproof of exp.  this search might not terminate.
;; ;; the function g-isthmn however has a stack-counter n which is decremented with
;; ;; each recursive call, and hence does terminate.
;; (defun g-isthmn
;;       (pfn exp given defns symbols n)
;;       (if (or (btmp pfn)
;;               (btmp exp)
;;               (btmp given)
;;               (btmp defns)
;;               (btmp symbols)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-provesn (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                              exp
;;                              given
;;                              defns
;;                              symbols
;;                              (sub1 n))
;;                   (bool-fix t)
;;                   (pr-ifn (g-provesn (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                                      (g-f-notn exp)
;;                                      given
;;                                      defns
;;                                      symbols
;;                                      (sub1 n))
;;                           (bool-fix nil)
;;                           (g-isthmn (pr-add1n pfn) exp given defns symbols (sub1 n))))))
;; (toggle g1415 g-isthm nil)
;; (toggle g1416 g-isthm-defun nil)
;; (defun g-thm-ind
;;       (pfn exp given defns symbols va n)
;;       (if (zerop n)
;;           t
;;           (g-thm-ind (pr-add1 0)
;;                      1
;;                      2
;;                      3
;;                      4
;;                      (ev 1 (list pfn exp given defns symbols) va (fa) n)
;;                      (sub1 n))))
;; (defthm g-isthm-eval

;;              (equal (ev 0 (g-isthm pfn exp given defns symbols) va (fa) n)
;;                     (g-isthmn (ev 0 pfn va (fa) n)
;;                               (ev 0 exp va (fa) n)
;;                               (ev 0 given va (fa) n)
;;                               (ev 0 defns va (fa) n)
;;                               (ev 0 symbols va (fa) n)
;;                               n))
;;              ((induct (g-thm-ind pfn exp given defns symbols va n))))
;; ;; analogous to g-isthmn, we can define g-find-proofn which locates the number of the
;; ;; proof/disproof at which g-isthmn terminated.
;; (defun g-find-proofn
;;       (pfn exp given defns symbols n)
;;       (if (or (btmp pfn)
;;               (btmp exp)
;;               (btmp given)
;;               (btmp defns)
;;               (btmp symbols)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-provesn (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                              exp
;;                              given
;;                              defns
;;                              symbols
;;                              (sub1 n))
;;                   pfn
;;                   (pr-ifn (g-provesn (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                                      (g-f-notn exp)
;;                                      given
;;                                      defns
;;                                      symbols
;;                                      (sub1 n))
;;                           pfn
;;                           (g-find-proofn (pr-add1n pfn) exp given defns symbols (sub1 n))))))
;; ;; decipher is defined in terms of decipher1.
;; (defun decipher (x) (decipher1 x (sub1 x) (sub1 x)))
;; (defun find-proofn
;;       (pfn exp given defns symbols n)
;;       (if (or (btmp exp)
;;               (btmp given)
;;               (btmp defns)
;;               (btmp symbols)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-provesn (g-inv-coden (g-deciphern (gcode pfn) (sub1 n)) (sub1 n))
;;                              exp
;;                              given
;;                              defns
;;                              symbols
;;                              (sub1 n))
;;                   pfn
;;                   (pr-ifn (g-provesn (g-inv-coden (g-deciphern (gcode pfn) (sub1 n)) (sub1 n))
;;                                      (g-f-notn exp)
;;                                      given
;;                                      defns
;;                                      symbols
;;                                      (sub1 n))
;;                           pfn
;;                           (find-proofn (add1 pfn) exp given defns symbols (sub1 n))))))
;; (defun find-proof-ind (pfn n) (if (zerop n) t (find-proof-ind (add1 pfn) (sub1 n))))
;; (toggle g1417 pr-ifn nil)
;; (toggle g1418 bool-fix nil)
;; (toggle g1419 pr-andn nil)
;; (defthm pr-andn-t-or-f1

;;              (implies (and (not (btmp (pr-andn x y)))
;;                            (not (equal (pr-andn x y) (bool-fix nil))))
;;                       (equal (pr-andn x y) (bool-fix t))))
;; (defthm pr-andn-t-or-f2

;;              (implies (and (not (btmp (pr-andn x y)))
;;                            (not (equal (pr-andn x y) (bool-fix t))))
;;                       (equal (pr-andn x y) (bool-fix nil))))
;; (toggle g1420 pr-andn t)
;; (toggle g1421 g-provesn nil)
;; ;; if g-provesn terminates, it returns either (bool-fix t) or (bool-fix nil).
;; (defthm g-provesn-t-or-f1

;;              (implies (and (not (btmp (g-provesn pf exp given defns symbols n)))
;;                            (not (equal (g-provesn pf exp given defns symbols n) (bool-fix nil))))
;;                       (equal (g-provesn pf exp given defns symbols n) (bool-fix t))))
;; (defthm g-provesn-t-or-f2

;;              (implies (and (not (btmp (g-provesn pf exp given defns symbols n)))
;;                            (not (equal (g-provesn pf exp given defns symbols n) (bool-fix t))))
;;                       (equal (g-provesn pf exp given defns symbols n) (bool-fix nil))))
;; (toggle g1422 g-provesn t)
;; (toggle g1423 bool-fix t)
;; (prove-lemma
;;  g-find-proofn-gcode

;;  (implies (not (btmp (g-isthmn (gcode pfn) exp given defns symbols n)))
;;           (equal (g-find-proofn (gcode pfn) exp given defns symbols n)
;;                  (gcode (find-proofn pfn exp given defns symbols n))))
;;  ((disable gcode sub1 g-decipher1n-gcode g-inv-coden-gcode) (induct (find-proof-ind pfn n))))
;; (toggle g1424 pr-ifn t)
;; ;; decipher1 always returns a num-tree.
;; (defthm num-treep-decipher1 (num-treep (decipher1 x y z)))
;; ;; the lemma below essentially says that g-inv-coden returns the gcode of whatever
;; ;; inv-code returns.
;; (prove-lemma
;;  inv-code-decipher

;;  (implies (< (plus (dec-count x (sub1 x) (sub1 x)) (exp-count (decipher x))) n)
;;           (equal (g-inv-coden (g-deciphern (gcode x) n) n) (gcode (inv-code (decipher x)))))
;;  ((disable decipher1 gcode g-inv-coden inv-code g-decipher1n exp-count dec-count sub1)))
;; (toggle g1425 g-inv-coden t)
;; (toggle g1426 g-deciphern t)
;; (toggle g1427 inv-code t)
;; (toggle g1428 decipher t)
;; ;; g-findn returns the value of stack counter n at the point at which g-isthmn located
;; ;; a proof/disproof.
;; (defun g-findn
;;       (pfn exp given defns symbols n)
;;       (if (or (btmp pfn)
;;               (btmp exp)
;;               (btmp given)
;;               (btmp defns)
;;               (btmp symbols)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-provesn (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                              exp
;;                              given
;;                              defns
;;                              symbols
;;                              (sub1 n))
;;                   (sub1 n)
;;                   (pr-ifn (g-provesn (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                                      (g-f-notn exp)
;;                                      given
;;                                      defns
;;                                      symbols
;;                                      (sub1 n))
;;                           (sub1 n)
;;                           (g-findn (pr-add1n pfn) exp given defns symbols (sub1 n))))))
;; ;; g-find-proof returns the gcode of the proof/disproof.
;; (defun g-find-proof
;;       (pfn exp given defns symbols n)
;;       (if (or (btmp pfn)
;;               (btmp exp)
;;               (btmp given)
;;               (btmp defns)
;;               (btmp symbols)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-provesn (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                              exp
;;                              given
;;                              defns
;;                              symbols
;;                              (sub1 n))
;;                   (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                   (pr-ifn (g-provesn (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                                      (g-f-notn exp)
;;                                      given
;;                                      defns
;;                                      symbols
;;                                      (sub1 n))
;;                           (g-inv-coden (g-deciphern pfn (sub1 n)) (sub1 n))
;;                           (g-find-proof (pr-add1n pfn) exp given defns symbols (sub1 n))))))
;; (toggle g1429 pr-ifn nil)
;; (toggle g1430 bool-fix nil)
;; ;; if g-isthmn returns (bool-fix t), then g-find-proof returns the gcode of a proof.
;; (defthm find-proof-proves-t-case

;;              (implies (equal (g-isthmn pfn exp given defns symbols n) (bool-fix t))
;;                       (equal (g-provesn (g-find-proof pfn exp given defns symbols n)
;;                                         exp
;;                                         given
;;                                         defns
;;                                         symbols
;;                                         (g-findn pfn exp given defns symbols n))
;;                              (bool-fix t))))
;; ;; if g-isthmn returns (bool-fix nil), then g-find-proof returns the gcode of a disproof.
;; (defthm find-proof-proves-f-case

;;              (implies (equal (g-isthmn pfn exp given defns symbols n) (bool-fix nil))
;;                       (and (equal (g-provesn (g-find-proof pfn exp given defns symbols n)
;;                                              exp
;;                                              given
;;                                              defns
;;                                              symbols
;;                                              (g-findn pfn exp given defns symbols n))
;;                                   (bool-fix nil))
;;                            (equal (g-provesn (g-find-proof pfn exp given defns symbols n)
;;                                              (g-f-notn exp)
;;                                              given
;;                                              defns
;;                                              symbols
;;                                              (g-findn pfn exp given defns symbols n))
;;                                   (bool-fix t)))))
;; ;; this lemma relates g-find-proof and g-find-proofn (which returns the proof number).
;; (defthm g-find-proof-gcode

;;              (implies (not (btmp (g-isthmn pfn exp given defns symbols n)))
;;                       (equal (g-find-proof pfn exp given defns symbols n)
;;                              (g-inv-coden (g-deciphern (g-find-proofn pfn
;;                                                                       exp
;;                                                                       given
;;                                                                       defns
;;                                                                       symbols
;;                                                                       n)
;;                                                        (g-findn pfn exp given defns symbols n))
;;                                           (g-findn pfn exp given defns symbols n)))))
;; (toggle g1431 g-find-proof t)
;; (toggle g1432 g-find-proofn t)
;; (toggle g1433 g-findn t)
;; (toggle g1434 find-proofn t)
;; (toggle g1435 dec-count t)
;; (defun dec-countn (x) (dec-count x (sub1 x) (sub1 x)))
;; (defun thm-count
;;       (pfn exp var term flg given defns symbols)
;;       (plus (plus (dec-countn pfn) (exp-count (decipher pfn)))
;;             (exp-count (inv-code (decipher pfn)))
;;             (formula-cnt (g-subst exp var term flg) symbols)
;;             (prf-cnt (inv-code (decipher pfn)) given defns 0 symbols)))
;; ;; the same lemmas as above with proves, inv-code, and decipher, instead of
;; ;; g-provesn, g-inv-coden, and g-deciphern.
;; (defthm find-proof-proves-t-case-gcode

;;              (implies (and (< (add1 (thm-count (find-proofn pfn
;;                                                                 (gcode (g-subst exp var term flg))
;;                                                                 (gcode given)
;;                                                                 (gcode defns)
;;                                                                 (gcode symbols)
;;                                                                 n)
;;                                                    exp
;;                                                    var
;;                                                    term
;;                                                    flg
;;                                                    given
;;                                                    defns
;;                                                    symbols))
;;                                   (g-findn (gcode pfn)
;;                                            (gcode (g-subst exp var term flg))
;;                                            (gcode given)
;;                                            (gcode defns)
;;                                            (gcode symbols)
;;                                            n))
;;                            (equal (g-isthmn (gcode pfn)
;;                                             (gcode (g-subst exp var term flg))
;;                                             (gcode given)
;;                                             (gcode defns)
;;                                             (gcode symbols)
;;                                             n)
;;                                   (bool-fix t)))
;;                       (proves (inv-code (decipher (find-proofn pfn
;;                                                                (gcode (g-subst exp var term flg))
;;                                                                (gcode given)
;;                                                                (gcode defns)
;;                                                                (gcode symbols)
;;                                                                n)))
;;                               (g-subst exp var term flg)
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable gcode
;;                        sub1
;;                        g-isthmn
;;                        commutativity-of-plus
;;                        associativity-of-plus
;;                        commutativity2-of-plus)
;;               (use (find-proof-proves-t-case (pfn (gcode pfn))
;;                                              (exp (gcode (g-subst exp var term flg)))
;;                                              (given (gcode given))
;;                                              (defns (gcode defns))
;;                                              (symbols (gcode symbols))))))
;; (defthm find-proof-proves-f-case-case

;;              (implies (equal (g-isthmn pfn exp given defns symbols n) (bool-fix nil))
;;                       (equal (g-provesn (g-find-proof pfn exp given defns symbols n)
;;                                         (g-f-notn exp)
;;                                         given
;;                                         defns
;;                                         symbols
;;                                         (g-findn pfn exp given defns symbols n))
;;                              (bool-fix t)))
;;              ((use (find-proof-proves-f-case))))
;; (defthm <-thm-count1

;;              (< (plus (exp-count (inv-code (decipher pfn)))
;;                           (formula-cnt (g-subst exp var term flg) symbols)
;;                           (prf-cnt (inv-code (decipher pfn)) given defns 0 symbols))
;;                     (add1 (thm-count pfn exp var term flg given defns symbols))))
;; (toggle g1436 find-proof-proves-f-case t)
;; (toggle g1437 subst-ident t)
;; (defthm <-thm-count2

;;              (< (plus (dec-countn pfn) (exp-count (decipher pfn)))
;;                     (add1 (thm-count pfn exp var term flg given defns symbols))))
;; (defthm find-proof-proves-f-case-gcode

;;              (implies (and (< (add1 (thm-count (find-proofn pfn
;;                                                                 (gcode (g-subst exp var term 0))
;;                                                                 (gcode given)
;;                                                                 (gcode defns)
;;                                                                 (gcode symbols)
;;                                                                 n)
;;                                                    (f-not exp)
;;                                                    var
;;                                                    term
;;                                                    0
;;                                                    given
;;                                                    defns
;;                                                    symbols))
;;                                   (g-findn (gcode pfn)
;;                                            (gcode (g-subst exp var term 0))
;;                                            (gcode given)
;;                                            (gcode defns)
;;                                            (gcode symbols)
;;                                            n))
;;                            (equal (g-isthmn (gcode pfn)
;;                                             (gcode (g-subst exp var term 0))
;;                                             (gcode given)
;;                                             (gcode defns)
;;                                             (gcode symbols)
;;                                             n)
;;                                   (bool-fix nil)))
;;                       (proves (inv-code (decipher (find-proofn pfn
;;                                                                (gcode (g-subst exp var term 0))
;;                                                                (gcode given)
;;                                                                (gcode defns)
;;                                                                (gcode symbols)
;;                                                                n)))
;;                               (f-not (g-subst exp var term 0))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable gcode
;;                        sub1
;;                        g-isthmn
;;                        thm-count
;;                        commutativity-of-plus
;;                        associativity-of-plus
;;                        commutativity2-of-plus)
;;               (use (find-proof-proves-f-case-case (pfn (gcode pfn))
;;                                                   (exp (gcode (g-subst exp var term 0)))
;;                                                   (given (gcode given))
;;                                                   (defns (gcode defns))
;;                                                   (symbols (gcode symbols))))))
;; (toggle g1438 thm-count t)
;; ;; now we start constructing the undecidable sentence.
;; (defun a-undec1
;;       (flg exp fa val)
;;       (forsome 1
;;                (f-and (isin (z-list (list (ncode val)
;;                                           (ncode flg)
;;                                           (ncode exp)
;;                                           (z-opair 6 (ncode (gcode nil)))
;;                                           (ncode fa)))
;;                             1)
;;                       (a-ev-defun 1))))
;; (toggle g1439 a-ev1 nil)
;; (toggle g1440 a-ev-defun nil)
;; (toggle g1441 a-ev nil)
;; (defthm replace-va-a-undec1

;;              (equal (g-subst (a-undec1 flg exp fa val) 6 (ncode va1) 0)
;;                     (a-ev1 (ncode flg)
;;                            (ncode exp)
;;                            (z-opair (ncode va1) (ncode (gcode nil)))
;;                            (ncode fa)
;;                            (ncode val))))
;; (toggle g1442 a-ev-defn-part1 nil)
;; (defthm collect-free-a-undec1

;;              (implies (not (member var (collect-free term 0)))
;;                       (not (member var
;;                                    (collect-free (g-subst (a-undec1 flg exp fa val) 6 term 0) 0)))))
;; (toggle g1443 a-ev-defn-part1 t)
;; (toggle g1444 a-ev-defun t)
;; (defthm formula-a-undec1

;;              (implies (all-symbs symbols) (g-formula (a-undec1 flg exp fa val) symbols)))
;; (toggle g1445 a-ev1 t)
;; (toggle g1446 a-ev t)
;; (toggle g1447 bool-fix t)
;; (toggle g1448 g-isthm t)
;; (toggle g1449 g-isthmn t)
;; (defthm numeral-gcode (equal (numeral (gcode x)) (numeral x)))
;; ;; correspondence for gc-ncode.
;; (defun gc-ncoden
;;       (x n)
;;       (if (or (btmp x)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (pr-conspn x)
;;                   (g-z-opairn (gc-ncoden (pr-carn x) (sub1 n)) (gc-ncoden (pr-cdrn x) (sub1 n)))
;;                   (g-numeraln x (sub1 n)))))
;; (toggle g1450 gc-ncode nil)
;; (toggle g1451 gc-ncode-defun nil)
;; (defun gc-ncode-ind
;;       (x va n)
;;       (if (zerop n)
;;           t
;;           (and (gc-ncode-ind (pr-car 0) (ev 1 (list x) va (fa) n) (sub1 n))
;;                (gc-ncode-ind (pr-cdr 0) (ev 1 (list x) va (fa) n) (sub1 n)))))
;; (defthm gc-ncode-eval

;;              (equal (ev 0 (gc-ncode x) va (fa) n) (gc-ncoden (ev 0 x va (fa) n) n))
;;              ((induct (gc-ncode-ind x va n)) (disable pr-carn pr-cdrn pr-conspn)))
;; (toggle g1452 z-opair nil)
;; (toggle g1453 z-sing nil)
;; (toggle g1454 z-pair nil)
;; (defthm z-pairn-gcode (equal (g-z-pairn (gcode x) (gcode y)) (gcode (z-pair x y))))
;; (toggle g1455 z-pair t)
;; (toggle g1456 z-pair t)
;; (toggle g1457 g-z-pairn t)
;; (defthm z-opairn-gcode

;;              (equal (g-z-opairn (gcode x) (gcode y)) (gcode (z-opair x y))))
;; (toggle g1458 z-sing t)
;; (toggle g1459 g-z-singn t)
;; (toggle g1460 z-opair t)
;; (toggle g1461 g-z-opairn t)
;; (toggle g1462 g-numeraln nil)
;; (toggle g1463 ncode nil)
;; (toggle g1464 z-succ nil)
;; (defthm g-z-succ-gcode (equal (g-z-succn (gcode x)) (gcode (z-succ x))))
;; (toggle g1465 z-succ t)
;; (toggle g1466 g-z-succn t)
;; (toggle g1467 pr-zeropn nil)
;; (toggle g1468 pr-sub1n nil)
;; (toggle g1469 pr-add1n nil)
;; (toggle g1470 phi nil)
;; (defthm g-phin-gcode (equal (g-phin) (gcode (phi))))
;; (toggle g1471 phi t)
;; (toggle g1472 g-phin t)
;; (defthm g-numeraln-ncode

;;              (implies (and (< x n)
;;                            (acl2-numberp x))
;;                       (equal (g-numeraln x n) (gcode (ncode x))))
;;              ((induct (numeral-ind x n)) (disable gcode)))
;; (defun ncode-cnt
;;       (x)
;;       (if (consp x) (add1 (plus (ncode-cnt (car x)) (ncode-cnt (cdr x)))) (add1 (fix x))))
;; (defun ncode-ind
;;       (x n)
;;       (if (zerop n)
;;           t
;;           (if (consp x)
;;               (and (ncode-ind (car x) (sub1 n))
;;                    (ncode-ind (cdr x) (sub1 n)))
;;               t)))
;; (defthm gc-ncoden-gcode

;;              (implies (and (< (ncode-cnt x) n)
;;                            (num-treep x))
;;                       (equal (gc-ncoden x n) (gcode (ncode x))))
;;              ((induct (ncode-ind x n)) (disable gcode)))
;; (toggle g1473 gc-ncode t)
;; (toggle g1474 gc-ncoden t)
;; (toggle g1475 ncode t)
;; (defthm gc-ncoden-gcode-again

;;              (implies (< (ncode-cnt (gcode x)) n)
;;                       (equal (gc-ncoden (gcode x) n) (gcode (ncode (gcode x))))))
;; (toggle g1476 gc-ncode-defun t)
;; ;; g-undec (when pfn is 0) is the ev analogue of a the metatheoretic statement,
;; ;; "there exists a proof of the result of substituting (ncode (gcode exp)) for the
;; ;; variable var in exp (from given, defns, and symbols)".

;; (defun g-undec
;;       (pfn exp var given defns symbols)
;;       (g-isthm pfn (g-subst exp var (gc-ncode exp) (pr-quote (gcode 0))) given defns symbols))
;; (defun g-undecn
;;       (pfn exp var given defns symbols n)
;;       (g-isthmn pfn (g-substn exp var (gc-ncoden exp n) (gcode 0) n) given defns symbols n))
;; (defthm g-undec-eval

;;              (equal (ev 0 (g-undec pfn exp var given defns symbols) va (fa) n)
;;                     (g-undecn (ev 0 pfn va (fa) n)
;;                               (ev 0 exp va (fa) n)
;;                               (ev 0 var va (fa) n)
;;                               (ev 0 given va (fa) n)
;;                               (ev 0 defns va (fa) n)
;;                               (ev 0 symbols va (fa) n)
;;                               n)))
;; (toggle g1477 g-undec t)
;; ;; a-undec is the formula from which the undecidable sentence is constructed.
;; ;; it is got from a-ev and asserts that the value of g-undec on a particular
;; ;; exp (represented by a free variable, say "y", in a-undec) with given, defns,
;; ;; and symbols, is (bool-fix nil).  this means that it is asserting, "there is
;; ;; no proof of the result of substituting (ncode (gcode y)) for the variable "y"
;; ;; in y, from given, defns, and symbols."   the undecidable sentence will be got
;; ;; by substituting the formula the ncode of the gcode of a-undec for the free "y"
;; ;; in a-undec itself.
;; (defun a-undec
;;       (given defns symbols)
;;       (a-undec1 0
;;                 (g-undec (pr-quote (gcode 0))
;;                          0
;;                          (pr-quote (gcode 6))
;;                          (pr-quote (gcode given))
;;                          (pr-quote (gcode defns))
;;                          (pr-quote (gcode symbols)))
;;                 (fa)
;;                 (bool-fix nil)))
;; (defun undec-count
;;       (exp var term given defns symbols n)
;;       (plus (add1 (thm-count (find-proofn 0
;;                                           (gcode (g-subst exp var term 0))
;;                                           (gcode given)
;;                                           (gcode defns)
;;                                           (gcode symbols)
;;                                           n)
;;                              (f-not exp)
;;                              var
;;                              term
;;                              0
;;                              given
;;                              defns
;;                              symbols))
;;             (add1 (thm-count (find-proofn 0
;;                                           (gcode (g-subst exp var term 0))
;;                                           (gcode given)
;;                                           (gcode defns)
;;                                           (gcode symbols)
;;                                           n)
;;                              exp
;;                              var
;;                              term
;;                              0
;;                              given
;;                              defns
;;                              symbols))
;;             (ncode-cnt (gcode exp))))
;; (defun isthm-a-proves-a-proof
;;       (pfn exp var term given defns symbols n)
;;       (inv-code (decipher (find-proofn pfn
;;                                        (gcode (g-subst exp var term 0))
;;                                        (gcode given)
;;                                        (gcode defns)
;;                                        (gcode symbols)
;;                                        n))))
;; (defun findn-count
;;       (pfn exp var term given defns symbols n)
;;       (g-findn (gcode pfn)
;;                (gcode (g-subst exp var term 0))
;;                (gcode given)
;;                (gcode defns)
;;                (gcode symbols)
;;                n))
;; (toggle g1478 gcode t)
;; (toggle g1479 exp-count t)
;; ;; the lemma below begins the first of four important lemmas.
;; ;; the undecidable sentence is of the form;
;; ;; (g-subst (a-undec given defns symbols)
;; ;;        6
;; ;;        (ncode (gcode (a-undec given defns symbols))) 0),
;; ;; where defns and symbols will be instantiated by a specific list of
;; ;; definitions and symbols, respectively.  the lemma asserts that if
;; ;; g-isthmn returns (bool-fix t) on the gcode of the undecidable sentence,
;; ;; then the undecidable sentence is provable.  this makes sense because
;; ;; g-isthmn returns (bool-fix t) when it has found a proof in the enumeration
;; ;; of proofs.
;; (defthm isthm-a-proves-a

;;              (implies (and (< (undec-count (a-undec given defns symbols)
;;                                                6
;;                                                (ncode (gcode (a-undec given defns symbols)))
;;                                                given
;;                                                defns
;;                                                symbols
;;                                                n)
;;                                   (findn-count 0
;;                                                (a-undec given defns symbols)
;;                                                6
;;                                                (ncode (gcode (a-undec given defns symbols)))
;;                                                given
;;                                                defns
;;                                                symbols
;;                                                n))
;;                            (< (exp-count (a-undec given defns symbols)) n)
;;                            (equal (g-isthmn (gcode 0)
;;                                             (g-substn (gcode (a-undec given defns symbols))
;;                                                       (gcode 6)
;;                                                       (gcode (ncode (gcode (a-undec given
;;                                                                                     defns
;;                                                                                     symbols))))
;;                                                       (gcode 0)
;;                                                       n)
;;                                             (gcode given)
;;                                             (gcode defns)
;;                                             (gcode symbols)
;;                                             n)
;;                                   (bool-fix t)))
;;                       (proves (isthm-a-proves-a-proof 0
;;                                                       (a-undec given defns symbols)
;;                                                       6
;;                                                       (ncode (gcode (a-undec given
;;                                                                              defns
;;                                                                              symbols)))
;;                                                       given
;;                                                       defns
;;                                                       symbols
;;                                                       n)
;;                               (g-subst (a-undec given defns symbols)
;;                                      6
;;                                      (ncode (gcode (a-undec given defns symbols)))
;;                                      0)
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable a-undec)))
;; ;; similarly, if g-isthmn returns (bool-fix nil), it means that it found a disproof of
;; ;; the undecidable sentence, and its negation is therefore provable.
;; (defthm not-isthm-a-proves-not-a

;;              (implies (and (< (undec-count (a-undec given defns symbols)
;;                                                6
;;                                                (ncode (gcode (a-undec given defns symbols)))
;;                                                given
;;                                                defns
;;                                                symbols
;;                                                n)
;;                                   (findn-count 0
;;                                                (a-undec given defns symbols)
;;                                                6
;;                                                (ncode (gcode (a-undec given defns symbols)))
;;                                                given
;;                                                defns
;;                                                symbols
;;                                                n))
;;                            (< (exp-count (a-undec given defns symbols)) n)
;;                            (equal (g-isthmn (gcode 0)
;;                                             (g-substn (gcode (a-undec given defns symbols))
;;                                                       (gcode 6)
;;                                                       (gcode (ncode (gcode (a-undec given
;;                                                                                     defns
;;                                                                                     symbols))))
;;                                                       (gcode 0)
;;                                                       n)
;;                                             (gcode given)
;;                                             (gcode defns)
;;                                             (gcode symbols)
;;                                             n)
;;                                   (bool-fix nil)))
;;                       (proves (isthm-a-proves-a-proof 0
;;                                                       (a-undec given defns symbols)
;;                                                       6
;;                                                       (ncode (gcode (a-undec given
;;                                                                              defns
;;                                                                              symbols)))
;;                                                       given
;;                                                       defns
;;                                                       symbols
;;                                                       n)
;;                               (f-not (g-subst (a-undec given defns symbols)
;;                                             6
;;                                             (ncode (gcode (a-undec given defns symbols)))
;;                                             0))
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable a-undec)))
;; (toggle g1480 isthm-a-proves-a-proof t)
;; (toggle g1481 a-ev1-not-good-proof t)
;; (defun isthm-a-proves-not-a-proof
;;       (given defns symbols n)
;;       (a-ev1-not-good-proof 0
;;                             (g-undec (pr-quote (gcode 0))
;;                                      0
;;                                      (pr-quote (gcode 6))
;;                                      (pr-quote (gcode given))
;;                                      (pr-quote (gcode defns))
;;                                      (pr-quote (gcode symbols)))
;;                             (cons (gcode (a-undec given defns symbols)) (gcode nil))
;;                             (fa)
;;                             n
;;                             (bool-fix nil)))
;; ;; the more surprising pair of facts are that if g-isthmn returns (bool-fix t)
;; ;; the gcode of the undecidable sentence, then the negation of the undecidable
;; ;; sentence is provable.  this is because the undecidable sentence through the
;; ;; fact that it represents some instance of the lisp interpreter asserts that g-isthmn
;; ;; returns (bool-fix nil) on the undecidable sentence itself, which in this case is false.
;; (defthm isthm-a-proves-not-a-proof-proves

;;              (implies (and (ev-hyps given defns symbols)
;;                            (< (ncode-cnt (gcode (a-undec given defns symbols))) n)
;;                            (< (exp-count (a-undec given defns symbols)) n)
;;                            (equal (g-isthmn (gcode 0)
;;                                             (gcode (g-subst (a-undec given defns symbols)
;;                                                           6
;;                                                           (ncode (gcode (a-undec given
;;                                                                                  defns
;;                                                                                  symbols)))
;;                                                           0))
;;                                             (gcode given)
;;                                             (gcode defns)
;;                                             (gcode symbols)
;;                                             n)
;;                                   (bool-fix t))
;;                            (equal concl
;;                                   (f-not (g-subst (a-undec given defns symbols)
;;                                                 6
;;                                                 (ncode (gcode (a-undec given defns symbols)))
;;                                                 0))))
;;                       (proves (isthm-a-proves-not-a-proof given defns symbols n)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable subst a-undec1)))
;; (toggle g1482 isthm-a-proves-not-a-proof t)
;; (defun not-isthm-a-proves-a-proof
;;       (given defns symbols n)
;;       (a-ev1-ok-proof 0
;;                       (g-undec (pr-quote (gcode 0))
;;                                0
;;                                (pr-quote (gcode 6))
;;                                (pr-quote (gcode given))
;;                                (pr-quote (gcode defns))
;;                                (pr-quote (gcode symbols)))
;;                       (cons (gcode (a-undec given defns symbols)) (gcode nil))
;;                       (fa)
;;                       n))
;; ;; if g-isthmn returns (bool-fix nil) on the the gcode of the undecidable sentence,
;; ;; then the undecidable sentence is provable.  this is because the undecidable
;; ;; sentence through the fact that it represents some instance of the lisp interpreter
;; ;; asserts that g-isthmn does return (bool-fix nil) on the undecidable sentence itself.
;; (defthm not-isthm-a-proves-a-proof-proves

;;              (implies (and (ev-hyps given defns symbols)
;;                            (< (ncode-cnt (gcode (a-undec given defns symbols))) n)
;;                            (< (exp-count (a-undec given defns symbols)) n)
;;                            (equal (g-isthmn (gcode 0)
;;                                             (gcode (g-subst (a-undec given defns symbols)
;;                                                           6
;;                                                           (ncode (gcode (a-undec given
;;                                                                                  defns
;;                                                                                  symbols)))
;;                                                           0))
;;                                             (gcode given)
;;                                             (gcode defns)
;;                                             (gcode symbols)
;;                                             n)
;;                                   (bool-fix nil))
;;                            (equal concl
;;                                   (g-subst (a-undec given defns symbols)
;;                                          6
;;                                          (ncode (gcode (a-undec given defns symbols)))
;;                                          0)))
;;                       (proves (not-isthm-a-proves-a-proof given defns symbols n)
;;                               concl
;;                               given
;;                               defns
;;                               symbols))
;;              ((disable subst a-undec1)))
;; ;; now we need to prove that if z2 is complete, then g-isthmn returns either (bool-fix t)
;; ;; or (bool-fix nil).  then by the above four lemmas, we have that the undecidable sentence
;; ;; is both provable and disprovable.  therefore, we would have established that z2 is
;; ;; either incomplete or inconsistent.
;; (toggle g1483 isthm-a-proves-not-a-proof t)
;; (defun thm-count1
;;       (pfn exp given defns symbols)
;;       (plus (plus (dec-countn pfn) (exp-count (decipher pfn)))
;;             (exp-count (inv-code (decipher pfn)))
;;             (formula-cnt exp symbols)
;;             (prf-cnt (inv-code (decipher pfn)) given defns 0 symbols)))
;; (defthm thm-count1-<

;;              (< (plus (dec-count pfn (sub1 pfn) (sub1 pfn)) (exp-count (decipher pfn)))
;;                     (add1 (thm-count1 pfn exp given defns symbols))))
;; (defthm thm-count1-<1

;;              (< (plus (exp-count (inv-code (decipher pfn)))
;;                           (formula-cnt exp symbols)
;;                           (prf-cnt (inv-code (decipher pfn)) given defns 0 symbols))
;;                     (add1 (thm-count1 pfn exp given defns symbols))))
;; (toggle g1484 thm-count1 t)
;; (defun comp-count
;;       (pf pfn exp given defns symbols extras)
;;       (if (leq pf pfn)
;;           (plus (add1 (thm-count1 pfn exp given defns symbols))
;;                 (add1 (thm-count1 pfn (f-not exp) given defns symbols))
;;                 (add1 extras))
;;           (if (proves (inv-code (decipher pfn)) exp given defns symbols)
;;               (plus (add1 (thm-count1 pfn exp given defns symbols))
;;                     (add1 (thm-count1 pfn (f-not exp) given defns symbols))
;;                     (add1 extras))
;;               (if (proves (inv-code (decipher pfn)) (f-not exp) given defns symbols)
;;                   (plus (add1 (thm-count1 pfn exp given defns symbols))
;;                         (add1 (thm-count1 pfn (f-not exp) given defns symbols))
;;                         (add1 extras))
;;                   (plus (add1 (thm-count1 pfn exp given defns symbols))
;;                         (add1 (thm-count1 pfn (f-not exp) given defns symbols))
;;                         (add1 extras)
;;                         (add1 (comp-count pf (add1 pfn) exp given defns symbols extras))))))
;;       ((< (difference pf pfn))))
;; (defun proves-isthmn-ind
;;       (pf pfn exp given defns symbols n)
;;       (if (zerop n)
;;           t
;;           (if (leq pf pfn)
;;               t
;;               (if (proves (inv-code (decipher pfn)) exp given defns symbols)
;;                   t
;;                   (if (proves (inv-code (decipher pfn)) (f-not exp) given defns symbols)
;;                       t
;;                       (proves-isthmn-ind pf (add1 pfn) exp given defns symbols (sub1 n)))))))
;; (toggle g1485 g-isthmn nil)
;; (defthm <-comp-count1

;;              (< (thm-count1 pfn exp given defns symbols)
;;                     (comp-count pf pfn exp given defns symbols extras)))
;; (defthm <-comp-count2

;;              (< (thm-count1 pfn (f-not exp) given defns symbols)
;;                     (comp-count pf pfn exp given defns symbols extras)))
;; (defthm <-extras-comp-count

;;              (< extras (comp-count pf pfn exp given defns symbols extras)))
;; (toggle g1486 find-proof-proves-f-case-gcode t)
;; (toggle g1487 find-proof-proves-t-case-gcode t)
;; (toggle g1488 g-provesn-t-or-f1 t)
;; (toggle g1489 g-provesn-t-or-f2 t)
;; (toggle g1490 pr-ifn t)
;; ;; the lemma below is the crucial one in the final proof of the incompleteness theorem.
;; ;; it asserts that if there is a number pf which corresponds to a proof or disproof of exp,
;; ;; then g-isthmn (with a large enough stack-counter) when started on a proof-number pfn
;; ;; less than or equal to pf, will either find pf or some proof/disproof before it, and
;; ;; will therefore either return (bool-fix t) or (bool-fix nil).  this with the four lemmas
;; ;; above provides enough material to prove the incompleteness theorem, but we still need
;; ;; to build up a large enough stack-counter to cover all these five lemmas.
;; (prove-lemma
;;  proves-t-not-btmp-isthmn

;;  (implies (and (acl2-numberp pfn)
;;                (acl2-numberp pf)
;;                (or (proves (inv-code (decipher pf)) exp given defns symbols)
;;                    (proves (inv-code (decipher pf)) (f-not exp) given defns symbols))
;;                (leq pfn pf)
;;                (< (comp-count pf pfn exp given defns symbols extras) n))
;;           (or (equal (g-isthmn (gcode pfn)
;;                                (gcode exp)
;;                                (gcode given)
;;                                (gcode defns)
;;                                (gcode symbols)
;;                                n)
;;                      (bool-fix t))
;;               (equal (g-isthmn (gcode pfn)
;;                                (gcode exp)
;;                                (gcode given)
;;                                (gcode defns)
;;                                (gcode symbols)
;;                                n)
;;                      (bool-fix nil))))
;;  ((induct (proves-isthmn-ind pf pfn exp given defns symbols n)) (disable commutativity-of-plus
;;                                                                          commutativity2-of-plus
;;                                                                          associativity-of-plus)))
;; (toggle g1491 proves-t-not-btmp-isthmn t)
;; (toggle g1492 find-proofn nil)
;; (defun findn
;;       (pfn exp given defns symbols n)
;;       (if (or (btmp exp)
;;               (btmp given)
;;               (btmp defns)
;;               (btmp symbols)
;;               (zerop n))
;;           (btm)
;;           (pr-ifn (g-provesn (g-inv-coden (g-deciphern (gcode pfn) (sub1 n)) (sub1 n))
;;                              exp
;;                              given
;;                              defns
;;                              symbols
;;                              (sub1 n))
;;                   (sub1 n)
;;                   (pr-ifn (g-provesn (g-inv-coden (g-deciphern (gcode pfn) (sub1 n)) (sub1 n))
;;                                      (g-f-notn exp)
;;                                      given
;;                                      defns
;;                                      symbols
;;                                      (sub1 n))
;;                           (sub1 n)
;;                           (findn (add1 pfn) exp given defns symbols (sub1 n))))))
;; (toggle g1493 pr-ifn t)
;; (defthm <-comp-count3

;;              (< (plus (thm-count1 pfn (f-not exp) given defns symbols)
;;                           (thm-count1 pfn exp given defns symbols)
;;                           extras)
;;                     (comp-count pf pfn exp given defns symbols extras))
;;              ((induct (comp-count pf pfn exp given defns symbols extras))))
;; (prove-lemma
;;  findn-thm-count-<

;;  (implies (and (acl2-numberp pfn)
;;                (acl2-numberp pf)
;;                (or (proves (inv-code (decipher pf)) exp given defns symbols)
;;                    (proves (inv-code (decipher pf)) (f-not exp) given defns symbols))
;;                (leq pfn pf)
;;                (< (add1 (add1 (comp-count pf pfn exp given defns symbols extras))) n))
;;           (< (plus (add1 (thm-count1 (find-proofn pfn
;;                                                       (gcode exp)
;;                                                       (gcode given)
;;                                                       (gcode defns)
;;                                                       (gcode symbols)
;;                                                       n)
;;                                          (f-not exp)
;;                                          given
;;                                          defns
;;                                          symbols))
;;                        (add1 (thm-count1 (find-proofn pfn
;;                                                       (gcode exp)
;;                                                       (gcode given)
;;                                                       (gcode defns)
;;                                                       (gcode symbols)
;;                                                       n)
;;                                          exp
;;                                          given
;;                                          defns
;;                                          symbols))
;;                        extras)
;;                  (findn pfn (gcode exp) (gcode given) (gcode defns) (gcode symbols) n)))
;;  ((induct (proves-isthmn-ind pf pfn exp given defns symbols n)) (disable commutativity-of-plus
;;                                                                          commutativity2-of-plus
;;                                                                          associativity-of-plus
;;                                                                          proves-is-formula-again
;;                                                                          exp-count)))
;; (toggle g1494 g-findn nil)
;; (defthm findn-g-findn

;;              (equal (g-findn (gcode pfn) exp given defns symbols n)
;;                     (findn pfn exp given defns symbols n))
;;              ((induct (find-proof-ind pfn n))))
;; (toggle g1495 g-findn t)
;; (toggle g1496 thm-count nil)
;; (toggle g1497 thm-count1 nil)
;; (defthm thm-count-thm-count1

;;              (equal (thm-count pfn exp var term flg given defns symbols)
;;                     (thm-count1 pfn (g-subst exp var term flg) given defns symbols)))
;; (toggle g1498 thm-count t)
;; (toggle g1499 thm-count1 t)
;; (toggle g1500 decipher nil)
;; (defthm num-treep-num-treep (equal (numtreep x) (num-treep x)))
;; (defthm inv-code-decipher-numcode

;;              (equal (gcode (inv-code (decipher (numcode (gcode x))))) (gcode x)))
;; (toggle g1501 decipher t)
;; (toggle g1502 bool-fix nil)
;; (prove-lemma
;;  proves-inv-code-decipher

;;  (equal (proves (inv-code (decipher (numcode (gcode pf)))) exp given defns symbols)
;;         (proves pf exp given defns symbols))
;;  ((use (g-provesn-gcode (n (add1 (plus (exp-count (inv-code (decipher (numcode (gcode pf)))))
;;                                        (formula-cnt exp symbols)
;;                                        (prf-cnt (inv-code (decipher (numcode (gcode pf))))
;;                                                 given
;;                                                 defns
;;                                                 0
;;                                                 symbols)
;;                                        (exp-count pf)
;;                                        (prf-cnt pf given defns 0 symbols))))
;;                         (pf (inv-code (decipher (numcode (gcode pf))))))
;;        (g-provesn-gcode (n (add1 (plus (exp-count (inv-code (decipher (numcode (gcode pf)))))
;;                                        (formula-cnt exp symbols)
;;                                        (prf-cnt (inv-code (decipher (numcode (gcode pf))))
;;                                                 given
;;                                                 defns
;;                                                 0
;;                                                 symbols)
;;                                        (exp-count pf)
;;                                        (prf-cnt pf given defns 0 symbols))))))
;;   (disable g-provesn-gcode inv-code-gcode)))
;; (toggle g1503 findn t)
;; (toggle g1504 bool-fix t)
;; ;; the undecidable sentence - defns and symbols will have to be instantiated, but
;; ;; given will be left as a parameter so that for any specific given, we get a specific
;; ;; undecidable sentence.  this would show that the addition of the undecidable sentence
;; ;; or any finite list of new axioms will still leave the theory incomplete or inconsistent.
;; (defun undec-sent
;;       (given defns symbols)
;;       (g-subst (a-undec given defns symbols) 6 (ncode (gcode (a-undec given defns symbols))) 0))
;; (defun final-count
;;       (pf given defns symbols)
;;       (add1 (plus (add1 (add1 (comp-count (numcode (gcode pf))
;;                                           0
;;                                           (undec-sent given defns symbols)
;;                                           given
;;                                           defns
;;                                           symbols
;;                                           (ncode-cnt (gcode (a-undec given defns symbols))))))
;;                   (add1 (ncode-cnt (gcode (a-undec given defns symbols))))
;;                   (add1 (exp-count (a-undec given defns symbols))))))
;; (toggle g1505 ncode-cnt t)
;; (toggle g1506 proves-is-formula-again t)
;; (toggle g1507 comp-count t)
;; (toggle g1508 numcode t)
;; (toggle g1509 exp-count t)
;; (toggle g1510 findn-thm-count-< t)
;; (defthm undec-count-<

;;              (implies (and (acl2-numberp pf)
;;                            (or (proves (inv-code (decipher pf))
;;                                        (g-subst exp var term 0)
;;                                        given
;;                                        defns
;;                                        symbols)
;;                                (proves (inv-code (decipher pf))
;;                                        (f-not (g-subst exp var term 0))
;;                                        given
;;                                        defns
;;                                        symbols))
;;                            (< (add1 (add1 (comp-count pf
;;                                                           0
;;                                                           (g-subst exp var term 0)
;;                                                           given
;;                                                           defns
;;                                                           symbols
;;                                                           (ncode-cnt (gcode exp)))))
;;                                   n))
;;                       (< (undec-count exp var term given defns symbols n)
;;                              (findn 0
;;                                     (gcode (g-subst exp var term 0))
;;                                     (gcode given)
;;                                     (gcode defns)
;;                                     (gcode symbols)
;;                                     n)))
;;              ((use (findn-thm-count-< (pfn 0)
;;                                           (extras (ncode-cnt (gcode exp)))
;;                                           (exp (g-subst exp var term 0))))
;;               (disable a-undec g-isthmn g-provesn-gcode inv-code-decipher find-proofn)))
;; (toggle g1511 undec-count t)
;; (toggle g1512 not-isthm-a-proves-a-proof t)
;; (defthm comp-count-final-count-<

;;              (< (add1 (add1 (comp-count (numcode (gcode pf))
;;                                             0
;;                                             (g-subst (a-undec given defns symbols)
;;                                                    6
;;                                                    (ncode (gcode (a-undec given defns symbols)))
;;                                                    0)
;;                                             given
;;                                             defns
;;                                             symbols
;;                                             (ncode-cnt (gcode (a-undec given defns symbols))))))
;;                     (final-count pf given defns symbols))
;;              ((disable a-undec)))
;; (defthm <-ncode-cnt-final-count

;;              (< (ncode-cnt (gcode (a-undec given defns symbols)))
;;                     (final-count pf given defns symbols))
;;              ((disable a-undec)))
;; (defthm <-exp-count-final-count

;;              (< (exp-count (a-undec given defns symbols)) (final-count pf given defns symbols))
;;              ((disable exp-count a-undec)))
;; (defthm <-num-final-count (< 4 (final-count pf given defns symbols)))
;; ;; the final list of symbols, thm-symbs.
;; (defun thm-symbs
;;       nil
;;       (list (fn 16 1)
;;             (fn 15 2)
;;             (fn 14 2)
;;             (fn 13 2)
;;             (fn 12 2)
;;             (fn 11 2)
;;             (fn 10 1)
;;             (fn 9 1)
;;             (fn 8 1)
;;             (fn 7 1)
;;             (fn 6 1)
;;             (fn 5 1)
;;             (fn 4 1)
;;             (fn 3 1)
;;             (p 2 1)
;;             (fn 2 2)
;;             (fn 1 2)
;;             (p 1 2)
;;             (fn 0 0)))
;; ;; the final list of function/predicate definitions.
;; (defun thm-defns
;;       nil
;;       (list (cons (p 2 1) (z-int-defun 0 1 2))
;;             (cons (fn 3 1) (f-equal (z-succ 0) (z-union (z-sing 0) 0)))
;;             (cons (fn 4 1) (z-car-defun 0 (z-car 0) 1 2))
;;             (cons (fn 5 1) (z-cdr-defun 0 (z-cdr 0) 1 2))
;;             (cons (fn 6 1) (z-consp-defun 0 (z-consp 0) 1 2))
;;             (cons (fn 7 1) (z-add1-defun 0 (z-add1 0) 1 2))
;;             (cons (fn 8 1) (z-acl2-numberp-defun 0 (z-acl2-numberp 0)))
;;             (cons (fn 9 1) (z-zerop-defun 0 (z-zerop 0)))
;;             (cons (fn 10 1) (z-sub1-defun 0 (z-sub1 0) 3))
;;             (cons (fn 11 2) (z-equal-defun 0 1 (z-equal 0 1)))
;;             (cons (fn 12 2) (z-cons-defun 0 1 (z-cons 0 1)))
;;             (cons (fn 13 2) (z-apply-subr1-defun 0 1 (z-apply-subr1 0 1)))
;;             (cons (fn 14 2) (z-apply-subr2-defun 0 1 (z-apply-subr2 0 1)))
;;             (cons (fn 15 2) (z-apply-subr-defun 0 1 (z-apply-subr 0 1)))
;;             (cons (fn 16 1) (z-subrp-defun 0 (z-subrp 0)))))
;; (toggle g1549 z-subrp-hyps nil)
;; (toggle g1550 z-apply-subr-hyps nil)
;; (toggle g1551 z-apply-subr1-hyps nil)
;; (toggle g1552 z-apply-subr2-hyps nil)
;; (toggle g1553 z-succ-hyps nil)
;; (toggle g1554 z-int-hyps nil)
;; (toggle g1555 z-car-hyps nil)
;; (toggle g1556 z-cdr-hyps nil)
;; (toggle g1557 z-consp-hyps nil)
;; (toggle g1558 z-cons-hyps nil)
;; (toggle g1559 z-add1-hyps nil)
;; (toggle g1560 z-sub1-hyps nil)
;; (toggle g1561 z-equal-hyps nil)
;; (toggle g1562 z-acl2-numberp-hyps nil)
;; (toggle g1563 rest-of nil)
;; (toggle g1564 eql-gcode-equal t)
;; (defthm ev-hyps-z-int (z-int-hyps (thm-defns) (thm-symbs)))
;; (defthm ev-hyps-z-succ (z-succ-hyps (thm-defns) (thm-symbs)))
;; (defthm ev-hyps-z-car (z-car-hyps (thm-defns) (thm-symbs)))
;; (defthm ev-hyps-z-cdr (z-cdr-hyps (thm-defns) (thm-symbs)))
;; (defthm z-consp-ev-hyps (z-consp-hyps (thm-defns) (thm-symbs)))
;; (defthm z-cons-ev-hyps (z-cons-hyps (thm-defns) (thm-symbs)))
;; (defthm z-acl2-numberp-ev-hyps (z-acl2-numberp-hyps (thm-defns) (thm-symbs)))
;; (defthm z-equal-ev-hyps (z-equal-hyps (thm-defns) (thm-symbs)))
;; (defthm z-add1-ev-hyps (z-add1-hyps (thm-defns) (thm-symbs)))
;; (defthm z-sub1-ev-hyps (z-sub1-hyps (thm-defns) (thm-symbs)))
;; (toggle g1565 subset-cons t)
;; (toggle g1566 prime-member t)
;; (toggle g1567 member-delete t)
;; (defthm z-apply-subr1-ev-hyps

;;              (z-apply-subr1-hyps (thm-defns) (thm-symbs))
;;              ((disable z-apply-subr1-defun z-apply-subr2-defun z-apply-subr-defn)))
;; (defthm z-apply-subr2-ev-hyps

;;              (z-apply-subr2-hyps (thm-defns) (thm-symbs))
;;              ((disable z-apply-subr1-defun z-apply-subr2-defun z-apply-subr-defn)))
;; (defthm z-apply-subr-ev-hyps

;;              (z-apply-subr-hyps (thm-defns) (thm-symbs))
;;              ((disable z-apply-subr1-defun z-apply-subr2-defun z-apply-subr-defn)))
;; (defthm z-subrp-ev-hyps (z-subrp-hyps (thm-defns) (thm-symbs)))
;; (toggle g1568 z-subrp-hyps t)
;; (toggle g1569 z-apply-subr-hyps t)
;; (toggle g1570 z-apply-subr1-hyps t)
;; (toggle g1571 z-apply-subr2-hyps t)
;; (toggle g1572 z-succ-hyps t)
;; (toggle g1573 z-int-hyps t)
;; (toggle g1574 z-car-hyps t)
;; (toggle g1575 z-cdr-hyps t)
;; (toggle g1576 z-consp-hyps t)
;; (toggle g1577 z-cons-hyps t)
;; (toggle g1578 z-add1-hyps t)
;; (toggle g1579 z-sub1-hyps t)
;; (toggle g1580 z-equal-hyps t)
;; (toggle g1581 z-acl2-numberp-hyps t)
;; (defthm subset-thm-symbs

;;              (subset (list (fn 16 1)
;;                            (fn 15 2)
;;                            (fn 14 2)
;;                            (fn 13 2)
;;                            (fn 12 2)
;;                            (fn 0 0)
;;                            (fn 3 1)
;;                            (fn 4 1)
;;                            (fn 5 1)
;;                            (fn 6 1)
;;                            (fn 7 1)
;;                            (fn 8 1)
;;                            (fn 9 1)
;;                            (fn 10 1)
;;                            (fn 11 2)
;;                            (fn 1 2)
;;                            (fn 2 2)
;;                            (p 2 1)
;;                            (p 1 2))
;;                      (thm-symbs)))
;; (toggle g1585 z-zerop-hyps nil)
;; (defthm z-zerop-ev-hyps (z-zerop-hyps (thm-defns) (thm-symbs)))
;; (toggle g1586 rest-of t)
;; (toggle g1587 thm-defns t)
;; (defthm all-symbs-thm-symbs (all-symbs (thm-symbs)))
;; (toggle g1589 thm-symbs t)
;; (defthm ev-hyps-thm-defns-symbols

;;              (ev-hyps given (thm-defns) (thm-symbs))
;;              ((disable subset) (use (subset-thm-symbs))))
;; (defthm all-symbs-termp-ncode (implies (all-symbs symbs) (g-termp (ncode x) 0 symbs)))
;; (toggle g1591 all-symbs t)
;; (defthm formula-undec-sent

;;              (implies (all-symbs symbs) (g-formula (undec-sent given defns symbs) symbs))
;;              ((disable a-undec1 replace-va-a-undec1)))
;; ;; the lemma below is very nearly the final one.  it asserts that if pf is either
;; ;; a proof or disproof of the undecidable sentence, then in one of two possible ways
;; ;; (as given by the four lemmas above), the undecidable sentence is both provable and
;; ;; disprovable.  the observation is that if z2 was complete, the undecidable sentence
;; ;; would either be a provable or disprovable.  pf below could be instantiated with
;; ;; the given proof/disproof, yielding the conclusion of the lemma that z2 is then
;; ;; inconsistent.  we still need to show that the undecidable sentence below is a
;; ;; z2 formula and that it contains no free variables.  this is done next.
;; (prove-lemma
;;  incompleteness-main-part

;;  (implies (or (proves pf (undec-sent given (thm-defns) (thm-symbs)) given (thm-defns) (thm-symbs))
;;               (proves pf
;;                       (f-not (undec-sent given (thm-defns) (thm-symbs)))
;;                       given
;;                       (thm-defns)
;;                       (thm-symbs)))
;;           (or (and (proves (isthm-a-proves-a-proof 0
;;                                                    (a-undec given (thm-defns) (thm-symbs))
;;                                                    6
;;                                                    (ncode (gcode (a-undec given
;;                                                                           (thm-defns)
;;                                                                           (thm-symbs))))
;;                                                    given
;;                                                    (thm-defns)
;;                                                    (thm-symbs)
;;                                                    (final-count pf given (thm-defns) (thm-symbs)))
;;                            (undec-sent given (thm-defns) (thm-symbs))
;;                            given
;;                            (thm-defns)
;;                            (thm-symbs))
;;                    (proves (isthm-a-proves-not-a-proof given
;;                                                        (thm-defns)
;;                                                        (thm-symbs)
;;                                                        (final-count pf
;;                                                                     given
;;                                                                     (thm-defns)
;;                                                                     (thm-symbs)))
;;                            (f-not (undec-sent given (thm-defns) (thm-symbs)))
;;                            given
;;                            (thm-defns)
;;                            (thm-symbs)))
;;               (and (proves (not-isthm-a-proves-a-proof given
;;                                                        (thm-defns)
;;                                                        (thm-symbs)
;;                                                        (final-count pf
;;                                                                     given
;;                                                                     (thm-defns)
;;                                                                     (thm-symbs)))
;;                            (undec-sent given (thm-defns) (thm-symbs))
;;                            given
;;                            (thm-defns)
;;                            (thm-symbs))
;;                    (proves (isthm-a-proves-a-proof 0
;;                                                    (a-undec given (thm-defns) (thm-symbs))
;;                                                    6
;;                                                    (ncode (gcode (a-undec given
;;                                                                           (thm-defns)
;;                                                                           (thm-symbs))))
;;                                                    given
;;                                                    (thm-defns)
;;                                                    (thm-symbs)
;;                                                    (final-count pf
;;                                                                 given
;;                                                                 (thm-defns)
;;                                                                 (thm-symbs)))
;;                            (f-not (undec-sent given (thm-defns) (thm-symbs)))
;;                            given
;;                            (thm-defns)
;;                            (thm-symbs)))))
;;  ((use (proves-t-not-btmp-isthmn (pf (numcode (gcode pf)))
;;                                  (pfn 0)
;;                                  (defns (thm-defns))
;;                                  (symbols (thm-symbs))
;;                                  (exp (undec-sent given (thm-defns) (thm-symbs)))
;;                                  (n (final-count pf given (thm-defns) (thm-symbs)))
;;                                  (extras (ncode-cnt (gcode (a-undec given
;;                                                                     (thm-defns)
;;                                                                     (thm-symbs))))))
;;        (undec-count-< (pf (numcode (gcode pf)))
;;                           (exp (a-undec given (thm-defns) (thm-symbs)))
;;                           (defns (thm-defns))
;;                           (symbols (thm-symbs))
;;                           (var 6)
;;                           (term (ncode (gcode (a-undec given (thm-defns) (thm-symbs)))))
;;                           (n (final-count pf given (thm-defns) (thm-symbs)))))
;;   (disable a-undec
;;            subst
;;            g-isthmn
;;            g-provesn-gcode
;;            inv-code-decipher
;;            find-proofn
;;            undec-count-<
;;            inv-code-decipher-numcode
;;            exp-count)))
;; (defthm collect-free-undec-sent

;;              (not (member var (collect-free (undec-sent given defns symbs) 0)))
;;              ((disable replace-va-a-undec1 a-undec1)))
;; (toggle g1593 undec-sent t)
;; ;; the undecidable sentence: undec-sent with defns and symbols instantiated.o
;; (defun undecidable-sentence (given) (undec-sent given (thm-defns) (thm-symbs)))
;; (defun some-proof1
;;       (given pf)
;;       (isthm-a-proves-a-proof 0
;;                               (a-undec given (thm-defns) (thm-symbs))
;;                               6
;;                               (ncode (gcode (a-undec given (thm-defns) (thm-symbs))))
;;                               given
;;                               (thm-defns)
;;                               (thm-symbs)
;;                               (final-count pf given (thm-defns) (thm-symbs))))
;; (defun some-disproof1
;;       (given pf)
;;       (isthm-a-proves-not-a-proof given
;;                                   (thm-defns)
;;                                   (thm-symbs)
;;                                   (final-count pf given (thm-defns) (thm-symbs))))
;; (defun some-proof2
;;       (given pf)
;;       (not-isthm-a-proves-a-proof given
;;                                   (thm-defns)
;;                                   (thm-symbs)
;;                                   (final-count pf given (thm-defns) (thm-symbs))))
;; (defun some-disproof2
;;       (given pf)
;;       (isthm-a-proves-a-proof 0
;;                               (a-undec given (thm-defns) (thm-symbs))
;;                               6
;;                               (ncode (gcode (a-undec given (thm-defns) (thm-symbs))))
;;                               given
;;                               (thm-defns)
;;                               (thm-symbs)
;;                               (final-count pf given (thm-defns) (thm-symbs))))
;; ;; the final statement of the incompleteness theorem: [1] the undecidable sentence
;; ;; is a z2 formula in a theory whose symbols are from (thm-symbs),
;; ;; [2] the undecidable sentence is a sentence, i.e., contains no variables var free,
;; ;; [3] if the undecidable sentence is either provable or disprovable, then it is
;; ;; both provable and disprovable.
;; (defthm incompleteness-theorem

;;              (and (g-formula (undecidable-sentence given) (thm-symbs))
;;                   (not (member var (collect-free (undecidable-sentence given) 0)))
;;                   (implies (or (proves pf
;;                                        (undecidable-sentence given)
;;                                        given
;;                                        (thm-defns)
;;                                        (thm-symbs))
;;                                (proves pf
;;                                        (f-not (undecidable-sentence given))
;;                                        given
;;                                        (thm-defns)
;;                                        (thm-symbs)))
;;                            (or (and (proves (some-proof1 given pf)
;;                                             (undecidable-sentence given)
;;                                             given
;;                                             (thm-defns)
;;                                             (thm-symbs))
;;                                     (proves (some-disproof1 given pf)
;;                                             (f-not (undecidable-sentence given))
;;                                             given
;;                                             (thm-defns)
;;                                             (thm-symbs)))
;;                                (and (proves (some-proof2 given pf)
;;                                             (undecidable-sentence given)
;;                                             given
;;                                             (thm-defns)
;;                                             (thm-symbs))
;;                                     (proves (some-disproof2 given pf)
;;                                             (f-not (undecidable-sentence given))
;;                                             given
;;                                             (thm-defns)
;;                                             (thm-symbs))))))
;;              ((use (incompleteness-main-part)) (disable a-undec
;;                                             subst
;;                                             g-isthmn
;;                                             g-provesn-gcode
;;                                             inv-code-decipher
;;                                             find-proofn
;;                                             undec-count-<
;;                                             inv-code-decipher-numcode
;;                                             incompleteness-main-part
;;                                             exp-count)))





;; ;;;;;;;;;;;;;;



;;  BOOT-STRAP loads basic library of axioms about lists, litatoms, and numbers.
;;
;; (BOOT-STRAP)
;; (COMPILE-UNCOMPILED-DEFNS "tmp")

;;  Turn off the use of the compiled lisp definitions for the non-boot-strap
;;  Functions.
;;  (toggle-defined-functions turn-off-lisp-defns t)


;;  f-not is the negation shell.
;; (add-shell f-not nil f-notp ((arg (none-of) zero)))

;; f-or is the disjunction shell.
;;  (add-shell f-or nil f-orp ((arg1 (none-of) zero) (arg2 (none-of) zero)))

;; forsome is the existential quantification shell.
;;  (add-shell forsome nil forsomep
;;             ((bind (one-of acl2-numberp) zero) (g-body (none-of) zero)))
